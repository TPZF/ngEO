(function() {
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/



/**************************************************************************************************************/

/**
	Declare namespace for Numeric functions.
	TODO : Should be put into GlobWeb
 */
var Numeric = {};

/**************************************************************************************************************/

/**
  Linear interpolation between [a, b], t must be [0, 1]
*/
Numeric.lerp = function(t, a, b)
{
    return a + ((b - a) * t);
}

/**************************************************************************************************************/

/**
  Cosine interpolation between [a, b], t must be [0, 1]
*/
Numeric.coserp = function(t, a, b)
{
	var t2 = (1 - Math.cos(t * Math.PI))/2;
    return a + ((b - a) * t2);
}

/**************************************************************************************************************/

/**
 Cubic interpolation between [a, b], t must be [0, 1]
*/
Numeric.cubicInterpolation = function(t, startPos, startVel, endPos, endVel)
{
	var t2 = t * t;
	var t3 = t2 * t; 
	
	// Evaluate the position
	
	var M00 = 2 * startPos[0] - 2 * endPos[0] + startVel[0] + endVel[0];
	var M10 = 2 * startPos[1] - 2 * endPos[1] + startVel[1] + endVel[1];
	var M20 = 2 * startPos[2] - 2 * endPos[2] + startVel[2] + endVel[2];

	var M01 = -3 * startPos[0] + 3 * endPos[0] - 2 * startVel[0] - endVel[0];
	var M11 = -3 * startPos[1] + 3 * endPos[1] - 2 * startVel[1] - endVel[1];
	var M21 = -3 * startPos[2] + 3 * endPos[2] - 2 * startVel[2] - endVel[2];
	
	var position = vec3.create();
	position[0] = M00 * t3 + M01 * t2 + startVel[0] * t + startPos[0];
	position[1] = M10 * t3 + M11 * t2 + startVel[1] * t + startPos[1];
	position[2] = M20 * t3 + M21 * t2 + startVel[2] * t + startPos[2];
	
	return position;
}

/**************************************************************************************************************/

/**
 Cubic interpolation between [a, b], t must be [0, 1]
*/
Numeric.cubicInterpolationDerivative = function(t, startPos, startVel, endPos, endVel)
{
	var t2 = t * t;
	
	// Evaluates the direction

	var M01 = 6 * startPos[0] - 6 * endPos[0] + 3 * startVel[0] + 3 * endVel[0];
	var M11 = 6 * startPos[1] - 6 * endPos[1] + 3 * startVel[1] + 3 * endVel[1];
	var M21 = 6 * startPos[2] - 6 * endPos[2] + 3 * startVel[2] + 3 * endVel[2];

	var M02 = -6 * startPos[0] + 6 * endPos[0] - 4 * startVel[0] - 2 * endVel[0];
	var M12 = -6 * startPos[1] + 6 * endPos[1] - 4 * startVel[1] - 2 * endVel[1];
	var M22 = -6 * startPos[2] + 6 * endPos[2] - 4 * startVel[2] - 2 * endVel[2];

	var direction = vec3.create();
	direction[0] = M01 * t2 + M02 * t + startVel[0];
	direction[1] = M11 * t2 + M12 * t + startVel[1];
	direction[2] = M21 * t2 + M22 * t + startVel[2];
	
	return direction;
}

/**************************************************************************************************************/

/**
  Map x between [xMin, xMax] to [0, 1]
*/
Numeric.map01 = function(x, xMin, xMax)
{
    return (xMin != xMax) ? (x - xMin) / (xMax - xMin) : 0;
}

/**************************************************************************************************************/

/*
  Map x between [xMin, xMax] to [outMin, outMax]
*/
Numeric.mapLinear = function(x, xMin, xMax, outMin, outMax)
{
    return Numeric.lerp(Numeric.map01(x, xMin, xMax), outMin, outMax);
}

/**************************************************************************************************************/

Numeric.easeInQuad = function(t)
{
    return t*t;
}

/**************************************************************************************************************/

Numeric.easeOutQuad = function(t)
{
    // use 1-(t^2) with input [-1, 0]
    var v = t - 1; // map [0 1] to [-1 0]
    return 1.0-(v*v);
}

/**************************************************************************************************************/

/**
  Remap input t ([0, 1]) to a curve starting slowly
  and accelerating till 0.5 an decelerating till 1
*/
Numeric.easeInOutQuad = function(t)
{
    var out = t;
    if (out < 0.5)
    {
        // use (0.5*t^2) with input [0, 1]
        out = out+out; // map [0 0.5] outo [0 1]
        out = 0.5*(out*out);
    }
    else
    {
        // use (0.5*(1-t)^2) with input [-1, 0]
        out = (out+out) - 2.0; // map [0.5 1] to [-1 0]
        out = 0.5*(1.0-(out*out));
        out = 0.5 + out;
    }
    return out;
}

/**************************************************************************************************************/

/*
 */
Numeric.easeOutInQuad = function(t)
{
    var out = t;
    if (out < 0.5)
    {
        // use (0.5*(1-t)^2) with input [-1, 0]
        out = (out+out) - 1.0; // map [0 0.5] to [-1 0]
        out = 0.5*(1.0-(out*out));
    }
    else
    {
        // use (0.5*t^2) with input [0, 1]
        out = (out+out) - 1.0; // map [0.5 1] outo [0 1]
        out = 0.5*(out*out);
        out = 0.5 + out;
    }
    return out;
}

/**************************************************************************************************************/

/**
  Convert the given degree value in radian
*/
Numeric.toRadian = function(degree)
{
    return degree * Math.PI / 180.0;
}

/**************************************************************************************************************/

/**
  Convert the given radian value in degree
*/
Numeric.toDegree = function(radian)
{
    return radian * 180.0 / Math.PI;
}

/**************************************************************************************************************/

/**
  Line-line intersection
  rayDirection must be normalized.
  Returns t at which intersection occurs or -1 if no intersection.
*/

Numeric.lineIntersection = function( x1, y1, x2, y2, x3, y3, x4, y4 )
{
	var det = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
	if ( det == 0 )
	{
		return [-1,-1];
	}
	
	var ua = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
	var ub = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
	
	ua /= det;
	ub /= det;
	
	return [ ua, ub ];
	//return ua > 0.0 && ua < 1.0 && ub > 0.0 && ub < 1.0;
}

/**************************************************************************************************************/

/**
 * 	Round the given number
 * 
 * 	@param num Number to round
 * 	@param dec Number of decimals
 */
Numeric.roundNumber = function (num, dec)
{
	var result = Math.round(num*Math.pow(10,dec))/Math.pow(10,dec);
	return result;
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/


 
var CoordinateSystem = function(options)
{
	this.radius = options && options.hasOwnProperty('radius') ? options.radius : 1.0;
	this.realEarthRadius = options && options.hasOwnProperty('realEarthRadius') ? options.realEarthRadius : 6356752.3142;
	this.heightScale = 1.0 / this.realEarthRadius;
};

/**************************************************************************************************************/

/*
	Convert a geographic position to 3D
 */
CoordinateSystem.prototype.fromGeoTo3D = function(geo, dest)
{
    if (!dest) { dest = new Array(3); }

	var longInRad = Numeric.toRadian(geo[0]);
	var latInRad = Numeric.toRadian(geo[1]);
	var cosLat = Math.cos(latInRad);
	
	// Take height into account
	var height = geo.length > 2 ? this.heightScale * geo[2] : 0;
	var radius = this.radius + height;

    dest[0] = radius * Math.cos(longInRad) * cosLat;
    dest[1] = radius * Math.sin(longInRad) * cosLat;
    dest[2] = radius * Math.sin(latInRad);

    return dest;
};

/**************************************************************************************************************/

/*
	Convert a 3D position to geographic
    Returns 3 values [long, lat, distance from earth surface]
 */
CoordinateSystem.prototype.from3DToGeo = function(position3d, dest)
{
    if (!dest) { dest = new Array(3); }

    var r = Math.sqrt(position3d[0]*position3d[0] +
                      position3d[1]*position3d[1] +
                      position3d[2]*position3d[2]);
    var lon = Math.atan2(position3d[1] / r, position3d[0] / r);
    var lat = Math.asin(position3d[2] / r);

    dest[0] = Numeric.toDegree(lon);
    dest[1] = Numeric.toDegree(lat);
    dest[2] = this.realEarthRadius * (r - this.radius);

    return dest;
};

/**************************************************************************************************************/

/*
	Get local transformation
 */
CoordinateSystem.prototype.getLocalTransform = function(geo, dest)
{
    if (!dest) { dest = mat4.create(); }

	var longitude = geo[0] * Math.PI / 180.0;
	var latitude = geo[1] * Math.PI / 180.0;
	
	var up = [  Math.cos(longitude)*Math.cos(latitude), Math.sin(longitude)*Math.cos(latitude), Math.sin(latitude) ];
	var east = [ -Math.sin(longitude), Math.cos(longitude), 0 ];
	var north = vec3.create();
	vec3.cross( up, east, north );
	
	dest[0] = east[0];
	dest[1] = east[1];
	dest[2] = east[2];
	dest[3] = 0.0;
		
	dest[4] = north[0];
	dest[5] = north[1];
	dest[6] = north[2];
	dest[7] = 0.0;
		
	dest[8] = up[0];
	dest[9] = up[1];
	dest[10] = up[2];
	dest[11] = 0.0;

	dest[12] = 0.0;
	dest[13] = 0.0;
	dest[14] = 0.0;
	dest[15] = 1.0;

	return dest;
};

/**************************************************************************************************************/

/*
	Get local transformation
 */
CoordinateSystem.prototype.getLHVTransform = function(geo, dest)
{
    if (!dest) { dest = mat4.create(); }

	var longitude = geo[0] * Math.PI / 180.0;
	var latitude = geo[1] * Math.PI / 180.0;
	
	var up = [  Math.cos(longitude)*Math.cos(latitude), Math.sin(longitude)*Math.cos(latitude), Math.sin(latitude) ];
	var east = [ -Math.sin(longitude), Math.cos(longitude), 0 ];
	var north = vec3.create();
	vec3.cross( up, east, north );
	
	var pt = this.fromGeoTo3D(geo);
	
	dest[0] = east[0];
	dest[1] = east[1];
	dest[2] = east[2];
	dest[3] = 0.0;
		
	dest[4] = north[0];
	dest[5] = north[1];
	dest[6] = north[2];
	dest[7] = 0.0;
		
	dest[8] = up[0];
	dest[9] = up[1];
	dest[10] = up[2];
	dest[11] = 0.0;

	dest[12] = pt[0];
	dest[13] = pt[1];
	dest[14] = pt[2];
	dest[15] = 1.0;

	return dest;
};

/**************************************************************************************************************/

/*
	Get the side (i.e. X) vector from a local transformation
 */
CoordinateSystem.prototype.getSideVector = function( matrix, v )
{
	v[0] = matrix[0];
	v[1] = matrix[1];
	v[2] = matrix[2];
	
    return v;
};

/**************************************************************************************************************/

/*
	Get the front (i.e. Y) vector from a local transformation
 */
CoordinateSystem.prototype.getFrontVector = function( matrix, v )
{
	v[0] = matrix[4];
	v[1] = matrix[5];
	v[2] = matrix[6];
	
    return v;
};

/**************************************************************************************************************/

/*
	Get the up (i.e. Z) vector from a local transformation
 */
CoordinateSystem.prototype.getUpVector = function( matrix, v )
{
	v[0] = matrix[8];
	v[1] = matrix[9];
	v[2] = matrix[10];
	
    return v;
};

/**************************************************************************************************************/;
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations for WebGL
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 1.3.7
 */

/*
 * Copyright (c) 2012 Brandon Jones, Colin MacKenzie IV
 *
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 *    1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 *
 *    2. Altered source versions must be plainly marked as such, and must not
 *    be misrepresented as being the original software.
 *
 *    3. This notice may not be removed or altered from any source
 *    distribution.
 */

// Modification to plain glMatrix
//	- Always use Array for MatrixType
//	- Remove export management
//	- Remove vec2, mat2, mat3, vec4
//	- Comments some not needed functions
//	- Add mat4.project and mat4.rotateVec3



    // Tweak to your liking
    var FLOAT_EPSILON = 0.000001;

    /**
     * @class System-specific optimal array type
     * @name MatrixArray
     */
    var MatrixArray = Array;
    
    /**
     * @class 3 Dimensional Vector
     * @name vec3
     */
    var vec3 = {};
     
    /**
     * Creates a new instance of a vec3 using the default array type
     * Any javascript array-like objects containing at least 3 numeric elements can serve as a vec3
     *
     * @param {vec3} [vec] vec3 containing values to initialize with
     *
     * @returns {vec3} New vec3
     */
    vec3.create = function (vec) {
        var dest = new MatrixArray(3);

        if (vec) {
            dest[0] = vec[0];
            dest[1] = vec[1];
            dest[2] = vec[2];
        } else {
            dest[0] = dest[1] = dest[2] = 0;
        }

        return dest;
    };

    /**
     * Creates a new instance of a vec3, initializing it with the given arguments
     *
     * @param {number} x X value
     * @param {number} y Y value
     * @param {number} z Z value

     * @returns {vec3} New vec3
     */
    vec3.createFrom = function (x, y, z) {
        var dest = new MatrixArray(3);

        dest[0] = x;
        dest[1] = y;
        dest[2] = z;

        return dest;
    };

    /**
     * Copies the values of one vec3 to another
     *
     * @param {vec3} vec vec3 containing values to copy
     * @param {vec3} dest vec3 receiving copied values
     *
     * @returns {vec3} dest
     */
    vec3.set = function (vec, dest) {
        dest[0] = vec[0];
        dest[1] = vec[1];
        dest[2] = vec[2];

        return dest;
    };

    /**
     * Compares two vectors for equality within a certain margin of error
     *
     * @param {vec3} a First vector
     * @param {vec3} b Second vector
     *
     * @returns {Boolean} True if a is equivalent to b
     */
    vec3.equal = function (a, b) {
        return a === b || (
            Math.abs(a[0] - b[0]) < FLOAT_EPSILON &&
            Math.abs(a[1] - b[1]) < FLOAT_EPSILON &&
            Math.abs(a[2] - b[2]) < FLOAT_EPSILON
        );
    };

    /**
     * Performs a vector addition
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.add = function (vec, vec2, dest) {
        if (!dest || vec === dest) {
            vec[0] += vec2[0];
            vec[1] += vec2[1];
            vec[2] += vec2[2];
            return vec;
        }

        dest[0] = vec[0] + vec2[0];
        dest[1] = vec[1] + vec2[1];
        dest[2] = vec[2] + vec2[2];
        return dest;
    };

    /**
     * Performs a vector subtraction
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.subtract = function (vec, vec2, dest) {
        if (!dest || vec === dest) {
            vec[0] -= vec2[0];
            vec[1] -= vec2[1];
            vec[2] -= vec2[2];
            return vec;
        }

        dest[0] = vec[0] - vec2[0];
        dest[1] = vec[1] - vec2[1];
        dest[2] = vec[2] - vec2[2];
        return dest;
    };

    /**
     * Performs a vector multiplication
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.multiply = function (vec, vec2, dest) {
        if (!dest || vec === dest) {
            vec[0] *= vec2[0];
            vec[1] *= vec2[1];
            vec[2] *= vec2[2];
            return vec;
        }

        dest[0] = vec[0] * vec2[0];
        dest[1] = vec[1] * vec2[1];
        dest[2] = vec[2] * vec2[2];
        return dest;
    };

    /**
     * Negates the components of a vec3
     *
     * @param {vec3} vec vec3 to negate
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.negate = function (vec, dest) {
        if (!dest) { dest = vec; }

        dest[0] = -vec[0];
        dest[1] = -vec[1];
        dest[2] = -vec[2];
        return dest;
    };

    /**
     * Multiplies the components of a vec3 by a scalar value
     *
     * @param {vec3} vec vec3 to scale
     * @param {number} val Value to scale by
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.scale = function (vec, val, dest) {
        if (!dest || vec === dest) {
            vec[0] *= val;
            vec[1] *= val;
            vec[2] *= val;
            return vec;
        }

        dest[0] = vec[0] * val;
        dest[1] = vec[1] * val;
        dest[2] = vec[2] * val;
        return dest;
    };

    /**
     * Generates a unit vector of the same direction as the provided vec3
     * If vector length is 0, returns [0, 0, 0]
     *
     * @param {vec3} vec vec3 to normalize
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.normalize = function (vec, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0], y = vec[1], z = vec[2],
            len = Math.sqrt(x * x + y * y + z * z);

        if (!len) {
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            return dest;
        } else if (len === 1) {
            dest[0] = x;
            dest[1] = y;
            dest[2] = z;
            return dest;
        }

        len = 1 / len;
        dest[0] = x * len;
        dest[1] = y * len;
        dest[2] = z * len;
        return dest;
    };

    /**
     * Generates the cross product of two vec3s
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.cross = function (vec, vec2, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0], y = vec[1], z = vec[2],
            x2 = vec2[0], y2 = vec2[1], z2 = vec2[2];

        dest[0] = y * z2 - z * y2;
        dest[1] = z * x2 - x * z2;
        dest[2] = x * y2 - y * x2;
        return dest;
    };

    /**
     * Caclulates the length of a vec3
     *
     * @param {vec3} vec vec3 to calculate length of
     *
     * @returns {number} Length of vec
     */
    vec3.length = function (vec) {
        var x = vec[0], y = vec[1], z = vec[2];
        return Math.sqrt(x * x + y * y + z * z);
    };

    /**
     * Caclulates the squared length of a vec3
     *
     * @param {vec3} vec vec3 to calculate squared length of
     *
     * @returns {number} Squared Length of vec
     */
    vec3.squaredLength = function (vec) {
        var x = vec[0], y = vec[1], z = vec[2];
        return x * x + y * y + z * z;
    };

    /**
     * Caclulates the dot product of two vec3s
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     *
     * @returns {number} Dot product of vec and vec2
     */
    vec3.dot = function (vec, vec2) {
        return vec[0] * vec2[0] + vec[1] * vec2[1] + vec[2] * vec2[2];
    };

    /**
     * Generates a unit vector pointing from one vector to another
     *
     * @param {vec3} vec Origin vec3
     * @param {vec3} vec2 vec3 to point to
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
/*   vec3.direction = function (vec, vec2, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0] - vec2[0],
            y = vec[1] - vec2[1],
            z = vec[2] - vec2[2],
            len = Math.sqrt(x * x + y * y + z * z);

        if (!len) {
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            return dest;
        }

        len = 1 / len;
        dest[0] = x * len;
        dest[1] = y * len;
        dest[2] = z * len;
        return dest;
    };*/

    /**
     * Performs a linear interpolation between two vec3
     *
     * @param {vec3} vec First vector
     * @param {vec3} vec2 Second vector
     * @param {number} lerp Interpolation amount between the two inputs
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.lerp = function (vec, vec2, lerp, dest) {
        if (!dest) { dest = vec; }

        dest[0] = vec[0] + lerp * (vec2[0] - vec[0]);
        dest[1] = vec[1] + lerp * (vec2[1] - vec[1]);
        dest[2] = vec[2] + lerp * (vec2[2] - vec[2]);

        return dest;
    };

    /**
     * Calculates the euclidian distance between two vec3
     *
     * Params:
     * @param {vec3} vec First vector
     * @param {vec3} vec2 Second vector
     *
     * @returns {number} Distance between vec and vec2
     */
    vec3.dist = function (vec, vec2) {
        var x = vec2[0] - vec[0],
            y = vec2[1] - vec[1],
            z = vec2[2] - vec[2];
            
        return Math.sqrt(x*x + y*y + z*z);
    };

    // Pre-allocated to prevent unecessary garbage collection
    //var unprojectMat = null;
    //var unprojectVec = new MatrixArray(4);
    /**
     * Projects the specified vec3 from screen space into object space
     * Based on the <a href="http://webcvs.freedesktop.org/mesa/Mesa/src/glu/mesa/project.c?revision=1.4&view=markup">Mesa gluUnProject implementation</a>
     *
     * @param {vec3} vec Screen-space vector to project
     * @param {mat4} view View matrix
     * @param {mat4} proj Projection matrix
     * @param {vec4} viewport Viewport as given to gl.viewport [x, y, width, height]
     * @param {vec3} [dest] vec3 receiving unprojected result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
 /*   vec3.unproject = function (vec, view, proj, viewport, dest) {
        if (!dest) { dest = vec; }

        if(!unprojectMat) {
            unprojectMat = mat4.create();
        }

        var m = unprojectMat;
        var v = unprojectVec;
        
        v[0] = (vec[0] - viewport[0]) * 2.0 / viewport[2] - 1.0;
        v[1] = (vec[1] - viewport[1]) * 2.0 / viewport[3] - 1.0;
        v[2] = 2.0 * vec[2] - 1.0;
        v[3] = 1.0;
        
        mat4.multiply(proj, view, m);
        if(!mat4.inverse(m)) { return null; }
        
        mat4.multiplyVec4(m, v);
        if(v[3] === 0.0) { return null; }

        dest[0] = v[0] / v[3];
        dest[1] = v[1] / v[3];
        dest[2] = v[2] / v[3];
        
        return dest;
    };*/

/*    var xUnitVec3 = vec3.createFrom(1,0,0);
    var yUnitVec3 = vec3.createFrom(0,1,0);
    var zUnitVec3 = vec3.createFrom(0,0,1);

    var tmpvec3 = vec3.create();*/
    /**
     * Generates a quaternion of rotation between two given normalized vectors
     *
     * @param {vec3} a Normalized source vector
     * @param {vec3} b Normalized target vector
     * @param {quat4} [dest] quat4 receiving operation result.
     *
     * @returns {quat4} dest if specified, a new quat4 otherwise
     */
/*    vec3.rotationTo = function (a, b, dest) {
        if (!dest) { dest = quat4.create(); }
        
        var d = vec3.dot(a, b);
        var axis = tmpvec3;
        if (d >= 1.0) {
            quat4.set(identityQuat4, dest);
        } else if (d < (0.000001 - 1.0)) {
            vec3.cross(xUnitVec3, a, axis);
            if (vec3.length(axis) < 0.000001)
                vec3.cross(yUnitVec3, a, axis);
            if (vec3.length(axis) < 0.000001)
                vec3.cross(zUnitVec3, a, axis);
            vec3.normalize(axis);
            quat4.fromAngleAxis(Math.PI, axis, dest);
        } else {
            var s = Math.sqrt((1.0 + d) * 2.0);
            var sInv = 1.0 / s;
            vec3.cross(a, b, axis);
            dest[0] = axis[0] * sInv;
            dest[1] = axis[1] * sInv;
            dest[2] = axis[2] * sInv;
            dest[3] = s * 0.5;
            quat4.normalize(dest);
        }
        if (dest[3] > 1.0) dest[3] = 1.0;
        else if (dest[3] < -1.0) dest[3] = -1.0;
        return dest;
    };*/

    /**
     * Returns a string representation of a vector
     *
     * @param {vec3} vec Vector to represent as a string
     *
     * @returns {string} String representation of vec
     */
    vec3.str = function (vec) {
        return '[' + vec[0] + ', ' + vec[1] + ', ' + vec[2] + ']';
    };
	
	/**
	 * @class 3x3 Matrix
	 * @name mat3
	 */
    var mat3 = {};
	
	/**
	 * Creates a new isntance of mat3
	 *
     * @param {mat3} [mat] mat3 containing values to initialize with
	 *
	 * @returns {mat3} a new 3x3 matrix
	 */
    mat3.create = function (mat) {
        var dest = new MatrixArray(9);

        if (mat) {
            dest[0] = mat[0];
            dest[1] = mat[1];
            dest[2] = mat[2];
            dest[3] = mat[3];
            dest[4] = mat[4];
            dest[5] = mat[5];
            dest[6] = mat[6];
            dest[7] = mat[7];
            dest[8] = mat[8];
        }

        return dest;
    };

    /**
     * @class 4x4 Matrix
     * @name mat4
     */
    var mat4 = {};

    /**
     * Creates a new instance of a mat4 using the default array type
     * Any javascript array-like object containing at least 16 numeric elements can serve as a mat4
     *
     * @param {mat4} [mat] mat4 containing values to initialize with
     *
     * @returns {mat4} New mat4
     */
    mat4.create = function (mat) {
        var dest = new MatrixArray(16);

        if (mat) {
            dest[0] = mat[0];
            dest[1] = mat[1];
            dest[2] = mat[2];
            dest[3] = mat[3];
            dest[4] = mat[4];
            dest[5] = mat[5];
            dest[6] = mat[6];
            dest[7] = mat[7];
            dest[8] = mat[8];
            dest[9] = mat[9];
            dest[10] = mat[10];
            dest[11] = mat[11];
            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        return dest;
    };

    /**
     * Creates a new instance of a mat4, initializing it with the given arguments
     *
     * @param {number} m00
     * @param {number} m01
     * @param {number} m02
     * @param {number} m03
     * @param {number} m10
     * @param {number} m11
     * @param {number} m12
     * @param {number} m13
     * @param {number} m20
     * @param {number} m21
     * @param {number} m22
     * @param {number} m23
     * @param {number} m30
     * @param {number} m31
     * @param {number} m32
     * @param {number} m33

     * @returns {mat4} New mat4
     */
 /*   mat4.createFrom = function (m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        var dest = new MatrixArray(16);

        dest[0] = m00;
        dest[1] = m01;
        dest[2] = m02;
        dest[3] = m03;
        dest[4] = m10;
        dest[5] = m11;
        dest[6] = m12;
        dest[7] = m13;
        dest[8] = m20;
        dest[9] = m21;
        dest[10] = m22;
        dest[11] = m23;
        dest[12] = m30;
        dest[13] = m31;
        dest[14] = m32;
        dest[15] = m33;

        return dest;
    };*/

    /**
     * Copies the values of one mat4 to another
     *
     * @param {mat4} mat mat4 containing values to copy
     * @param {mat4} dest mat4 receiving copied values
     *
     * @returns {mat4} dest
     */
    mat4.set = function (mat, dest) {
        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[3];
        dest[4] = mat[4];
        dest[5] = mat[5];
        dest[6] = mat[6];
        dest[7] = mat[7];
        dest[8] = mat[8];
        dest[9] = mat[9];
        dest[10] = mat[10];
        dest[11] = mat[11];
        dest[12] = mat[12];
        dest[13] = mat[13];
        dest[14] = mat[14];
        dest[15] = mat[15];
        return dest;
    };

    /**
     * Compares two matrices for equality within a certain margin of error
     *
     * @param {mat4} a First matrix
     * @param {mat4} b Second matrix
     *
     * @returns {Boolean} True if a is equivalent to b
     */
/*    mat4.equal = function (a, b) {
        return a === b || (
            Math.abs(a[0] - b[0]) < FLOAT_EPSILON &&
            Math.abs(a[1] - b[1]) < FLOAT_EPSILON &&
            Math.abs(a[2] - b[2]) < FLOAT_EPSILON &&
            Math.abs(a[3] - b[3]) < FLOAT_EPSILON &&
            Math.abs(a[4] - b[4]) < FLOAT_EPSILON &&
            Math.abs(a[5] - b[5]) < FLOAT_EPSILON &&
            Math.abs(a[6] - b[6]) < FLOAT_EPSILON &&
            Math.abs(a[7] - b[7]) < FLOAT_EPSILON &&
            Math.abs(a[8] - b[8]) < FLOAT_EPSILON &&
            Math.abs(a[9] - b[9]) < FLOAT_EPSILON &&
            Math.abs(a[10] - b[10]) < FLOAT_EPSILON &&
            Math.abs(a[11] - b[11]) < FLOAT_EPSILON &&
            Math.abs(a[12] - b[12]) < FLOAT_EPSILON &&
            Math.abs(a[13] - b[13]) < FLOAT_EPSILON &&
            Math.abs(a[14] - b[14]) < FLOAT_EPSILON &&
            Math.abs(a[15] - b[15]) < FLOAT_EPSILON
        );
    };*/

    /**
     * Sets a mat4 to an identity matrix
     *
     * @param {mat4} dest mat4 to set
     *
     * @returns {mat4} dest
     */
    mat4.identity = function (dest) {
        if (!dest) { dest = mat4.create(); }
        dest[0] = 1;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 0;
        dest[5] = 1;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = 0;
        dest[9] = 0;
        dest[10] = 1;
        dest[11] = 0;
        dest[12] = 0;
        dest[13] = 0;
        dest[14] = 0;
        dest[15] = 1;
        return dest;
    };

    /**
     * Transposes a mat4 (flips the values over the diagonal)
     *
     * @param {mat4} mat mat4 to transpose
     * @param {mat4} [dest] mat4 receiving transposed values. If not specified result is written to mat
     *
     * @param {mat4} dest is specified, mat otherwise
     */
    mat4.transpose = function (mat, dest) {
        // If we are transposing ourselves we can skip a few steps but have to cache some values
        if (!dest || mat === dest) {
            var a01 = mat[1], a02 = mat[2], a03 = mat[3],
                a12 = mat[6], a13 = mat[7],
                a23 = mat[11];

            mat[1] = mat[4];
            mat[2] = mat[8];
            mat[3] = mat[12];
            mat[4] = a01;
            mat[6] = mat[9];
            mat[7] = mat[13];
            mat[8] = a02;
            mat[9] = a12;
            mat[11] = mat[14];
            mat[12] = a03;
            mat[13] = a13;
            mat[14] = a23;
            return mat;
        }

        dest[0] = mat[0];
        dest[1] = mat[4];
        dest[2] = mat[8];
        dest[3] = mat[12];
        dest[4] = mat[1];
        dest[5] = mat[5];
        dest[6] = mat[9];
        dest[7] = mat[13];
        dest[8] = mat[2];
        dest[9] = mat[6];
        dest[10] = mat[10];
        dest[11] = mat[14];
        dest[12] = mat[3];
        dest[13] = mat[7];
        dest[14] = mat[11];
        dest[15] = mat[15];
        return dest;
    };

    /**
     * Calculates the determinant of a mat4
     *
     * @param {mat4} mat mat4 to calculate determinant of
     *
     * @returns {number} determinant of mat
     */
    mat4.determinant = function (mat) {
        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3],
            a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7],
            a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11],
            a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];

        return (a30 * a21 * a12 * a03 - a20 * a31 * a12 * a03 - a30 * a11 * a22 * a03 + a10 * a31 * a22 * a03 +
                a20 * a11 * a32 * a03 - a10 * a21 * a32 * a03 - a30 * a21 * a02 * a13 + a20 * a31 * a02 * a13 +
                a30 * a01 * a22 * a13 - a00 * a31 * a22 * a13 - a20 * a01 * a32 * a13 + a00 * a21 * a32 * a13 +
                a30 * a11 * a02 * a23 - a10 * a31 * a02 * a23 - a30 * a01 * a12 * a23 + a00 * a31 * a12 * a23 +
                a10 * a01 * a32 * a23 - a00 * a11 * a32 * a23 - a20 * a11 * a02 * a33 + a10 * a21 * a02 * a33 +
                a20 * a01 * a12 * a33 - a00 * a21 * a12 * a33 - a10 * a01 * a22 * a33 + a00 * a11 * a22 * a33);
    };

    /**
     * Calculates the inverse matrix of a mat4
     *
     * @param {mat4} mat mat4 to calculate inverse of
     * @param {mat4} [dest] mat4 receiving inverse matrix. If not specified result is written to mat
     *
     * @param {mat4} dest is specified, mat otherwise, null if matrix cannot be inverted
     */
    mat4.inverse = function (mat, dest) {
        if (!dest) { dest = mat; }

        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3],
            a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7],
            a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11],
            a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15],

            b00 = a00 * a11 - a01 * a10,
            b01 = a00 * a12 - a02 * a10,
            b02 = a00 * a13 - a03 * a10,
            b03 = a01 * a12 - a02 * a11,
            b04 = a01 * a13 - a03 * a11,
            b05 = a02 * a13 - a03 * a12,
            b06 = a20 * a31 - a21 * a30,
            b07 = a20 * a32 - a22 * a30,
            b08 = a20 * a33 - a23 * a30,
            b09 = a21 * a32 - a22 * a31,
            b10 = a21 * a33 - a23 * a31,
            b11 = a22 * a33 - a23 * a32,

            d = (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06),
            invDet;

            // Calculate the determinant
            if (!d) { return null; }
            invDet = 1 / d;

        dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
        dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
        dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
        dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
        dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
        dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
        dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
        dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
        dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
        dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
        dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
        dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
        dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
        dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
        dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
        dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;

        return dest;
    };

    /**
     * Copies the upper 3x3 elements of a mat4 into another mat4
     *
     * @param {mat4} mat mat4 containing values to copy
     * @param {mat4} [dest] mat4 receiving copied values
     *
     * @returns {mat4} dest is specified, a new mat4 otherwise
     */
    mat4.toRotationMat = function (mat, dest) {
        if (!dest) { dest = mat4.create(); }

        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[3];
        dest[4] = mat[4];
        dest[5] = mat[5];
        dest[6] = mat[6];
        dest[7] = mat[7];
        dest[8] = mat[8];
        dest[9] = mat[9];
        dest[10] = mat[10];
        dest[11] = mat[11];
        dest[12] = 0;
        dest[13] = 0;
        dest[14] = 0;
        dest[15] = 1;

        return dest;
    };

    /**
     * Copies the upper 3x3 elements of a mat4 into a mat3
     *
     * @param {mat4} mat mat4 containing values to copy
     * @param {mat3} [dest] mat3 receiving copied values
     *
     * @returns {mat3} dest is specified, a new mat3 otherwise
     */
    mat4.toMat3 = function (mat, dest) {
        if (!dest) { dest = mat3.create(); }

        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[4];
        dest[4] = mat[5];
        dest[5] = mat[6];
        dest[6] = mat[8];
        dest[7] = mat[9];
        dest[8] = mat[10];

        return dest;
    };

    /**
     * Calculates the inverse of the upper 3x3 elements of a mat4 and copies the result into a mat3
     * The resulting matrix is useful for calculating transformed normals
     *
     * Params:
     * @param {mat4} mat mat4 containing values to invert and copy
     * @param {mat3} [dest] mat3 receiving values
     *
     * @returns {mat3} dest is specified, a new mat3 otherwise, null if the matrix cannot be inverted
     */
 /*   mat4.toInverseMat3 = function (mat, dest) {
        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0], a01 = mat[1], a02 = mat[2],
            a10 = mat[4], a11 = mat[5], a12 = mat[6],
            a20 = mat[8], a21 = mat[9], a22 = mat[10],

            b01 = a22 * a11 - a12 * a21,
            b11 = -a22 * a10 + a12 * a20,
            b21 = a21 * a10 - a11 * a20,

            d = a00 * b01 + a01 * b11 + a02 * b21,
            id;

        if (!d) { return null; }
        id = 1 / d;

        if (!dest) { dest = mat3.create(); }

        dest[0] = b01 * id;
        dest[1] = (-a22 * a01 + a02 * a21) * id;
        dest[2] = (a12 * a01 - a02 * a11) * id;
        dest[3] = b11 * id;
        dest[4] = (a22 * a00 - a02 * a20) * id;
        dest[5] = (-a12 * a00 + a02 * a10) * id;
        dest[6] = b21 * id;
        dest[7] = (-a21 * a00 + a01 * a20) * id;
        dest[8] = (a11 * a00 - a01 * a10) * id;

        return dest;
    };*/

    /**
     * Performs a matrix multiplication
     *
     * @param {mat4} mat First operand
     * @param {mat4} mat2 Second operand
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.multiply = function (mat, mat2, dest) {
        if (!dest) { dest = mat; }

        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[ 0], a01 = mat[ 1], a02 = mat[ 2], a03 = mat[3];
        var a10 = mat[ 4], a11 = mat[ 5], a12 = mat[ 6], a13 = mat[7];
        var a20 = mat[ 8], a21 = mat[ 9], a22 = mat[10], a23 = mat[11];
        var a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];

        // Cache only the current line of the second matrix
        var b0  = mat2[0], b1 = mat2[1], b2 = mat2[2], b3 = mat2[3];  
        dest[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        dest[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        dest[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        dest[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = mat2[4];
        b1 = mat2[5];
        b2 = mat2[6];
        b3 = mat2[7];
        dest[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        dest[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        dest[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        dest[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = mat2[8];
        b1 = mat2[9];
        b2 = mat2[10];
        b3 = mat2[11];
        dest[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        dest[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        dest[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        dest[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = mat2[12];
        b1 = mat2[13];
        b2 = mat2[14];
        b3 = mat2[15];
        dest[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        dest[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        dest[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        dest[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        return dest;
    };

    /**
     * Transforms a vec3 with the given matrix
     * 4th vector component is implicitly '1'
     *
     * @param {mat4} mat mat4 to transform the vector with
     * @param {vec3} vec vec3 to transform
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    mat4.multiplyVec3 = function (mat, vec, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0], y = vec[1], z = vec[2];

        dest[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12];
        dest[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13];
        dest[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14];

        return dest;
    };

    /**
     * Transforms a vec4 with the given matrix
     *
     * @param {mat4} mat mat4 to transform the vector with
     * @param {vec4} vec vec4 to transform
     * @param {vec4} [dest] vec4 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec4} dest if specified, vec otherwise
     */
    mat4.multiplyVec4 = function (mat, vec, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0], y = vec[1], z = vec[2], w = vec[3];

        dest[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12] * w;
        dest[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13] * w;
        dest[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14] * w;
        dest[3] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15] * w;

        return dest;
    };

	/**
	  Project a vec3
	*/
	mat4.project = function(mat, vec, dest)
	{
		if(!dest) { dest = vec }
		mat4.multiplyVec4( mat, vec, dest );
		var iw = 1.0 / dest[3];
		dest[0] *= iw;
		dest[1] *= iw;
		dest[2] *= iw;
		return dest;
	}

	/**
	 * mat4.rotateVec3
	 * Rotate a vec3 with the given matrix
	 *
	 * Params:
	 * mat - mat4 to transform the vector with
	 * vec - vec3 to transform
	 * dest - Optional, vec3 receiving operation result. If not specified result is written to vec
	 *
	 * Returns:
	 * dest if specified, vec otherwise
	 */
	mat4.rotateVec3 = function(mat, vec, dest) {
		if(!dest) { dest = vec }
		
		var x = vec[0], y = vec[1], z = vec[2];
		
		dest[0] = mat[0]*x + mat[4]*y + mat[8]*z;
		dest[1] = mat[1]*x + mat[5]*y + mat[9]*z;
		dest[2] = mat[2]*x + mat[6]*y + mat[10]*z;
		
		return dest;
	};
	
    /**
     * Translates a matrix by the given vector
     *
     * @param {mat4} mat mat4 to translate
     * @param {vec3} vec vec3 specifying the translation
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.translate = function (mat, vec, dest) {
        var x = vec[0], y = vec[1], z = vec[2],
            a00, a01, a02, a03,
            a10, a11, a12, a13,
            a20, a21, a22, a23;

        if (!dest || mat === dest) {
            mat[12] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12];
            mat[13] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13];
            mat[14] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14];
            mat[15] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15];
            return mat;
        }

        a00 = mat[0]; a01 = mat[1]; a02 = mat[2]; a03 = mat[3];
        a10 = mat[4]; a11 = mat[5]; a12 = mat[6]; a13 = mat[7];
        a20 = mat[8]; a21 = mat[9]; a22 = mat[10]; a23 = mat[11];

        dest[0] = a00; dest[1] = a01; dest[2] = a02; dest[3] = a03;
        dest[4] = a10; dest[5] = a11; dest[6] = a12; dest[7] = a13;
        dest[8] = a20; dest[9] = a21; dest[10] = a22; dest[11] = a23;

        dest[12] = a00 * x + a10 * y + a20 * z + mat[12];
        dest[13] = a01 * x + a11 * y + a21 * z + mat[13];
        dest[14] = a02 * x + a12 * y + a22 * z + mat[14];
        dest[15] = a03 * x + a13 * y + a23 * z + mat[15];
        return dest;
    };

    /**
     * Scales a matrix by the given vector
     *
     * @param {mat4} mat mat4 to scale
     * @param {vec3} vec vec3 specifying the scale for each axis
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @param {mat4} dest if specified, mat otherwise
     */
    mat4.scale = function (mat, vec, dest) {
        var x = vec[0], y = vec[1], z = vec[2];

        if (!dest || mat === dest) {
            mat[0] *= x;
            mat[1] *= x;
            mat[2] *= x;
            mat[3] *= x;
            mat[4] *= y;
            mat[5] *= y;
            mat[6] *= y;
            mat[7] *= y;
            mat[8] *= z;
            mat[9] *= z;
            mat[10] *= z;
            mat[11] *= z;
            return mat;
        }

        dest[0] = mat[0] * x;
        dest[1] = mat[1] * x;
        dest[2] = mat[2] * x;
        dest[3] = mat[3] * x;
        dest[4] = mat[4] * y;
        dest[5] = mat[5] * y;
        dest[6] = mat[6] * y;
        dest[7] = mat[7] * y;
        dest[8] = mat[8] * z;
        dest[9] = mat[9] * z;
        dest[10] = mat[10] * z;
        dest[11] = mat[11] * z;
        dest[12] = mat[12];
        dest[13] = mat[13];
        dest[14] = mat[14];
        dest[15] = mat[15];
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the specified axis
     * If rotating around a primary axis (X,Y,Z) one of the specialized rotation functions should be used instead for performance
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {vec3} axis vec3 representing the axis to rotate around
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotate = function (mat, angle, axis, dest) {
        var x = axis[0], y = axis[1], z = axis[2],
            len = Math.sqrt(x * x + y * y + z * z),
            s, c, t,
            a00, a01, a02, a03,
            a10, a11, a12, a13,
            a20, a21, a22, a23,
            b00, b01, b02,
            b10, b11, b12,
            b20, b21, b22;

        if (!len) { return null; }
        if (len !== 1) {
            len = 1 / len;
            x *= len;
            y *= len;
            z *= len;
        }

        s = Math.sin(angle);
        c = Math.cos(angle);
        t = 1 - c;

        a00 = mat[0]; a01 = mat[1]; a02 = mat[2]; a03 = mat[3];
        a10 = mat[4]; a11 = mat[5]; a12 = mat[6]; a13 = mat[7];
        a20 = mat[8]; a21 = mat[9]; a22 = mat[10]; a23 = mat[11];

        // Construct the elements of the rotation matrix
        b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
        b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
        b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) { // If the source and destination differ, copy the unchanged last row
            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform rotation-specific matrix multiplication
        dest[0] = a00 * b00 + a10 * b01 + a20 * b02;
        dest[1] = a01 * b00 + a11 * b01 + a21 * b02;
        dest[2] = a02 * b00 + a12 * b01 + a22 * b02;
        dest[3] = a03 * b00 + a13 * b01 + a23 * b02;

        dest[4] = a00 * b10 + a10 * b11 + a20 * b12;
        dest[5] = a01 * b10 + a11 * b11 + a21 * b12;
        dest[6] = a02 * b10 + a12 * b11 + a22 * b12;
        dest[7] = a03 * b10 + a13 * b11 + a23 * b12;

        dest[8] = a00 * b20 + a10 * b21 + a20 * b22;
        dest[9] = a01 * b20 + a11 * b21 + a21 * b22;
        dest[10] = a02 * b20 + a12 * b21 + a22 * b22;
        dest[11] = a03 * b20 + a13 * b21 + a23 * b22;
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the X axis
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotateX = function (mat, angle, dest) {
        var s = Math.sin(angle),
            c = Math.cos(angle),
            a10 = mat[4],
            a11 = mat[5],
            a12 = mat[6],
            a13 = mat[7],
            a20 = mat[8],
            a21 = mat[9],
            a22 = mat[10],
            a23 = mat[11];

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) { // If the source and destination differ, copy the unchanged rows
            dest[0] = mat[0];
            dest[1] = mat[1];
            dest[2] = mat[2];
            dest[3] = mat[3];

            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform axis-specific matrix multiplication
        dest[4] = a10 * c + a20 * s;
        dest[5] = a11 * c + a21 * s;
        dest[6] = a12 * c + a22 * s;
        dest[7] = a13 * c + a23 * s;

        dest[8] = a10 * -s + a20 * c;
        dest[9] = a11 * -s + a21 * c;
        dest[10] = a12 * -s + a22 * c;
        dest[11] = a13 * -s + a23 * c;
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the Y axis
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotateY = function (mat, angle, dest) {
        var s = Math.sin(angle),
            c = Math.cos(angle),
            a00 = mat[0],
            a01 = mat[1],
            a02 = mat[2],
            a03 = mat[3],
            a20 = mat[8],
            a21 = mat[9],
            a22 = mat[10],
            a23 = mat[11];

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) { // If the source and destination differ, copy the unchanged rows
            dest[4] = mat[4];
            dest[5] = mat[5];
            dest[6] = mat[6];
            dest[7] = mat[7];

            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform axis-specific matrix multiplication
        dest[0] = a00 * c + a20 * -s;
        dest[1] = a01 * c + a21 * -s;
        dest[2] = a02 * c + a22 * -s;
        dest[3] = a03 * c + a23 * -s;

        dest[8] = a00 * s + a20 * c;
        dest[9] = a01 * s + a21 * c;
        dest[10] = a02 * s + a22 * c;
        dest[11] = a03 * s + a23 * c;
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the Z axis
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotateZ = function (mat, angle, dest) {
        var s = Math.sin(angle),
            c = Math.cos(angle),
            a00 = mat[0],
            a01 = mat[1],
            a02 = mat[2],
            a03 = mat[3],
            a10 = mat[4],
            a11 = mat[5],
            a12 = mat[6],
            a13 = mat[7];

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) { // If the source and destination differ, copy the unchanged last row
            dest[8] = mat[8];
            dest[9] = mat[9];
            dest[10] = mat[10];
            dest[11] = mat[11];

            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform axis-specific matrix multiplication
        dest[0] = a00 * c + a10 * s;
        dest[1] = a01 * c + a11 * s;
        dest[2] = a02 * c + a12 * s;
        dest[3] = a03 * c + a13 * s;

        dest[4] = a00 * -s + a10 * c;
        dest[5] = a01 * -s + a11 * c;
        dest[6] = a02 * -s + a12 * c;
        dest[7] = a03 * -s + a13 * c;

        return dest;
    };

    /**
     * Generates a frustum matrix with the given bounds
     *
     * @param {number} left Left bound of the frustum
     * @param {number} right Right bound of the frustum
     * @param {number} bottom Bottom bound of the frustum
     * @param {number} top Top bound of the frustum
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.frustum = function (left, right, bottom, top, near, far, dest) {
        if (!dest) { dest = mat4.create(); }
        var rl = (right - left),
            tb = (top - bottom),
            fn = (far - near);
        dest[0] = (near * 2) / rl;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 0;
        dest[5] = (near * 2) / tb;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = (right + left) / rl;
        dest[9] = (top + bottom) / tb;
        dest[10] = -(far + near) / fn;
        dest[11] = -1;
        dest[12] = 0;
        dest[13] = 0;
        dest[14] = -(far * near * 2) / fn;
        dest[15] = 0;
        return dest;
    };

    /**
     * Generates a perspective projection matrix with the given bounds
     *
     * @param {number} fovy Vertical field of view
     * @param {number} aspect Aspect ratio. typically viewport width/height
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.perspective = function (fovy, aspect, near, far, dest) {
        var top = near * Math.tan(fovy * Math.PI / 360.0),
            right = top * aspect;
        return mat4.frustum(-right, right, -top, top, near, far, dest);
    };

    /**
     * Generates a orthogonal projection matrix with the given bounds
     *
     * @param {number} left Left bound of the frustum
     * @param {number} right Right bound of the frustum
     * @param {number} bottom Bottom bound of the frustum
     * @param {number} top Top bound of the frustum
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.ortho = function (left, right, bottom, top, near, far, dest) {
        if (!dest) { dest = mat4.create(); }
        var rl = (right - left),
            tb = (top - bottom),
            fn = (far - near);
        dest[0] = 2 / rl;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 0;
        dest[5] = 2 / tb;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = 0;
        dest[9] = 0;
        dest[10] = -2 / fn;
        dest[11] = 0;
        dest[12] = -(left + right) / rl;
        dest[13] = -(top + bottom) / tb;
        dest[14] = -(far + near) / fn;
        dest[15] = 1;
        return dest;
    };

    /**
     * Generates a look-at matrix with the given eye position, focal point, and up axis
     *
     * @param {vec3} eye Position of the viewer
     * @param {vec3} center Point the viewer is looking at
     * @param {vec3} up vec3 pointing "up"
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.lookAt = function (eye, center, up, dest) {
        if (!dest) { dest = mat4.create(); }

        var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
            eyex = eye[0],
            eyey = eye[1],
            eyez = eye[2],
            upx = up[0],
            upy = up[1],
            upz = up[2],
            centerx = center[0],
            centery = center[1],
            centerz = center[2];

        if (eyex === centerx && eyey === centery && eyez === centerz) {
            return mat4.identity(dest);
        }

        //vec3.direction(eye, center, z);
        z0 = eyex - centerx;
        z1 = eyey - centery;
        z2 = eyez - centerz;

        // normalize (no check needed for 0 because of early return)
        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
        z0 *= len;
        z1 *= len;
        z2 *= len;

        //vec3.normalize(vec3.cross(up, z, x));
        x0 = upy * z2 - upz * z1;
        x1 = upz * z0 - upx * z2;
        x2 = upx * z1 - upy * z0;
        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
        if (!len) {
            x0 = 0;
            x1 = 0;
            x2 = 0;
        } else {
            len = 1 / len;
            x0 *= len;
            x1 *= len;
            x2 *= len;
        }

        //vec3.normalize(vec3.cross(z, x, y));
        y0 = z1 * x2 - z2 * x1;
        y1 = z2 * x0 - z0 * x2;
        y2 = z0 * x1 - z1 * x0;

        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
        if (!len) {
            y0 = 0;
            y1 = 0;
            y2 = 0;
        } else {
            len = 1 / len;
            y0 *= len;
            y1 *= len;
            y2 *= len;
        }

        dest[0] = x0;
        dest[1] = y0;
        dest[2] = z0;
        dest[3] = 0;
        dest[4] = x1;
        dest[5] = y1;
        dest[6] = z1;
        dest[7] = 0;
        dest[8] = x2;
        dest[9] = y2;
        dest[10] = z2;
        dest[11] = 0;
        dest[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
        dest[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
        dest[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
        dest[15] = 1;

        return dest;
    };

    /**
     * Creates a matrix from a quaternion rotation and vector translation
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.translate(dest, vec);
     *     var quatMat = mat4.create();
     *     quat4.toMat4(quat, quatMat);
     *     mat4.multiply(dest, quatMat);
     *
     * @param {quat4} quat Rotation quaternion
     * @param {vec3} vec Translation vector
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to a new mat4
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
/*    mat4.fromRotationTranslation = function (quat, vec, dest) {
        if (!dest) { dest = mat4.create(); }

        // Quaternion math
        var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
            x2 = x + x,
            y2 = y + y,
            z2 = z + z,

            xx = x * x2,
            xy = x * y2,
            xz = x * z2,
            yy = y * y2,
            yz = y * z2,
            zz = z * z2,
            wx = w * x2,
            wy = w * y2,
            wz = w * z2;

        dest[0] = 1 - (yy + zz);
        dest[1] = xy + wz;
        dest[2] = xz - wy;
        dest[3] = 0;
        dest[4] = xy - wz;
        dest[5] = 1 - (xx + zz);
        dest[6] = yz + wx;
        dest[7] = 0;
        dest[8] = xz + wy;
        dest[9] = yz - wx;
        dest[10] = 1 - (xx + yy);
        dest[11] = 0;
        dest[12] = vec[0];
        dest[13] = vec[1];
        dest[14] = vec[2];
        dest[15] = 1;
        
        return dest;
    };*/

    /**
     * Returns a string representation of a mat4
     *
     * @param {mat4} mat mat4 to represent as a string
     *
     * @returns {string} String representation of mat
     */
    mat4.str = function (mat) {
        return '[' + mat[0] + ', ' + mat[1] + ', ' + mat[2] + ', ' + mat[3] +
            ', ' + mat[4] + ', ' + mat[5] + ', ' + mat[6] + ', ' + mat[7] +
            ', ' + mat[8] + ', ' + mat[9] + ', ' + mat[10] + ', ' + mat[11] +
            ', ' + mat[12] + ', ' + mat[13] + ', ' + mat[14] + ', ' + mat[15] + ']';
    };

    /**
     * @class Quaternion
     * @name quat4
     */
    var quat4 = {};

    /**
     * Creates a new instance of a quat4 using the default array type
     * Any javascript array containing at least 4 numeric elements can serve as a quat4
     *
     * @param {quat4} [quat] quat4 containing values to initialize with
     *
     * @returns {quat4} New quat4
     */
    quat4.create = function (quat) {
        var dest = new MatrixArray(4);

        if (quat) {
            dest[0] = quat[0];
            dest[1] = quat[1];
            dest[2] = quat[2];
            dest[3] = quat[3];
        } else {
            dest[0] = dest[1] = dest[2] = dest[3] = 0;
        }

        return dest;
    };

    /**
     * Creates a new instance of a quat4, initializing it with the given arguments
     *
     * @param {number} x X value
     * @param {number} y Y value
     * @param {number} z Z value
     * @param {number} w W value

     * @returns {quat4} New quat4
     */
    quat4.createFrom = function (x, y, z, w) {
        var dest = new MatrixArray(4);

        dest[0] = x;
        dest[1] = y;
        dest[2] = z;
        dest[3] = w;

        return dest;
    };

    /**
     * Copies the values of one quat4 to another
     *
     * @param {quat4} quat quat4 containing values to copy
     * @param {quat4} dest quat4 receiving copied values
     *
     * @returns {quat4} dest
     */
    quat4.set = function (quat, dest) {
        dest[0] = quat[0];
        dest[1] = quat[1];
        dest[2] = quat[2];
        dest[3] = quat[3];

        return dest;
    };

    /**
     * Compares two quaternions for equality within a certain margin of error
     *
     * @param {quat4} a First vector
     * @param {quat4} b Second vector
     *
     * @returns {Boolean} True if a is equivalent to b
     */
    quat4.equal = function (a, b) {
        return a === b || (
            Math.abs(a[0] - b[0]) < FLOAT_EPSILON &&
            Math.abs(a[1] - b[1]) < FLOAT_EPSILON &&
            Math.abs(a[2] - b[2]) < FLOAT_EPSILON &&
            Math.abs(a[3] - b[3]) < FLOAT_EPSILON
        );
    };

    /**
     * Creates a new identity Quat4
     *
     * @param {quat4} [dest] quat4 receiving copied values
     *
     * @returns {quat4} dest is specified, new quat4 otherwise
     */
    quat4.identity = function (dest) {
        if (!dest) { dest = quat4.create(); }
        dest[0] = 0;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 1;
        return dest;
    };

    //var identityQuat4 = quat4.identity();

    /**
     * Calculates the W component of a quat4 from the X, Y, and Z components.
     * Assumes that quaternion is 1 unit in length.
     * Any existing W component will be ignored.
     *
     * @param {quat4} quat quat4 to calculate W component of
     * @param {quat4} [dest] quat4 receiving calculated values. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.calculateW = function (quat, dest) {
        var x = quat[0], y = quat[1], z = quat[2];

        if (!dest || quat === dest) {
            quat[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
            return quat;
        }
        dest[0] = x;
        dest[1] = y;
        dest[2] = z;
        dest[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
        return dest;
    };

    /**
     * Calculates the dot product of two quaternions
     *
     * @param {quat4} quat First operand
     * @param {quat4} quat2 Second operand
     *
     * @return {number} Dot product of quat and quat2
     */
    quat4.dot = function(quat, quat2){
        return quat[0]*quat2[0] + quat[1]*quat2[1] + quat[2]*quat2[2] + quat[3]*quat2[3];
    };

    /**
     * Calculates the inverse of a quat4
     *
     * @param {quat4} quat quat4 to calculate inverse of
     * @param {quat4} [dest] quat4 receiving inverse values. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.inverse = function(quat, dest) {
        var q0 = quat[0], q1 = quat[1], q2 = quat[2], q3 = quat[3],
            dot = q0*q0 + q1*q1 + q2*q2 + q3*q3,
            invDot = dot ? 1.0/dot : 0;
        
        // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0
        
        if(!dest || quat === dest) {
            quat[0] *= -invDot;
            quat[1] *= -invDot;
            quat[2] *= -invDot;
            quat[3] *= invDot;
            return quat;
        }
        dest[0] = -quat[0]*invDot;
        dest[1] = -quat[1]*invDot;
        dest[2] = -quat[2]*invDot;
        dest[3] = quat[3]*invDot;
        return dest;
    };


    /**
     * Calculates the conjugate of a quat4
     * If the quaternion is normalized, this function is faster than quat4.inverse and produces the same result.
     *
     * @param {quat4} quat quat4 to calculate conjugate of
     * @param {quat4} [dest] quat4 receiving conjugate values. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.conjugate = function (quat, dest) {
        if (!dest || quat === dest) {
            quat[0] *= -1;
            quat[1] *= -1;
            quat[2] *= -1;
            return quat;
        }
        dest[0] = -quat[0];
        dest[1] = -quat[1];
        dest[2] = -quat[2];
        dest[3] = quat[3];
        return dest;
    };

    /**
     * Calculates the length of a quat4
     *
     * Params:
     * @param {quat4} quat quat4 to calculate length of
     *
     * @returns Length of quat
     */
    quat4.length = function (quat) {
        var x = quat[0], y = quat[1], z = quat[2], w = quat[3];
        return Math.sqrt(x * x + y * y + z * z + w * w);
    };

    /**
     * Generates a unit quaternion of the same direction as the provided quat4
     * If quaternion length is 0, returns [0, 0, 0, 0]
     *
     * @param {quat4} quat quat4 to normalize
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.normalize = function (quat, dest) {
        if (!dest) { dest = quat; }

        var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
            len = Math.sqrt(x * x + y * y + z * z + w * w);
        if (len === 0) {
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            dest[3] = 0;
            return dest;
        }
        len = 1 / len;
        dest[0] = x * len;
        dest[1] = y * len;
        dest[2] = z * len;
        dest[3] = w * len;

        return dest;
    };

    /**
     * Performs quaternion addition
     *
     * @param {quat4} quat First operand
     * @param {quat4} quat2 Second operand
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.add = function (quat, quat2, dest) {
        if(!dest || quat === dest) {
            quat[0] += quat2[0];
            quat[1] += quat2[1];
            quat[2] += quat2[2];
            quat[3] += quat2[3];
            return quat;
        }
        dest[0] = quat[0]+quat2[0];
        dest[1] = quat[1]+quat2[1];
        dest[2] = quat[2]+quat2[2];
        dest[3] = quat[3]+quat2[3];
        return dest;
    };

    /**
     * Performs a quaternion multiplication
     *
     * @param {quat4} quat First operand
     * @param {quat4} quat2 Second operand
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.multiply = function (quat, quat2, dest) {
        if (!dest) { dest = quat; }

        var qax = quat[0], qay = quat[1], qaz = quat[2], qaw = quat[3],
            qbx = quat2[0], qby = quat2[1], qbz = quat2[2], qbw = quat2[3];

        dest[0] = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        dest[1] = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        dest[2] = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        dest[3] = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

        return dest;
    };

    /**
     * Transforms a vec3 with the given quaternion
     *
     * @param {quat4} quat quat4 to transform the vector with
     * @param {vec3} vec vec3 to transform
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns dest if specified, vec otherwise
     */
    quat4.multiplyVec3 = function (quat, vec, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0], y = vec[1], z = vec[2],
            qx = quat[0], qy = quat[1], qz = quat[2], qw = quat[3],

            // calculate quat * vec
            ix = qw * x + qy * z - qz * y,
            iy = qw * y + qz * x - qx * z,
            iz = qw * z + qx * y - qy * x,
            iw = -qx * x - qy * y - qz * z;

        // calculate result * inverse quat
        dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;

        return dest;
    };

    /**
     * Multiplies the components of a quaternion by a scalar value
     *
     * @param {quat4} quat to scale
     * @param {number} val Value to scale by
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.scale = function (quat, val, dest) {
        if(!dest || quat === dest) {
            quat[0] *= val;
            quat[1] *= val;
            quat[2] *= val;
            quat[3] *= val;
            return quat;
        }
        dest[0] = quat[0]*val;
        dest[1] = quat[1]*val;
        dest[2] = quat[2]*val;
        dest[3] = quat[3]*val;
        return dest;
    };

    /**
     * Calculates a 4x4 matrix from the given quat4
     *
     * @param {quat4} quat quat4 to create matrix from
     * @param {mat4} [dest] mat4 receiving operation result
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    quat4.toMat4 = function (quat, dest) {
        if (!dest) { dest = mat4.create(); }

        var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
            x2 = x + x,
            y2 = y + y,
            z2 = z + z,

            xx = x * x2,
            xy = x * y2,
            xz = x * z2,
            yy = y * y2,
            yz = y * z2,
            zz = z * z2,
            wx = w * x2,
            wy = w * y2,
            wz = w * z2;

        dest[0] = 1 - (yy + zz);
        dest[1] = xy + wz;
        dest[2] = xz - wy;
        dest[3] = 0;

        dest[4] = xy - wz;
        dest[5] = 1 - (xx + zz);
        dest[6] = yz + wx;
        dest[7] = 0;

        dest[8] = xz + wy;
        dest[9] = yz - wx;
        dest[10] = 1 - (xx + yy);
        dest[11] = 0;

        dest[12] = 0;
        dest[13] = 0;
        dest[14] = 0;
        dest[15] = 1;

        return dest;
    };

    /**
     * Performs a spherical linear interpolation between two quat4
     *
     * @param {quat4} quat First quaternion
     * @param {quat4} quat2 Second quaternion
     * @param {number} slerp Interpolation amount between the two inputs
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.slerp = function (quat, quat2, slerp, dest) {
        if (!dest) { dest = quat; }

        var cosHalfTheta = quat[0] * quat2[0] + quat[1] * quat2[1] + quat[2] * quat2[2] + quat[3] * quat2[3],
            halfTheta,
            sinHalfTheta,
            ratioA,
            ratioB;

        if (Math.abs(cosHalfTheta) >= 1.0) {
            if (dest !== quat) {
                dest[0] = quat[0];
                dest[1] = quat[1];
                dest[2] = quat[2];
                dest[3] = quat[3];
            }
            return dest;
        }

        halfTheta = Math.acos(cosHalfTheta);
        sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);

        if (Math.abs(sinHalfTheta) < 0.001) {
            dest[0] = (quat[0] * 0.5 + quat2[0] * 0.5);
            dest[1] = (quat[1] * 0.5 + quat2[1] * 0.5);
            dest[2] = (quat[2] * 0.5 + quat2[2] * 0.5);
            dest[3] = (quat[3] * 0.5 + quat2[3] * 0.5);
            return dest;
        }

        ratioA = Math.sin((1 - slerp) * halfTheta) / sinHalfTheta;
        ratioB = Math.sin(slerp * halfTheta) / sinHalfTheta;

        dest[0] = (quat[0] * ratioA + quat2[0] * ratioB);
        dest[1] = (quat[1] * ratioA + quat2[1] * ratioB);
        dest[2] = (quat[2] * ratioA + quat2[2] * ratioB);
        dest[3] = (quat[3] * ratioA + quat2[3] * ratioB);

        return dest;
    };

    /**
     * Creates a quaternion from the given 3x3 rotation matrix.
     * If dest is omitted, a new quaternion will be created.
     *
     * @param {mat3}  mat    the rotation matrix
     * @param {quat4} [dest] an optional receiving quaternion
     *
     * @returns {quat4} the quaternion constructed from the rotation matrix
     *
     */
    quat4.fromRotationMatrix = function(mat, dest) {
        if (!dest) dest = quat4.create();
        
        // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
        // article "Quaternion Calculus and Fast Animation".

        var fTrace = mat[0] + mat[4] + mat[8];
        var fRoot;

        if ( fTrace > 0.0 ) {
            // |w| > 1/2, may as well choose w > 1/2
            fRoot = Math.sqrt(fTrace + 1.0);  // 2w
            dest[3] = 0.5 * fRoot;
            fRoot = 0.5/fRoot;  // 1/(4w)
            dest[0] = (mat[7]-mat[5])*fRoot;
            dest[1] = (mat[2]-mat[6])*fRoot;
            dest[2] = (mat[3]-mat[1])*fRoot;
        } else {
            // |w| <= 1/2
            var s_iNext = quat4.fromRotationMatrix.s_iNext = quat4.fromRotationMatrix.s_iNext || [1,2,0];
            var i = 0;
            if ( mat[4] > mat[0] )
              i = 1;
            if ( mat[8] > mat[i*3+i] )
              i = 2;
            var j = s_iNext[i];
            var k = s_iNext[j];
            
            fRoot = Math.sqrt(mat[i*3+i]-mat[j*3+j]-mat[k*3+k] + 1.0);
            dest[i] = 0.5 * fRoot;
            fRoot = 0.5 / fRoot;
            dest[3] = (mat[k*3+j] - mat[j*3+k]) * fRoot;
            dest[j] = (mat[j*3+i] + mat[i*3+j]) * fRoot;
            dest[k] = (mat[k*3+i] + mat[i*3+k]) * fRoot;
        }
        
        return dest;
    };

 
    /**
     * Sets a quat4 to the Identity and returns it.
     *
     * @param {quat4} [dest] quat4 to set. If omitted, a
     * new quat4 will be created.
     *
     * @returns {quat4} dest
     */
    quat4.identity = function(dest) {
        if (!dest) dest = quat4.create();
        dest[0] = 0;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 1;
        return dest;
    };

    /**
     * Sets a quat4 from the given angle and rotation axis,
     * then returns it. If dest is not given, a new quat4 is created.
     *
     * @param {Number} angle  the angle in radians
     * @param {vec3}   axis   the axis around which to rotate
     * @param {quat4}  [dest] the optional quat4 to store the result
     *
     * @returns {quat4} dest
     **/
    quat4.fromAngleAxis = function(angle, axis, dest) {
        // The quaternion representing the rotation is
        //   q = cos(A/2)+sin(A/2)*(x*i+y*j+z*k)
        if (!dest) dest = quat4.create();
        
        var half = angle * 0.5;
        var s = Math.sin(half);
        dest[3] = Math.cos(half);
        dest[0] = s * axis[0];
        dest[1] = s * axis[1];
        dest[2] = s * axis[2];
        
        return dest;
    };

    /**
     * Stores the angle and axis in a vec4, where the XYZ components represent
     * the axis and the W (4th) component is the angle in radians.
     *
     * If dest is not given, src will be modified in place and returned, after
     * which it should not be considered not a quaternion (just an axis and angle).
     *
     * @param {quat4} quat   the quaternion whose angle and axis to store
     * @param {vec4}  [dest] the optional vec4 to receive the data
     *
     * @returns {vec4} dest
     */
    quat4.toAngleAxis = function(src, dest) {
        if (!dest) dest = src;
        // The quaternion representing the rotation is
        //   q = cos(A/2)+sin(A/2)*(x*i+y*j+z*k)

        var sqrlen = src[0]*src[0]+src[1]*src[1]+src[2]*src[2];
        if (sqrlen > 0)
        {
            dest[3] = 2 * Math.acos(src[3]);
            var invlen = 1.0 / Math.sqrt(sqrlen);
            dest[0] = src[0]*invlen;
            dest[1] = src[1]*invlen;
            dest[2] = src[2]*invlen;
        } else {
            // angle is 0 (mod 2*pi), so any axis will do
            dest[3] = 0;
            dest[0] = 1;
            dest[1] = 0;
            dest[2] = 0;
        }
        
        return dest;
    };

    /**
     * Returns a string representation of a quaternion
     *
     * @param {quat4} quat quat4 to represent as a string
     *
     * @returns {string} String representation of quat
     */
    quat4.str = function (quat) {
        return '[' + quat[0] + ', ' + quat[1] + ', ' + quat[2] + ', ' + quat[3] + ']';
    };
   

    /*
     * Exports
     */

	window.vec3 = vec3;
	window.mat4 = mat4;
	window.quat4 = quat4;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/



/**************************************************************************************************************/

/** @constructor
	Plane constructor
 */
var Plane = function()
{
	this.normal = vec3.create( [0.0, 0.0, 0.0] );
	this.d = 0.0;
}

/**************************************************************************************************************/

/**
	Plane init from 3 points
 */
Plane.prototype.init = function( v1, v2, v3 )
{
	var vu = [];
	var vv = [];
	vec3.subtract( v2, v1, vu );
	vec3.subtract( v3, v1, vv );
	vec3.cross( vu, vv, this.normal );
	vec3.normalize( this.normal );
	this.d = - vec3.dot( v1, this.normal );
}


/**************************************************************************************************************/

/**
	Transform the plane with the given matrix
 */
Plane.prototype.transform = function(matrix)
{
	var vec = [ this.normal[0], this.normal[1], this.normal[2], this.d ];
	mat4.multiplyVec4(matrix,vec);
	this.normal[0] = vec[0];
	this.normal[1] = vec[1];
	this.normal[2] = vec[2];
	this.d = vec[3];
}

/**************************************************************************************************************/

/**
 Intersection test between plane and bounding sphere.
           return 1 if the bs is completely above plane,
            return 0 if the bs intersects the plane,
            return -1 if the bs is completely below the plane.
*/
Plane.prototype.intersectSphere = function( center, radius )
{
	var dist = vec3.dot( center, this.normal ) + this.d;
	if 	(dist > radius) return 1;
	else if ( dist < - radius ) return -1;
	else return 0;
}

/**************************************************************************************************************/

/**
	Return the distance between a point and the plane
*/
Plane.prototype.distance = function( point )
{
	return point[0] * this.normal[0] + point[1] * this.normal[1] + point[2] * this.normal[2] +  this.d
}


/**************************************************************************************************************/

/**
 Intersection test between plane and bounding box.
           return 1 if the bbox is completely above plane,
            return 0 if the bbox intersects the plane,
            return -1 if the bbox is completely below the plane.
*/
Plane.prototype.intersectBoundingBox = function( bbox )
{
	var upperBBCorner = (this.normal[0]>=0.0?1:0) |
                             (this.normal[1]>=0.0?2:0) |
                             (this.normal[2]>=0.0?4:0);
							 
	var lowerBBCorner = (~upperBBCorner)&7;

	// if lowest point above plane than all above.
	if ( this.distance(bbox.getCorner(lowerBBCorner)) > 0.0) return 1;

	// if highest point is below plane then all below.
	if ( this.distance(bbox.getCorner(upperBBCorner)) < 0.0) return -1;

	// d_lower<=0.0f && d_upper>=0.0f
	// therefore must be crossing plane.
	return 0;
}

/**************************************************************************************************************/

/** @constructor
	Frustum constructor
 */
var Frustum = function()
{
	// The frustum does not contains near and far plane, because near and far are computed during rendering.
	// Some tests have been done with a near plane but are not really useful
	this.planes = [ new Plane(), new Plane(), new Plane(), new Plane(), new Plane() ];
	//this.planes = [ new Plane(), new Plane(), new Plane(), new Plane() ];
}

/**************************************************************************************************************/

/**
	Compute the frustum from the given projection matrix
 */
Frustum.prototype.compute = function(projectionMatrix)
{
	var inverseProjectionMatrix = mat4.create();
	mat4.inverse( projectionMatrix, inverseProjectionMatrix )
	
	var bottomleft = mat4.project( inverseProjectionMatrix, [-1.0,-1.0,-1.0,1.0] );
	var topleft = mat4.project( inverseProjectionMatrix, [-1.0,1.0,-1.0,1.0] );
	var topright = mat4.project( inverseProjectionMatrix, [1.0,1.0,-1.0,1.0] );
	var bottomright = mat4.project( inverseProjectionMatrix, [1.0,-1.0,-1.0,1.0] );
	
	this.planes[0].init( [0.0,0.0,0.0], bottomleft, topleft );
	this.planes[1].init( [0.0,0.0,0.0], topleft, topright );
	this.planes[2].init( [0.0,0.0,0.0], topright, bottomright );
	this.planes[3].init( [0.0,0.0,0.0], bottomright, bottomleft );
	
	// A plane for near plane if needed
	this.planes[4].init( bottomleft, topleft, topright );
}

/**************************************************************************************************************/

/**
	Transform the frustum with the given matrix
 */
Frustum.prototype.transform = function(frustum,matrix)
{
	var mat = mat4.create();
	mat4.inverse(matrix,mat);
	this.inverseTransform(frustum,mat);
}

/**************************************************************************************************************/

/**
	Inverse transform the frustum with the given matrix
 */
Frustum.prototype.inverseTransform = function(frustum,matrix)
{
	// Optimized implementation
	for ( var i = 0; i < frustum.planes.length; i++ )
	{
		var plane = frustum.planes[i];
		
		var x = plane.normal[0];
		var y = plane.normal[1];
		var z = plane.normal[2];
		var w = plane.d;

		plane = this.planes[i];
		
		plane.normal[0] = matrix[0]*x + matrix[1]*y + matrix[2]*z + matrix[3]*w;
		plane.normal[1] = matrix[4]*x + matrix[5]*y + matrix[6]*z + matrix[7]*w;
		plane.normal[2] = matrix[8]*x + matrix[9]*y + matrix[10]*z + matrix[11]*w;
		plane.d = matrix[12]*x + matrix[13]*y + matrix[14]*z + matrix[15]*w;
	}
}

/**************************************************************************************************************/

/**
	Intersection test between frustum and bounding sphere.
	   return 1 if the bs is completely inside the frustum,
		return 0 if the bs intersects the frustum,
		return -1 if the bs is completely outside the frustum.
 */
Frustum.prototype.containsSphere = function( center, radius )
{
	var flag = 1;
	
	for (var i = 0; i < this.planes.length; i++)
	{
		var pn = this.planes[i].normal;
		
		// Compute distance between center and plane (inline to be more efficient)
		var dist = center[0]*pn[0] + center[1]*pn[1] + center[2]*pn[2] + this.planes[i].d;
		
		if 	(dist <= radius)
		{
			if ( dist < - radius ) 
				return -1;
			else 
				flag = 0;
		}	
	}
	
	return flag;
}

/**************************************************************************************************************/

/**
	Test if the frustum contains the given bounding box
 */
Frustum.prototype.containsBoundingBox = function( bbox )
{
	// Optimized implementation
	for (var i = 0; i < this.planes.length; i++)
	{
		var plane = this.planes[i];
		
		// Get the closest point on the bbox
		var bbx = plane.normal[0]>=0.0 ? bbox.max[0] : bbox.min[0];
		var bby = plane.normal[1]>=0.0 ? bbox.max[1] : bbox.min[1];
		var bbz = plane.normal[2]>=0.0 ? bbox.max[2] : bbox.min[2];
		
		// Compute the distance
		var distance = bbx * plane.normal[0] + bby * plane.normal[1] + bbz * plane.normal[2] +  plane.d

		// if highest point is below plane then all below.
		if ( distance < 0.0) return false;
	}
	
/*	for (var i = 0; i < 4; i++)
	{
		if ( this.planes[i].intersectBoundingBox( bbox ) < 0 )
		{
			return false;
		}
	}*/
	
	return true;
}

/**************************************************************************************************************/

// Export plane
Frustum.Plane = Plane;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
 


/**************************************************************************************************************/

/** 
	@constructor
	Function constructor for RencerContext
*/
var RenderContext = function(options)
{
	/**
	 * Private properties
	 */
	 
	/**
	 * Private method
	 */

	
	/**
	 * Constructor
	 */
	this.activeAnimations = [];
	this.shadersPath = options['shadersPath'] || "../shaders/";
	this.tileErrorTreshold = options['tileErrorTreshold'] || 4;
	this.lighting = options['lighting'] || false;
	this.continuousRendering = options['continuousRendering'] || false;
	this.stats = null;
	this.isActive = true;

	// Init GL
	var canvas = null;
	
	// Check canvas options
	if (!options['canvas'])
		throw "GlobWeb : no canvas in options";
	

	if (typeof options['canvas'] == "string") 
	{
		canvas = document.getElementById(options['canvas']);
	}
	else
	{
		canvas = options['canvas'];
	}
	
	// Check canvas is valid
	if (!canvas instanceof HTMLCanvasElement)
		throw "GlobWeb : invalid canvas";
		
	// Create the webl context
	var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
	var gl = null;
	for (var ii = 0; ii < names.length && gl == null; ++ii) 
	{
		try 
		{
		  gl = canvas.getContext(names[ii], RenderContext.contextAttributes);
		} 
		catch(e) {}
	}
	
	if ( gl == null )
		throw "GlobWeb : WebGL context cannot be initialized";

	
	if ( options['backgroundColor'] )
	{
		var color = options['backgroundColor'];
		gl.clearColor(color[0],color[1],color[2],color[3]);
	}
	else
	{
		gl.clearColor(0.0, 0.0, 0.0, 1.0);
	}
	
	gl.getExtension('OES_element_index_uint');
	
	gl.pixelStorei( gl['UNPACK_COLORSPACE_CONVERSION_WEBGL'], gl.NONE );
	gl.enable(gl.DEPTH_TEST);
	gl.enable(gl.CULL_FACE);
		
	// Store local variable into static object
	this.viewMatrix = mat4.create();
	this.modelViewMatrix =  mat4.create();
	this.projectionMatrix = mat4.create();
	this.gl = gl;
	this.canvas = canvas;
	this.frustum = new Frustum();
	this.worldFrustum = new Frustum();
	this.localFrustum = new Frustum();
	this.eyePosition = vec3.create();
	this.eyeDirection = vec3.create();
	this.minNear = 0.0001;
	this.minFar = options['minFar'] || 0; // No limit on far
	this.near = RenderContext.minNear;
	this.far = 6.0;
	this.numActiveAttribArray = 0;
	this.frameRequested = false;
	this.fov = 45;
	this.renderers = [];
	
	
	// Initialize the window requestAnimationFrame
	if ( !window.requestAnimationFrame ) 
	{
		window.requestAnimationFrame = ( function() {
			return window.webkitRequestAnimationFrame ||
				 window.mozRequestAnimationFrame ||
				window.oRequestAnimationFrame ||
				window.msRequestAnimationFrame ||
				function( callback, element ) { window.setTimeout( callback, 1000 / 60 );};
			} )();
	}
	
	var self = this;
	this.frameCallback = function() { self.frame(); };
}

/**************************************************************************************************************/

/** 
	The context attributes used when creating WebGL context, see WebGL specification.
	Can be changed by the renderers if needed, or by an external interface.
*/
RenderContext.contextAttributes = {};

/**************************************************************************************************************/

/** 
	Request a frame
*/
RenderContext.prototype.requestFrame = function()
{	
	if (!this.frameRequested)
	{
		window.requestAnimationFrame( this.frameCallback );
		this.frameRequested = true;
	}
}


/**************************************************************************************************************/

/**
 	Deactivate render context
 */
RenderContext.prototype.deactivate = function()
{
	this.isActive = false;
	this.frameRequested = false;
}

/**************************************************************************************************************/

/**
 	Activate render context
 */
RenderContext.prototype.activate = function()
{
	this.isActive = true;
}

/**************************************************************************************************************/

/** 
	A frame of the application
*/
RenderContext.prototype.frame = function() 
{
	if ( this.isActive )
	{
		// Reset frame requested flag first
		this.frameRequested = false;
		
		var stats = this.stats;
		var gl = this.gl;

		if (stats) stats.start("globalRenderTime");
		
		// Update active animations
		if ( this.activeAnimations.length > 0)
		{
			var time = Date.now();
			for (var i = 0; i < this.activeAnimations.length; i++)
			{
				this.activeAnimations[i].update(time);
			}
		}
		
		// Clear the buffer
		if ( RenderContext.contextAttributes.stencil )
		{
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
		}
		else
		{
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		}
		
		// Check canvas size is valid
		if ( this.canvas.width == 0 || this.canvas.height == 0 )
			return;
			
		gl.viewport(0, 0, this.canvas.width, this.canvas.height);

		// Update view dependent properties to be used during rendering : view matrix, frustum, projection, etc...
		this.updateViewDependentProperties();
				
		// Call render method of all registered renderers
		for ( var i=0; i<this.renderers.length; i++ )
		{
			this.renderers[i].render();
		}
		
		if (stats) stats.end("globalRenderTime");
		
		// Request next frame
		if ( this.continuousRendering )
		{
			this.requestFrame();
		}
		else if ( this.activeAnimations.length > 0 )
		{
			this.requestFrame();
		}
	}	
};

/**************************************************************************************************************/

/** 
	Update properies that depends on the view matrix
*/
RenderContext.prototype.updateViewDependentProperties = function()
{
	var inverseViewMatrix = mat4.create();
	mat4.inverse( this.viewMatrix, inverseViewMatrix );
	
	vec3.set( [ 0.0, 0.0, 0.0 ], this.eyePosition );
	mat4.multiplyVec3( inverseViewMatrix, this.eyePosition );
	
	vec3.set( [ 0.0, 0.0, -1.0 ], this.eyeDirection );
	mat4.rotateVec3( inverseViewMatrix, this.eyeDirection );
	
	// Init projection matrix
	mat4.perspective(this.fov, this.canvas.width / this.canvas.height, this.minNear, this.far, this.projectionMatrix);
	
	// Compute the frustum from the projection matrix
	this.frustum.compute(this.projectionMatrix);
	
	// Compute the world frustum
	this.worldFrustum.inverseTransform( this.frustum, this.viewMatrix );
	
	// Compute the pixel size vector from the current view/projection matrix
	this.pixelSizeVector = this.computePixelSizeVector();
}

/**************************************************************************************************************/

/**
	Get mouse coordinates relative to the canvas element
*/
RenderContext.prototype.getXYRelativeToCanvas = function(event)
{
	// cf. http://stackoverflow.com/questions/55677/how-do-i-get-the-coordinates-of-a-mouse-click-on-a-canvas-element
	var pos = [];
	if (event.pageX || event.pageY)
	{
		pos[0] = event.pageX;
		pos[1] = event.pageY;
	}
	else
	{ 
		pos[0] = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft; 
		pos[1] = event.clientY + document.body.scrollTop + document.documentElement.scrollTop; 
	}
	
	var element = this.canvas; 
	while (element)
	{
		pos[0] -= element.offsetLeft;
		pos[1] -= element.offsetTop;
		element = element.offsetParent;
	}
        
	return pos;
}


/**************************************************************************************************************/

/** 
	Compute the pixel size vector
*/
RenderContext.prototype.computePixelSizeVector = function( mv )
{
	// pre adjust P00,P20,P23,P33 by multiplying them by the viewport window matrix.
	// here we do it in short hand with the knowledge of how the window matrix is formed
	// note P23,P33 are multiplied by an implicit 1 which would come from the window matrix.
	// Robert Osfield, June 2002.
	
	var width = this.canvas.width;
	var height = this.canvas.height;
	var P = this.projectionMatrix;
	var V = mv || this.viewMatrix;
	
	// scaling for horizontal pixels
	var P00 = P[0]*width*0.5;
	var P20_00 = P[8]*width*0.5 + P[11]*width*0.5;
	var scale_00 = [ V[0]*P00 + V[2]*P20_00,
			V[4]*P00 + V[6]*P20_00,
			V[8]*P00 + V[10]*P20_00 ];

	// scaling for vertical pixels
	var P10 = P[5]*height*0.5;
	var P20_10 = P[9]*height*0.5 + P[11]*height*0.5;
	var scale_10 = [ V[1]*P10 + V[2]*P20_10,
			V[5]*P10 + V[6]*P20_10,
			V[9]*P10 + V[10]*P20_10 ];

	var P23 = P[11];
	var P33 = P[15];
	var pixelSizeVector = [V[2]*P23,
				V[6]*P23,
				V[10]*P23,
				V[14]*P23 + V[15]*P33];

	var scaleRatio  = 0.7071067811 / Math.sqrt( vec3.dot(scale_00,scale_00)+ vec3.dot(scale_10,scale_10) );
	pixelSizeVector[0] *= scaleRatio;
	pixelSizeVector[1] *= scaleRatio;
	pixelSizeVector[2] *= scaleRatio;
	pixelSizeVector[3] *= scaleRatio;

	return pixelSizeVector;
}

/**************************************************************************************************************/

/** 
	Get pixel from 3D
	TODO: move it to Globe/Sky too ?
*/
RenderContext.prototype.getPixelFrom3D = function(x,y,z)
{
	var viewProjectionMatrix = mat4.create();
	mat4.multiply(this.projectionMatrix, this.viewMatrix, viewProjectionMatrix);
	
	// transform world to clipping coordinates
	var point3D = [x,y,z,1];
	mat4.project(viewProjectionMatrix, point3D);
	
	// transform clipping to window coordinates
	var winX = Math.round( ( 1 + point3D[0] ) * 0.5 * this.canvas.width );
	
	// reverse y because (0,0) is top left but opengl's normalized
	// device coordinate (-1,-1) is bottom left
	var winY = Math.round( ( 1 - point3D[1] ) * 0.5 * this.canvas.height );

	return [winX, winY];
}

/**************************************************************************************************************/

/** 
	Create a non power of two texture from an image
*/
RenderContext.prototype.createNonPowerOfTwoTextureFromImage = function(image, invertY)
{	
	var gl = this.gl;
	var tex = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, tex);
	gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, invertY);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	// Restore to default
	gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
	return tex;
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/



/**************************************************************************************************************/

/** @constructor
	BoundingBox constructor
 */
var BoundingBox = function(min,max)
{
	if (min)
	{
		this.min = vec3.create( min );
	}
	if (max)
	{
		this.max = vec3.create( max );
	}
}

/**************************************************************************************************************/

/**
	Extent the bounding box with the given point
 */
BoundingBox.prototype.extend = function( x, y, z)
{
	if (!this.min)
	{
		this.min = vec3.create();
		this.max = vec3.create();
		
		this.min[0] = x;
		this.min[1] = y;
		this.min[2] = z;
		this.max[0] = x;
		this.max[1] = y;
		this.max[2] = z;
	}
	else
	{
		if ( x < this.min[0] )
		{
			this.min[0] = x;
		}
		if ( y < this.min[1] )
		{
			this.min[1] = y;
		}
		if ( z < this.min[2] )
		{
			this.min[2] = z;
		}
		if ( x > this.max[0] )
		{
			this.max[0] = x;
		}
		if ( y > this.max[1] )
		{
			this.max[1] = y;
		}
		if ( z > this.max[2] )
		{
			this.max[2] = z;
		}
	}
}
/**************************************************************************************************************/

/**
	Compute the bounding box from an array of vertices
 */
BoundingBox.prototype.compute = function(vertices,length,stride)
{
	if (!this.min)
	{
		this.min = vec3.create();
		this.max = vec3.create();
	}
	
	this.min[0] = vertices[0];
	this.min[1] = vertices[1];
	this.min[2] = vertices[2];
	this.max[0] = vertices[0];
	this.max[1] = vertices[1];
	this.max[2] = vertices[2];
	
	var st = stride || 3;
	var ll = length || vertices.length;
	
	for (var i=st; i < ll; i += st)
	{
		for (var j=0; j < 3; j++)
		{
			if ( vertices[i+j] < this.min[j] )
			{
				this.min[j] = vertices[i+j];
			}
			if ( vertices[i+j] > this.max[j] )
			{
				this.max[j] = vertices[i+j];
			}
		}
	}
}

/**************************************************************************************************************/

/**
	Get the corner of a bounding box
 */
BoundingBox.prototype.getCorner = function(pos)
{
	return [ pos&1 ? this.max[0] : this.min[0],
			pos&2 ? this.max[1] : this.min[1],
			pos&4 ? this.max[2] : this.min[2]	];
}

/**************************************************************************************************************/

/**
	Get the center of a bounding box
 */
BoundingBox.prototype.getCenter = function()
{
	return [ (this.max[0] + this.min[0]) * 0.5,
			(this.max[1] + this.min[1]) * 0.5,
			(this.max[2] + this.min[2]) * 0.5	];
}

/**************************************************************************************************************/

/**
	Get the radius of a bounding box
 */
BoundingBox.prototype.getRadius = function()
{
	var vec = vec3.create();
	vec3.subtract( this.max, this.min, vec)
	return 0.5 * vec3.length(vec);
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 

/**************************************************************************************************************/

/** @constructor
	Tile constructor
 */
var Tile = function()
{
	// Parent/child relationship
	this.parent = null;
	this.parentIndex = -1;
	this.children = null;
	
	// Graphics data to render the tile
	this.vertices = null;
	this.texture = null;
	this.vertexBuffer = null;
	this.texTransform = [1., 1., 0., 0.];
	
	// Tile spatial data
	this.matrix = null;
	this.inverseMatrix = null;
	this.bbox = new BoundingBox();
	
	// For culling
	this.radius = 0.0;	
	this.distance = 0.0;
	this.closestPointToEye = [ 0.0, 0.0, 0.0 ];
	
	// Specific object to store extension from renderers
	this.extension = {};
	
	// For debug
	//this.color = [ Math.random(), Math.random(), Math.random() ];
	
	this.state = Tile.State.NONE;
	
	// Tile configuration given by tile manager : contains if the tile uses skirt, the tesselation, etc...
	this.config = null;
	this.imageSize = 256;
}

/**************************************************************************************************************/

/**
 *	Tile state enumerations
 */
Tile.State = 
{
	ERROR : -10,
	NONE : 0,
	REQUESTED : 1,
	LOADING : 2,
	LOADED : 3
};


/**************************************************************************************************************/

/**
 * Compute position on the tile using normalized coordinate between [0,size-1]
 */
Tile.prototype.computePosition = function(u,v)
{
	var size = this.config.tesselation;
	u = Math.min( size-1, Math.max( 0, u ) );
	v = Math.min( size-1, Math.max( 0, v ) );
	
	var vFloor = Math.floor( v );
	var vFrac = v - vFloor;
	var uFloor = Math.floor( u );
	var uFrac = u - uFloor;
	var vertexSize = this.config.vertexSize;
	var vertexOffset = vertexSize*( vFloor*size + uFloor );
	var vec = [ 0.0, 0.0, 0.0 ];
	for ( var i=0; i < 3; i++)
	{
		vec[i] = (1.0 - vFrac) * (1.0 - uFrac) * this.vertices[ vertexOffset + i ]
		+ vFrac * (1.0 - uFrac) * this.vertices[ vertexOffset + vertexSize*size + i ]
		+ vFrac * uFrac * this.vertices[ vertexOffset + vertexSize*size + vertexSize + i ]
		+ (1.0 - vFrac) * uFrac * this.vertices[ vertexOffset + vertexSize + i ];
	}
	
	return vec;
}


/**************************************************************************************************************/

/**
 *	Initialize the tile from its parent
 */
Tile.prototype.initFromParent = function(parent,i,j)
{
	this.parent = parent;
	this.parentIndex = j*2 + i;
	this.matrix  = parent.matrix;
	this.inverseMatrix  = parent.inverseMatrix;
	this.texture = parent.texture;
	this.config = parent.config;
	
	this.vertexBuffer = parent.vertexBuffer;
	
	// Recompute the bounding box
	// Very fast and coarse version but it does not work with HEALPix tiling
	//var w = 0.5 * (parent.bbox.max[0] - parent.bbox.min[0]);
	//var h = -0.5 * (parent.bbox.max[1] - parent.bbox.min[1]);
	//var min = [  parent.bbox.min[0] + i * w, parent.bbox.max[1] + (j+1) * h, parent.bbox.min[2] ];
	//var max = [  parent.bbox.min[0] + (i+1) * w, parent.bbox.max[1] + j * h, parent.bbox.max[2] ];
	
	var size = this.config.tesselation;
	var halfTesselation = (size-1)/2;
	for (var n = 0; n <= halfTesselation; n++)
	{
		var offset = this.config.vertexSize * ( (n+j*halfTesselation)*size + i*halfTesselation );
		for (var k = 0; k <= halfTesselation; k++)
		{
			this.bbox.extend( parent.vertices[offset], parent.vertices[offset+1], parent.vertices[offset+2] );
			offset += this.config.vertexSize;
		}
	}
	
	// Compute the bounding box
	this.radius = this.bbox.getRadius();
	
	// Init extension
	for ( var x in parent.extension ) 
	{
		var e = parent.extension[x];
		if ( e.initChild )
		{
			e.initChild(this,i,j);
		}
	}

}

/**************************************************************************************************************/

/**
 *	Test if the tile needs to be refined
 */
Tile.prototype.needsToBeRefined = function(renderContext)
{
	if ( this.distance < this.radius )
		return true;

	// Approximate the radius of one texel : the radius of the tile divided by the image size
	// The radius is taken as the average of the bbox width and length, rather than the actual radius because at the pole, there is a large difference betwen width and length
	// and the radius (ie maximum width/length) is too pessimistic
	var radius = 0.25 * ( (this.bbox.max[0] - this.bbox.min[0]) + (this.bbox.max[1] - this.bbox.min[1]) )  / this.imageSize; 
	
	// Transform the closest point from the eye in world coordinates
	var mat = this.matrix;
	var c = this.closestPointToEye;
	var px = mat[0]*c[0] + mat[4]*c[1] + mat[8]*c[2] + mat[12];
	var py = mat[1]*c[0] + mat[5]*c[1] + mat[9]*c[2] + mat[13];
	var pz = mat[2]*c[0] + mat[6]*c[1] + mat[10]*c[2] + mat[14];
	
	// Compute the pixel size of the radius texel
	var pixelSizeVector = renderContext.pixelSizeVector;
	var pixelSize = radius / ( px * pixelSizeVector[0] + py * pixelSizeVector[1]
						+ pz * pixelSizeVector[2] + pixelSizeVector[3] );
	
	// Check if pixel radius of a texel is superior to the treshold
	// The pixel size can be negative when the closest point is close to the near plane, so take absolute value
	return Math.abs(pixelSize) > renderContext.tileErrorTreshold;
}

/**************************************************************************************************************/

/**
 *	Test if the tile is culled given the current view parameters
 */
Tile.prototype.isCulled = function(renderContext)
{	
	// Compute the eye in tile local space
	var mat = this.inverseMatrix;
	var c = renderContext.eyePosition;
	var ex = mat[0]*c[0] + mat[4]*c[1] + mat[8]*c[2] + mat[12];
	var ey = mat[1]*c[0] + mat[5]*c[1] + mat[9]*c[2] + mat[13];
	var ez = mat[2]*c[0] + mat[6]*c[1] + mat[10]*c[2] + mat[14];
			
	// If the eye is in the radius of the tile, consider the tile is not culled
	this.distance = Math.sqrt( ex * ex + ey * ey + ez * ez );
	if ( this.distance < this.radius )
	{
		this.distance = 0.0;
		return false;
	}
	else
	{
		var pt = this.closestPointToEye;
		
		// Compute closest point to eye with the bbox of the tile
		pt[0] = Math.min( Math.max( ex, this.bbox.min[0] ), this.bbox.max[0] );
		pt[1] = Math.min( Math.max( ey, this.bbox.min[1] ), this.bbox.max[1] );
		pt[2] = Math.min( Math.max( ez, this.bbox.min[2] ), this.bbox.max[2] );
		
		// Compute horizontal culling only if the eye is "behind" the tile
		// and the coordinate system is not a plane(no need to compute horizon culling on plane)
		if ( ez < 0.0 && !this.config.coordinateSystem.isFlat )
		{
			// Compute vertical at the closest point. The earth center is [0, 0, -radius] in tile local space.
			var vx = pt[0];
			var vy = pt[1];
			var vz = pt[2] + this.config.coordinateSystem.radius;
			var vl = Math.sqrt( vx * vx + vy * vy + vz * vz );
			vx /= vl; vy /= vl; vz /= vl;
			
			// Compute eye direction at the closest point (clampled on earth to avoid problem with mountains)
			// The position clamp to earth is Vertical * Radius + EarthCenter. The EarthCenter being 0,0,-radius a lot of simplification is done.
			var edx = ex - vx * this.config.coordinateSystem.radius;
			var edy = ey - vy * this.config.coordinateSystem.radius;
			var edz = ez - (vz - 1.0) * this.config.coordinateSystem.radius;
			
			// Compute dot product between eye direction and the vertical at the point
			var el = Math.sqrt( edx * edx + edy * edy  + edz * edz );
			var eDv = (edx * vx + edy * vy  + edz * vz) / el;
						
			eDv *= this.config.cullSign;
			
			if ( eDv < -0.05 )
			{
				return true;
			}
		}
		
		// Compute local frustum
		var localFrustum = renderContext.localFrustum;
		localFrustum.inverseTransform( renderContext.worldFrustum, this.matrix );
		
		// Check if the tile is inside the frustum
		return !localFrustum.containsBoundingBox(this.bbox);
	}
}

/**************************************************************************************************************/

/**
 *	Dispose the tile
 */
Tile.prototype.dispose = function(renderContext,tilePool)
{		
	// Dispose extension even if tile isn't loaded because it can be culled
	for ( var x in this.extension )
	{
		if ( this.extension[x].dispose )
			this.extension[x].dispose(renderContext,tilePool);
	}

	if ( this.state == Tile.State.LOADED  )
	{
		tilePool.disposeGLBuffer(this.vertexBuffer);
		if (this.texture) tilePool.disposeGLTexture(this.texture);
		
		this.vertexBuffer = null;
		this.texture = null;
		this.parent = null;
		
		this.state = Tile.State.NONE;
	}
}

/**************************************************************************************************************/

/**
 *	Delete the children
 */
Tile.prototype.deleteChildren = function(renderContext,tilePool)
{
	if ( this.children )
	{
		for (var i = 0; i < 4; i++)
		{
			// Recursively delete its children
			this.children[i].deleteChildren(renderContext,tilePool);
			// Dispose its ressources (WebGL)
			this.children[i].dispose(renderContext,tilePool);
		}
		
		// Cleanup the tile
		this.children = null;
	}
}

/**************************************************************************************************************/

/**
 *	Build skirt vertices
 */
Tile.prototype.buildSkirtVertices = function(center,srcOffset,srcStep,dstOffset)
{
	var vertices = this.vertices;
	var skirtHeight = this.radius * 0.05;
	
	var size = this.config.tesselation;
	for ( var i = 0; i < size; i++)
	{
/*		//Not optimized version of skirt computation
		var srcPos = [ vertices[srcOffset], vertices[srcOffset+1], vertices[srcOffset+2] ];
		var dir = vec3.subtract( srcPos, center, vec3.create() );
		vec3.normalize(dir);
		vec3.scale( dir, skirtHeight );
		vec3.subtract( srcPos, dir );*/
		
		// Optimized version of skirt computation
		var x = vertices[srcOffset] - center[0];
		var y = vertices[srcOffset+1] - center[1];
		var z = vertices[srcOffset+2] - center[2];
		var scale = skirtHeight / Math.sqrt( x*x + y*y + z*z );
		x *= scale;
		y *= scale;
		z *= scale;
		
		vertices[ dstOffset ] = vertices[srcOffset] - x;
		vertices[ dstOffset+1 ] = vertices[srcOffset+1] - y;
		vertices[ dstOffset+2 ] = vertices[srcOffset+2] - z;
		
		for (var n = 3; n < this.config.vertexSize; n++)
		{
			vertices[ dstOffset+n ] = vertices[srcOffset+n];
		}
		
		dstOffset += this.config.vertexSize;
		srcOffset += srcStep;
	}	
}

/**************************************************************************************************************/

/**
 *	Generate normals for a tile
 */
Tile.prototype.generateNormals = function()
{	
	var size = this.config.tesselation;
	var vertexSize = this.config.vertexSize;
	var lineSize = vertexSize*size;
	
	var vo = 0;
	for ( var j=0; j < size; j++ )
	{
		var vp1 = j == size-1 ? 0 : lineSize;
		var vm1 = j == 0 ? 0 : -lineSize;
		for ( var i=0; i < size; i++ )
		{
			var up1 = i == size-1 ? 0 : vertexSize;
			var um1 = i == 0 ? 0 : -vertexSize;
			var u = [
				this.vertices[vo+up1] - this.vertices[vo+um1],
				this.vertices[vo+up1+1] - this.vertices[vo+um1+1],
				this.vertices[vo+up1+2] - this.vertices[vo+um1+2],
			];
			var v = [
				this.vertices[vo+vp1] - this.vertices[vo+vm1],
				this.vertices[vo+vp1+1] - this.vertices[vo+vm1+1],
				this.vertices[vo+vp1+2] - this.vertices[vo+vm1+2],
			];
			
			var normal = vec3.cross( u, v, [] );
			vec3.normalize(normal);
			this.vertices[vo+3] = normal[0];
			this.vertices[vo+4] = normal[1];
			this.vertices[vo+5] = normal[2];
			
			vo += vertexSize;
		}
	}
}

/**************************************************************************************************************/

/**
 *	Generate the tile
 */
Tile.prototype.generate = function(tilePool,image,elevations)
{
	// Generate the vertices
	this.vertices = this.generateVertices(elevations);
		
	// Compute the bounding box
	var size = this.config.tesselation;
	var vertexSize = this.config.vertexSize;
	this.bbox.compute(this.vertices,vertexSize*size*size,vertexSize);
	this.radius = this.bbox.getRadius();
	
	// Compute normals if needed
	if (this.config.normals)
	{
		this.generateNormals();
	}
		
	// Compute skirt from vertices
	if (this.config.skirt)
	{
		// Compute local earth center, used to generate skirts
		var localEarthCenter = [ 0.0, 0.0, 0.0 ];
		mat4.multiplyVec3( this.inverseMatrix, localEarthCenter );
		
		// Skirts
		var dstOffset = vertexSize * (size * size); // TOP
		this.buildSkirtVertices( localEarthCenter, 0, vertexSize, dstOffset );
		dstOffset += vertexSize * size; // BOTTOM
		this.buildSkirtVertices( localEarthCenter, vertexSize * (size * (size-1)), vertexSize, dstOffset );
		dstOffset += vertexSize * size; // LEFT
		this.buildSkirtVertices( localEarthCenter, 0, vertexSize * size, dstOffset );
		dstOffset += vertexSize * size; // RIGHT
		this.buildSkirtVertices( localEarthCenter, vertexSize * (size-1), vertexSize * size, dstOffset );
		
		// These skirts are only used by children tile
		dstOffset += vertexSize * size; // CENTER
		this.buildSkirtVertices( localEarthCenter, vertexSize * ( size * (size-1)/2 ), vertexSize, dstOffset );
		dstOffset += vertexSize * size; // MIDDLE
		this.buildSkirtVertices( localEarthCenter, vertexSize * ( (size-1)/2 ), vertexSize * size, dstOffset );
	}	
	
	// Avoid double creation of vertex buffer for level0Tiles generation
	if (this.vertexBuffer != null && this.parent == null)
	{
		tilePool.disposeGLBuffer(this.vertexBuffer);
	}
	this.vertexBuffer = tilePool.createGLBuffer(this.vertices);

	// Create texture
	if (image)
	{
		this.texture = tilePool.createGLTexture(image);
		this.imageSize = this.config.imageSize;
	}
	
	this.state = Tile.State.LOADED;
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
 
 
 
 var Utils = {};
 
 /** 
  * Inherits from an object
  */
Utils.inherits = function(base, sub) 
{
	function tempCtor() {}
	tempCtor.prototype = base.prototype;
	sub.prototype = new tempCtor();
	sub.prototype.constructor = sub;
};
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 
 
/**************************************************************************************************************/

/** @constructor
	@export
	GeoBound constructor
 */
var GeoBound = function( w, s, e, n )
{
	this.south = s;
	this.west = w;
	this.north = n;
	this.east = e;
}

/**************************************************************************************************************/

/**
	Get geo center
 */
GeoBound.prototype.getCenter = function()
{
	return [ (this.east+this.west)*0.5, (this.south+this.north)*0.5, 0.0 ];
}

/**************************************************************************************************************/

/**	@export
	Get north
 */
GeoBound.prototype.getNorth = function()
{
	return this.north;
}

/**************************************************************************************************************/

/**	@export
	Get south
 */
GeoBound.prototype.getSouth = function()
{
	return this.south;
}

/**************************************************************************************************************/

/**	@export
	Get west
 */
GeoBound.prototype.getWest = function()
{
	return this.west;
}

/**************************************************************************************************************/

/**	@export
	Get east
 */
GeoBound.prototype.getEast = function()
{
	return this.east;
}

/**************************************************************************************************************/

/**
	Compute the geo bound from coordinates
 */
GeoBound.prototype.computeFromCoordinates = function( coordinates )
{
	this.west = coordinates[0][0];
	this.east = coordinates[0][0];
	this.south = coordinates[0][1];
	this.north = coordinates[0][1];
	
	for ( var i = 1; i < coordinates.length; i++ )
	{
		this.west = Math.min( this.west, coordinates[i][0] );
		this.east = Math.max( this.east, coordinates[i][0] );
		this.south = Math.min( this.south, coordinates[i][1] );
		this.north = Math.max( this.north, coordinates[i][1] );
	}
}

/**************************************************************************************************************/

/**
	Intersects this geo bound with another one
 */
GeoBound.prototype.intersects = function( geoBound )
{
	if ( this.west >= geoBound.east || this.east <= geoBound.west )
		return false;
		
	if ( this.south >= geoBound.north || this.north <= geoBound.south )
		return false;
		
	return true;
}

/**************************************************************************************************************/

/**
 	Intersects this geo bound with GeoJSON geometry
 */
GeoBound.prototype.intersectsGeometry = function( geometry )
{
	var isIntersected = false;
	var geoBound = new GeoBound();
	var coords = geometry['coordinates'];
	switch (geometry['type'])
	{
		case "LineString":
			geoBound.computeFromCoordinates( coords );
			isIntersected |= this.intersects(geoBound);
			break;
		case "Polygon":
			// Don't take care about holes
			for ( var i = 0; i < coords.length && !isIntersected; i++ )
			{
				geoBound.computeFromCoordinates( coords[i] );
				isIntersected |= this.intersects(geoBound);
			}
			break;
		case "MultiLineString":
			for ( var i = 0; i < coords.length && !isIntersected; i++ )
			{
				geoBound.computeFromCoordinates( coords[i] );
				isIntersected |= this.intersects(geoBound);
			}
			break;
		case "MultiPolygon":
			for ( var i = 0; i < coords.length && !isIntersected; i++ )
			{
				for ( var j = 0; j < coords[i].length && !isIntersected; j++ )
				{
					geoBound.computeFromCoordinates( coords[i][j] );
					isIntersected |= this.intersects(geoBound);
				}
			}
			break;
	}
	return isIntersected;
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 
 
/**************************************************************************************************************/

/** @constructor
	GeoTiling constructor
 */
var GeoTiling = function(nx,ny)
{
	this.level0NumTilesX = nx;
	this.level0NumTilesY = ny;
}

/**************************************************************************************************************/

/** 
	Generate the tiles for level zero
 */
GeoTiling.prototype.generateLevelZeroTiles = function(config)
{	
	config.skirt = 1;
	config.cullSign = 1;
	config.srs = 'EPSG:4326';

	var level0Tiles = [];
	
	var latStep = 180 / this.level0NumTilesY;
	var lonStep = 360 / this.level0NumTilesX;
	
	for (var j = 0; j < this.level0NumTilesY; j++)
	{
		for (var i = 0; i < this.level0NumTilesX; i++)
		{
			var geoBound = new GeoBound( -180 + i * lonStep, 90 - (j+1) * latStep, -180 + (i+1) * lonStep, 90 - j * latStep  );
			var tile = new GeoTile(geoBound, 0, i, j)
			tile.config = config;
			level0Tiles.push( tile );
		}
	}

	return level0Tiles;
}


/**
 * Compute the bbox of a feature
 */
var _getBBox = function(geometry) {

	// Get the coordinates
	var coords;
	var checkDateLine = true;
	switch (geometry.type) {
		case "Point":
			coords = geometry.coordinates;
			return [ coords[0], coords[1], coords[0], coords[1] ];
		case "MultiPoint":
			coords = geometry.coordinates;
			checkDateLine = false;
			break;
		case "Polygon":
			coords = geometry.coordinates[0];
			break;
		case "MultiPolygon":
			coords = geometry.coordinates[0][0];
			break;
		case "LineString":
			coords = geometry.coordinates;
			break;
		case "MultiLineString":
			coords = geometry.coordinates[0];
			break;
	}
	
	if (!coords || coords.length == 0)
		return;

	var minX = coords[0][0];
	var minY = coords[0][1];
	var maxX =  coords[0][0];
	var maxY =  coords[0][1];
	
	var numOuterRings = (geometry.type == "MultiPolygon" || geometry.type == "MultiLineString" ? geometry.coordinates.length : 1);
	for ( var j = 0; j < numOuterRings; j++ ) {
		switch (geometry.type) {
			case "MultiPolygon":
				coords = geometry.coordinates[j][0];
				break;
			case "MultiLineString":
				coords = geometry.coordinates[j];
				break;
		}

		for ( var i = 0;  i < coords.length; i++ )	{
			minX = Math.min( minX, coords[i][0] );	
			minY = Math.min( minY, coords[i][1] );	
			maxX = Math.max( maxX, coords[i][0] );	
			maxY = Math.max( maxY, coords[i][1] );	
			
			// Check if the coordinates cross dateline
			if ( checkDateLine && i > 0 && Math.abs(coords[i-1][0] - coords[i][0]) > 180 ) {
				minX = -180;
				maxX = 180;
			}
		}
	}
	
	return [ minX, minY, maxX, maxY ];
};

/**************************************************************************************************************/

/** 
	Locate a level zero tile
 */
GeoTiling.prototype._lon2LevelZeroIndex = function(lon)
{	
    var levelZeroIndex = Math.floor( (lon + 180) * this.level0NumTilesX / 360 );

    // Clamp between 0 and level0NumTilesX (can occure when lon isn't normalized)
    if ( levelZeroIndex > this.level0NumTilesX-1 )
        return this.level0NumTilesX-1;
    if ( levelZeroIndex < 0 )
        return 0;

    return levelZeroIndex;
}

/**************************************************************************************************************/

/** 
	Locate a level zero tile
 */
GeoTiling.prototype._lat2LevelZeroIndex = function(lat)
{	
	return Math.min(  this.level0NumTilesY-1, Math.floor( (90 - lat) * this.level0NumTilesY / 180 ) );
}
/**************************************************************************************************************/

/** 
	Locate a level zero tile
 */
GeoTiling.prototype.lonlat2LevelZeroIndex = function(lon,lat)
{	
	return this._lat2LevelZeroIndex(lat) * this.level0NumTilesX + this._lon2LevelZeroIndex(lon);
}


/**************************************************************************************************************/

/** 
	Get the overlapped tile by the given geometry
 */
GeoTiling.prototype.getOverlappedLevelZeroTiles = function(geometry)
{
	var tileIndices = [];
	
	var bbox = _getBBox(geometry);
	if (bbox)
	{
		var i1 = this._lon2LevelZeroIndex(bbox[0]);
		var j1 = this._lat2LevelZeroIndex(bbox[3]);
		var i2 = this._lon2LevelZeroIndex(bbox[2]);
		var j2 = this._lat2LevelZeroIndex(bbox[1]);
		
		
		for ( var j = j1; j <= j2; j++ ) {
			for ( var i = i1; i <= i2; i++ ) {
				tileIndices.push( j * this.level0NumTilesX + i );
			}
		}
	}

	return tileIndices;
}

/**************************************************************************************************************/

/** @constructor
	Tile constructor
 */
var GeoTile = function( geoBound, level, x, y )
{
    // Call ancestor constructor
    Tile.prototype.constructor.call(this);
	
	this.bound = this.geoBound = geoBound;
	this.level = level;
	this.x = x;
	this.y = y;
}

/**************************************************************************************************************/

/** inherits from Tile */
GeoTile.prototype = new Tile;

/**************************************************************************************************************/

/** @export
  Get elevation at a geo position
*/
GeoTile.prototype.getElevation = function(lon,lat)
{
	// Get the lon/lat in coordinates between [0,1] in the tile
	var u = (lon - this.geoBound.west) / (this.geoBound.east - this.geoBound.west);
 	var v = (lat - this.geoBound.north) / (this.geoBound.south - this.geoBound.north);

	// Quick fix when lat is on the border of the tile
	var childIndex = (v >= 1 ? 1 : Math.floor(2*v) )*2 + Math.floor(2*u);
	if ( this.children && this.children[childIndex].state == Tile.State.LOADED )
		return this.children[childIndex].getElevation(lon,lat);
	
	var tess = this.config.tesselation;
	var i = Math.floor( u * tess );
	var j = Math.floor( v * tess );
	
	var vo = this.config.vertexSize * (j * tess + i);
	var vertex = [ this.vertices[vo], this.vertices[vo+1], this.vertices[vo+2] ];
	mat4.multiplyVec3( this.matrix, vertex );
	var geo = this.config.coordinateSystem.from3DToGeo(vertex);
	return geo[2];
}

/**************************************************************************************************************/

/**
	Create the children
 */
GeoTile.prototype.createChildren = function()
{
	// Create the children
	var lonCenter = ( this.geoBound.east + this.geoBound.west ) * 0.5;
	var latCenter = ( this.geoBound.north + this.geoBound.south ) * 0.5;
	
	var level = this.level+1;
	
	var tile00 = new GeoTile( new GeoBound( this.geoBound.west, latCenter, lonCenter, this.geoBound.north), level, 2*this.x, 2*this.y );
	var tile10 = new GeoTile( new GeoBound( lonCenter, latCenter,  this.geoBound.east, this.geoBound.north), level, 2*this.x+1, 2*this.y );
	var tile01 = new GeoTile( new GeoBound( this.geoBound.west, this.geoBound.south, lonCenter, latCenter), level, 2*this.x, 2*this.y+1 );
	var tile11 = new GeoTile( new GeoBound( lonCenter, this.geoBound.south, this.geoBound.east, latCenter), level, 2*this.x+1, 2*this.y+1  );
	
	tile00.initFromParent( this, 0, 0 );
	tile10.initFromParent( this, 1, 0 );
	tile01.initFromParent( this, 0, 1 );
	tile11.initFromParent( this, 1, 1 );
	
	this.children = [ tile00, tile10, tile01, tile11 ];	
}

/**************************************************************************************************************/

/**
	Convert coordinates in longitude,latitude to coordinate in "tile space"
	Tile space means coordinates are between [0,tesselation-1] if inside the tile
	Used by renderers algorithm to clamp coordinates on the tile
 */
GeoTile.prototype.lonlat2tile = function(coordinates)
{
	var ul = this.geoBound.east - this.geoBound.west;
	var vl = this.geoBound.south - this.geoBound.north;
	var factor = this.config.tesselation-1;
	
	var tileCoords = [];
	for ( var i = 0; i < coordinates.length; i++ )
	{
		var u = factor * (coordinates[i][0] - this.geoBound.west) / ul;
		var v = factor * (coordinates[i][1] - this.geoBound.north) / vl;
		tileCoords.push( [ u, v ] );	
	}
	
	return tileCoords;
}

/**************************************************************************************************************/

/**
	Generate vertices for tile
 */
GeoTile.prototype.generateVertices = function(elevations)
{	
	// Compute tile matrix
	this.matrix = this.config.coordinateSystem.getLHVTransform( this.geoBound.getCenter() );
	var invMatrix = mat4.create();
	mat4.inverse( this.matrix, invMatrix );
	this.inverseMatrix = invMatrix;
	
	// Build the vertices
	var vertexSize = this.config.vertexSize;
	var size = this.config.tesselation;
	var vertices = new Float32Array( vertexSize*size*(size+6) );
	var lonStep = (this.geoBound.east - this.geoBound.west) / (size-1);
	var latStep = (this.geoBound.south - this.geoBound.north) / (size-1);
	var radius = this.config.coordinateSystem.radius;
	var scale = this.config.coordinateSystem.heightScale;
	var offset = 0;
	
	// Optimized build for sphere coordinates : uncomment if needed
	var lat = this.geoBound.north /* * Math.PI / 180.0*/;
	// latStep = latStep * Math.PI / 180.0;
	// lonStep = lonStep * Math.PI / 180.0;
	var pos3d = [ 0.0, 0.0, 0.0 ];
	for ( var j=0; j < size; j++)
	{
		//var cosLat = Math.cos( lat );
		//var sinLat = Math.sin( lat );
		
		var lon = this.geoBound.west /* * Math.PI / 180.0*/;
				
		for ( var i=0; i < size; i++)
		{
			// var height = elevations ? scale * elevations[ offset ] : 0.0;
			// var x = (radius + height) * Math.cos( lon ) * cosLat;
			// var y = (radius + height) * Math.sin( lon ) * cosLat;
			// var z = (radius + height) * sinLat;

			var height = elevations ? elevations[ offset ] : 0.0;
			this.config.coordinateSystem.fromGeoTo3D( [lon, lat, height], pos3d );
			var x = pos3d[0];
			var y = pos3d[1];
			var z = pos3d[2];

			var vi = offset * vertexSize;
			vertices[vi] = invMatrix[0]*x + invMatrix[4]*y + invMatrix[8]*z + invMatrix[12];
			vertices[vi+1] = invMatrix[1]*x + invMatrix[5]*y + invMatrix[9]*z + invMatrix[13];
			vertices[vi+2] = invMatrix[2]*x + invMatrix[6]*y + invMatrix[10]*z + invMatrix[14];
						
			offset++;
			lon += lonStep;
		}
		
		lat += latStep;
	}
	
	return vertices;
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 

/**************************************************************************************************************/

/** 
	@constructor
	TilePool constructor
 */
var TilePool = function(rc)
{
	// Private properties
	var gl = rc.gl;
	var glTexturePools = {};
	var glBuffers = [];
	var self = this;

	// Choose floating point texture filtering depending on extension support
	var float_linear_ext = gl.getExtension("OES_texture_float_linear");
	var float_filtering = float_linear_ext ? gl.LINEAR : gl.NEAREST;
	
	// Public properties
	this.numCreatedTextures = 0;
	this.numReusedTextures = 0;
	
	// Private methods

	/**************************************************************************************************************/

	/**
		Create a new GL texture
	 */
	var createNewGLTexture = function(image,texturePool)
	{
		var glTexture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, glTexture);
		if ( image.dataType == "byte" )
		{
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.generateMipmap(gl.TEXTURE_2D);
		}
		else
		{
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, image.width, image.height, 0, gl.LUMINANCE, gl.FLOAT, image.typedArray);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, float_filtering);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, float_filtering);
		}

		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		glTexture.pool = texturePool;
		self.numCreatedTextures++;
		
		return glTexture;
	}

	/**************************************************************************************************************/

	/**
		Reuse a GL texture
	 */
	var reuseGLTexture = function(image,texturePool)
	{
		var glTexture = texturePool.pop();
		gl.bindTexture(gl.TEXTURE_2D, glTexture);

		if ( image.dataType == "byte" )
		{
			//gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, image);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
			gl.generateMipmap(gl.TEXTURE_2D);
		}
		else
		{
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, image.width, image.height, 0, gl.LUMINANCE, gl.FLOAT, image.typedArray);
		}

		self.numReusedTextures++;
		
		return glTexture;
	};
	
	/**
	 * Get or create a texture pool for the given image
	 */
	var getOrCreateTexturePool = function(image) 
	{
		var key = image.dataType + image.width;
		if (!glTexturePools[key])
		{
			glTexturePools[key] = [];
		}
		return glTexturePools[key];
	};
		
	// Public methods
	
	/**************************************************************************************************************/

	/**
		Create a GL texture to be used by a tile
	 */
	this.createGLTexture = function(image)
	{
		var texturePool = getOrCreateTexturePool(image);

		if ( texturePool.length > 0 )
		{
			return reuseGLTexture(image,texturePool);
		}
		else
		{
			return createNewGLTexture(image,texturePool);
		}
	};

	/**************************************************************************************************************/

	/**
		Create a GL texture to be used by a tile
	 */
	this.createGLBuffer = function(vertices)
	{
		var vb;
		if ( glBuffers.length > 0 )
		{
			vb = glBuffers.pop();
		}
		else
		{
			vb = gl.createBuffer();
		}
		gl.bindBuffer(gl.ARRAY_BUFFER, vb);
		gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
		
		return vb;
	};

	/**************************************************************************************************************/

	/**
		Dispose a texture
	 */
	this.disposeGLTexture = function(texture)
	{
		texture.pool.push(texture);
	}

	/**************************************************************************************************************/

	/**
		Dispose a texture
	 */
	this.disposeGLBuffer = function(buffer)
	{
		glBuffers.push(buffer);
	}

	/**************************************************************************************************************/

	/**
		Dispose all
	 */
	this.disposeAll = function()
	{
		for ( var key in glTexturePools )
		{
			if ( glTexturePools.hasOwnProperty(key) )
			{
				var glTextures = glTexturePools[key];
				for ( var i = 0;  i < glTextures.length; i++ ) 
				{
					gl.deleteTexture( glTextures[i] );
				}
			}
		}
		glTexturePools = {};
		
		for ( var i = 0;  i < glBuffers.length; i++ )
		{
			gl.deleteBuffer( glBuffers[i] );
		}
		glBuffers.length = 0;
	}

	/**************************************************************************************************************/	
};
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/



/** 
 *	@constructor
 *	ImageRequest constructor
 */
var ImageRequest = function(options)
{
	this.successCallback = options.successCallback;
	this.failCallback = options.failCallback;
	this.abortCallback = options.abortCallback;
	this.image = null;
}

/**************************************************************************************************************/

/**
 *	Send image request
 */
ImageRequest.prototype.send = function(url,crossOrigin)
{
	this.image = new Image();
	this.image.crossOrigin = crossOrigin;
	this.image.dataType = "byte";

	var self = this;
	this.image.onload = function(){
		var isComplete = self.image.naturalWidth != 0 && self.image.complete;
		if ( isComplete )
		{
			self.successCallback.call(self);
		}
	} 
	this.image.onerror = this.failCallback.bind(this);
	this.image.src = url;
}

/**************************************************************************************************************/

/**
 *	Abort image request
 */
ImageRequest.prototype.abort = function()
{
	if ( this.abortCallback )
	{
		this.abortCallback(this);
	}
	this.image.src = '';
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 
 
/**************************************************************************************************************/

/** @constructor
	TileRequest constructor
 */
var TileRequest = function(tileManager)
{
	// Private variables
	var _imageLoaded = false;
	var _elevationLoaded = true;
	var _xhr = new XMLHttpRequest();
	var _imageRequest;

	// Public variables
	this.tile = null;
	this.elevations = null;
	this.image = null;

	var self = this;
	
	// Setup the XHR callback
	_xhr.onreadystatechange = function(e)
	{
		if ( _xhr.readyState == 4 )
		{
			if ( _xhr.status == 200 )
			{
				_handleLoadedElevation();
			}
			else
			{
				_handleErrorElevation();
			}
		}
	};
	

	/**************************************************************************************************************/

	/**
		Handle when image is loaded
	 */
	var _handleLoadedImage = function() 
	{
		// The method can be called twice when the image is in the cache (see launch())
		if (!_imageLoaded)
		{
			_imageLoaded = true;
			if ( _elevationLoaded )
			{
				// Call post-process function if defined
				if ( tileManager.imageryProvider && tileManager.imageryProvider.handleImage )
					tileManager.imageryProvider.handleImage(_imageRequest);

				tileManager.pendingRequests.splice(tileManager.pendingRequests.indexOf(self), 1);
				tileManager.completedRequests.push(self);
				tileManager.renderContext.requestFrame();
			}
			self.image = _imageRequest.image;
		}
	};

	/**************************************************************************************************************/

	/**
		Handle when loading image failed
	 */
	var _handleErrorImage = function() 
	{
		self.tile.state = Tile.State.ERROR;
		tileManager.pendingRequests.splice(tileManager.pendingRequests.indexOf(self), 1);
		tileManager.availableRequests.push(self);
	}

	/**************************************************************************************************************/

	/**
		Abort request
	 */
	var _handleAbort = function() 
	{
		self.tile.state = Tile.State.NONE;
		tileManager.pendingRequests.splice(tileManager.pendingRequests.indexOf(self), 1);
		tileManager.availableRequests.push(self);
	}

	/**************************************************************************************************************/

	/**
		Handle when elevation is loaded
	 */
	var _handleLoadedElevation = function() 
	{
		self.elevations = tileManager.elevationProvider.parseElevations(_xhr.responseText);	
		_elevationLoaded = true;
		
		if ( _imageLoaded )
		{
			tileManager.pendingRequests.splice(tileManager.pendingRequests.indexOf(self), 1);
			tileManager.completedRequests.push(self);
			tileManager.renderContext.requestFrame();
		}
	}

	/**************************************************************************************************************/

	/**
		Handle when loading elevation failed
	 */
	var _handleErrorElevation = function() 
	{
		self.elevations = null;
		_elevationLoaded = true;
		
		if ( _imageLoaded )
		{
			tileManager.pendingRequests.splice(tileManager.pendingRequests.indexOf(self), 1);
			tileManager.completedRequests.push(self);
			tileManager.renderContext.requestFrame();
		}
	}

	/**************************************************************************************************************/

	/**
		Launch the HTTP request for a tile
	 */
	this.launch = function(tile)
	{
		tile.state = Tile.State.LOADING;
		this.tile = tile;
		tileManager.pendingRequests.push(this);
		
		this.image = null;
		this.elevations = null;
		
		// Request the elevation if needed
		if ( tileManager.elevationProvider )
		{
			// TODO : handle the elevations coming from cache
			_elevationLoaded = false;
			_xhr.open("GET", tileManager.elevationProvider.getUrl(tile) );

            // Set withCredentials property after "open": http://stackoverflow.com/questions/19666809/cors-withcredentials-support-limited?answertab=votes#tab-top
            var useCredentials = tileManager.elevationProvider.crossOrigin != 'anonymous';
            _xhr.withCredentials = useCredentials;

			_xhr.send();
		}
		else
		{
			_elevationLoaded = true;
		}
		
		if ( tileManager.imageryProvider )
		{
			if (!_imageRequest)
			{
				_imageRequest = new ImageRequest({
					successCallback: function() {
						_handleLoadedImage();
						if ( tileManager.imageryProvider.cache )
						{
							tileManager.imageryProvider.cache.storeInCache( self );
						}
					},
					failCallback: _handleErrorImage,
					abortCallback: _handleAbort
				});
			}
			
			// Check if the image isn't already loaded in cache
			var cachedTileRequest;
			if ( tileManager.imageryProvider.cache )
			{
				cachedTileRequest = cachedTileRequest = tileManager.imageryProvider.cache.getFromCache(tile);
			}
			
			_imageLoaded = false;
			if ( cachedTileRequest )
			{
				_imageRequest.image = cachedTileRequest.image;
				_handleLoadedImage();
			}
			else
			{
				// Tile not found in cache or cache isn't activated, send the request
				_imageRequest.send( tileManager.imageryProvider.getUrl(tile), tileManager.imageryProvider.crossOrigin );
			}

		}
		else
		{
			_imageLoaded = true;
		}
		
		// Check if there is nothing to load
		if ( !tileManager.imageryProvider && !tileManager.elevationProvider )
		{
			tileManager.pendingRequests.splice(tileManager.pendingRequests.indexOf(this), 1);
			tileManager.completedRequests.push(this);
		}
	};

	/**************************************************************************************************************/

	/**
	 *	Abort launched request
	 */
	this.abort = function() {
		if (_imageRequest) {
			_imageRequest.abort();
		}
	}
	
};

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 
 
/**************************************************************************************************************/

/** 
	@constructor TileIndexBuffer
	TileIndexBuffer
 */
var TileIndexBuffer = function( renderContext, config )
{
	this.renderContext = renderContext;
	this.config = config;
	this.solidIndexBuffer = null;
	this.subSolidIndexBuffer = [ null, null, null, null ];
	this.subIndices = [ null, null, null, null ];
}

/**************************************************************************************************************/

/**  
 * Reset the index buffers.
 */
TileIndexBuffer.prototype.reset = function()
{	
	var gl = this.renderContext.gl;
	for ( var i=0; i < 4; i++ )
	{
		if ( this.subSolidIndexBuffer[i] )
		{
			gl.deleteBuffer( this.subSolidIndexBuffer[i] );
			this.subSolidIndexBuffer[i] = null;
		}
	}
	if ( this.solidIndexBuffer )
	{
		gl.deleteBuffer( this.solidIndexBuffer );
		this.solidIndexBuffer = null;
	}
}

/**************************************************************************************************************/

/**
 *	Get index buffer for sub solid
 */
TileIndexBuffer.prototype.getSubSolid = function(ii)
{
	if ( this.subSolidIndexBuffer[ii] == null )
	{
		var i = ii % 2;
		var j = Math.floor( ii / 2 );
		
		var size = this.config.tesselation;
		var halfTesselation = (size-1) / 2;
		
		// Build the sub grid for 'inside' tile
		var indices = [];
		for ( var n=halfTesselation*j; n < halfTesselation*(j+1); n++)
		{
			for ( var k=halfTesselation*i; k < halfTesselation*(i+1); k++)
			{
				indices.push( n * size + k );
				indices.push( (n+1) * size + k );
				indices.push( n * size + k + 1 );
				
				indices.push( n * size + k + 1 );
				indices.push( (n+1) * size + k );
				indices.push( (n+1) * size + k + 1 );
			}
		}
		
		this.subIndices[ii] = indices;

		if (this.config.skirt)
		{
			// Build skirts
			// Top skirt
			var start = (j == 0) ? size * size : size * size + 4 * size;
			var src = (j == 0) ? 0 : halfTesselation * size;
			for ( var n = halfTesselation*i; n < halfTesselation*(i+1); n++)
			{
				indices.push( start + n );
				indices.push( src + n );
				indices.push( start + n + 1 );
				
				indices.push( start + n + 1 );
				indices.push( src + n );
				indices.push( src + n + 1 );
			}
		
			// Bottom skirt
			start = (j == 0) ? size * size + 4 * size : size * size + size;
			src = (j == 0) ? halfTesselation * size : (size-1) * size;
			for ( var n = halfTesselation*i; n < halfTesselation*(i+1); n++)
			{
				indices.push( src + n );
				indices.push( start + n );
				indices.push( src + n + 1 );
				
				indices.push( src + n + 1 );
				indices.push( start + n );
				indices.push( start + n + 1 );
			}
				
			// Left skirt
			start = (i == 0) ? size * size + 2 * size : size * size + 5 * size;
			src = (i == 0) ? 0 : halfTesselation;
			for ( var k=halfTesselation*j; k < halfTesselation*(j+1); k++)
			{
				indices.push( start + k );
				indices.push( start + k + 1 );
				indices.push( src + k * size );
				
				indices.push( src + k * size );
				indices.push( start + k + 1);
				indices.push( src + (k+1) * size );
			}
			
			// Right skirt
			start = (i == 0) ? size * size + 5 * size : size * size + 3 * size;
			src = (i == 0) ? halfTesselation : size - 1;
			for ( var k=halfTesselation*j; k < halfTesselation*(j+1); k++)
			{
				indices.push( k * size + src );
				indices.push( (k+1) * size + src );
				indices.push( start + k );
				
				indices.push( start + k );
				indices.push( (k+1) * size + src );
				indices.push( start + k + 1 );
			}
		}
		
		var gl = this.renderContext.gl;
		var ib = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
		ib.numIndices = indices.length;
		this.subSolidIndexBuffer[ii] = ib;
	}
	
	return this.subSolidIndexBuffer[ii];
}

/**************************************************************************************************************/

/*
	Build index buffer
 */
TileIndexBuffer.prototype.getSolid = function()
{
	if ( this.solidIndexBuffer == null )
	{
		var size = this.config.tesselation;
		var indices = [];
		// Build the grid
		for ( var j=0; j < size-1; j++)
		{
			for ( var i=0; i < size-1; i++)
			{
				indices.push( j * size + i );
				indices.push( (j+1) * size + i );
				indices.push( j * size + i + 1 );
				
				indices.push( j * size + i + 1 );
				indices.push( (j+1) * size + i );
				indices.push( (j+1) * size + i + 1 );
			}
		}
		
		if (this.config.skirt)
		{
			// Top skirt
			var start = size * size;
			for ( var i = 0; i < size-1; i++)
			{
				indices.push( start + i );
				indices.push( i );
				indices.push( start + i + 1 );
				
				indices.push( start + i + 1 );
				indices.push( i );
				indices.push( i + 1 );
			}
			
			// Bottom skirt
			start += size;
			for ( var i=0; i < size-1; i++)
			{
				indices.push( (size-1) * size + i );
				indices.push( start + i );
				indices.push( (size-1) * size + i + 1 );
				
				indices.push( (size-1) * size + i + 1 );
				indices.push( start + i );
				indices.push( start + i + 1 );
			}
				
			// Left skirt
			start += size;
			for ( var j=0; j < size-1; j++)
			{
				indices.push( start + j );
				indices.push( start + j + 1 );
				indices.push( j * size );
				
				indices.push( j * size );
				indices.push( start + j + 1);
				indices.push( (j+1) * size );
			}

			// Right skirt
			start += size;
			for ( var j=0; j < size-1; j++)
			{
				indices.push( j * size + size - 1 );
				indices.push( (j+1) * size + size - 1 );
				indices.push( start + j );
				
				indices.push( start + j );
				indices.push( (j+1) * size + size - 1 );
				indices.push( start + j + 1 );
			}
		}
		
		var gl = this.renderContext.gl;
		var ib = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
		this.numIndices = indices.length;
		
		this.solidIndexBuffer = ib;
		this.solidIndexBuffer.numIndices = indices.length;
	}
	
	return this.solidIndexBuffer;
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 

/**************************************************************************************************************/

/** @constructor
	Program constructor
 */
var Program = function(renderContext)
{
	this.renderContext = renderContext;
    this.glProgram = null;
    this.attributes = {};
    this.uniforms = {};
	this.numActiveAttribArray = 0;
}

/**************************************************************************************************************/

/**
  Creates a shader of the given type from the given source string
*/
Program.prototype.createShader = function(type, source)
{
	var gl = this.renderContext.gl;
    var shader = gl.createShader(type);
    gl.shaderSource(shader, source);
	gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    {
		console.log("Shader compilation error: " + gl.getShaderInfoLog(shader));
		console.log(source);
		gl.deleteShader(shader);
        return null;
    }

    return shader;
}

/**************************************************************************************************************/

/**
	Create the program from source shaders
 */
Program.prototype.createFromSource = function(vertexSource, fragmentSource)
{
	var gl = this.renderContext.gl;
	
    //  Create the gl shaders from the source
    var vertexShader = this.createShader(gl.VERTEX_SHADER, vertexSource);
    var fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragmentSource);
    if (vertexShader == null || fragmentShader == null)
    {
		return false;
    }
	
	// Create the program and attach the shaderss
	this.glProgram = gl.createProgram();
	gl.attachShader(this.glProgram, vertexShader);
	gl.attachShader(this.glProgram, fragmentShader);

	// Link and test the program is ok
	gl.linkProgram(this.glProgram);
    if (!gl.getProgramParameter(this.glProgram, gl.LINK_STATUS)) 
    {
        console.log("Program link error: " + gl.getProgramInfoLog(this.glProgram));
		gl.deleteShader(vertexShader);
		gl.deleteShader(fragmentShader);
		gl.deleteProgram(this.glProgram);
		this.glProgram = null;
        return false;
    }

    // Get vertex attributes used in the program, stored them in an attributes object
    var attributeCount = gl.getProgramParameter(this.glProgram, gl.ACTIVE_ATTRIBUTES);
	this.numActiveAttribArray = 0;
    for (var i = 0; i < attributeCount; ++i)
    {
        var attribute = gl.getActiveAttrib(this.glProgram, i);
		var loc = gl.getAttribLocation(this.glProgram,attribute.name);
        this.attributes[attribute.name] = loc;
		
		if ( loc + 1 > this.numActiveAttribArray )
		{
			this.numActiveAttribArray = loc + 1;
		}
    }

    // Get uniforms used in the program, stored them in an uniforms object
    var uniformCount = gl.getProgramParameter(this.glProgram, gl.ACTIVE_UNIFORMS);
    for (var i = 0; i < uniformCount; ++i)
    {
        var uniform = gl.getActiveUniform(this.glProgram, i);
        this.uniforms[uniform.name] = gl.getUniformLocation(this.glProgram,uniform.name);
    }

    return true;
}

/**************************************************************************************************************/

/*
	Load from file (must be located on the server)
 */
Program.prototype.loadFromFile = function(vertexFile, fragmentFile)
{
    var xhr = new XMLHttpRequest;
	xhr.open("get", this.renderContext.shadersPath + vertexFile, false);
	xhr.send(null);
    var vertexSource = xhr.responseText;
	xhr.open("get", this.renderContext.shadersPath +  fragmentFile, false);
	xhr.send(null);
    var fragmentSource = xhr.responseText;
    
    return this.createFromSource(vertexSource, fragmentSource);
}

/**************************************************************************************************************/

/*
	Apply the programs
 */
Program.prototype.apply = function()
{
	var rc = this.renderContext;
	var gl =  rc.gl;
	
    // Bind program
	gl.useProgram(this.glProgram);
    
	for ( var i = rc.numActiveAttribArray;
		i < this.numActiveAttribArray; i++ )
	{
		gl.enableVertexAttribArray(i);
	}
	for ( var i = this.numActiveAttribArray;
		i < rc.numActiveAttribArray; i++ )
	{
		gl.disableVertexAttribArray(i);
	}
	rc.numActiveAttribArray = this.numActiveAttribArray;
}

/**************************************************************************************************************/

/**
	Dispose the program
 */
Program.prototype.dispose = function()
{
	this.renderContext.gl.deleteProgram(this.glProgram);
}

/**************************************************************************************************************/

/*
	Load shader using Http request
 */
// Program.prototype.loadShader = function (shader, type, callback) 
// {
//     function onreadystatechange() {
//         var xhr = this;
//         if (xhr.readyState == 4) {
//             shader =  gl.createShader(type);
//              gl.shaderSource(shader, xhr.responseText);
//              gl.compileShader(shader);
//             if (! gl.getShaderParameter(shader,  gl.COMPILE_STATUS))
//                 throw  gl.getShaderInfoLog(shader)
//             ;
//             !--length && typeof callback == "function" && callback(shader);
//         }
//     }
	
// 	var asynchronous = !!callback;
// 	xhr = new XMLHttpRequest;
// 	xhr.open("get", shader, asynchronous);
// 	if (asynchronous) 
// 	{
// 		xhr.onreadystatechange = onreadystatechange;
// 	}
// 	xhr.send(null);
// 	onreadystatechange.call(xhr);
		
//     return shader;
// }

/**************************************************************************************************************/


/*
	Get the shader using defined in HTML
 */
// Program.prototype.getShader = function(id)
//  {
// 	var shaderScript = document.getElementById(id);
// 	if (!shaderScript) {
// 		return null;
// 	}

// 	var str = "";
// 	var k = shaderScript.firstChild;
// 	while (k) {
// 		if (k.nodeType == 3) {
// 			str += k.textContent;
// 		}
// 		k = k.nextSibling;
// 	}

// 	var shader;
// 	if (shaderScript.type == "x-shader/x-fragment") {
// 		shader = RenderContext.gl.createShader(RenderContext.gl.FRAGMENT_SHADER);
// 	} else if (shaderScript.type == "x-shader/x-vertex") {
// 		shader = RenderContext.gl.createShader(RenderContext.gl.VERTEX_SHADER);
// 	} else {
// 		return null;
// 	}

// 	RenderContext.gl.shaderSource(shader, str);
// 	RenderContext.gl.compileShader(shader);

// 	if (!RenderContext.gl.getShaderParameter(shader, RenderContext.gl.COMPILE_STATUS)) {
// 		alert(RenderContext.gl.getShaderInfoLog(shader));
// 		return null;
// 	}

// 	return shader;
// }

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/



/** @constructor
	TileManager constructor
	
	Take in parameters its parent : can be a globe or a sky
 */
var TileManager = function( parent, options )
{
	this.parent = parent;
	this.renderContext = this.parent.renderContext;
	// Create a new tile pool or use the one from the parent
	this.tilePool = parent.tilePool || new TilePool(this.renderContext);
	this.tiling = new GeoTiling( 4, 2 ); // Use geo tiling by default

	this.imageryProvider = null;
	this.elevationProvider = null;
	this.tilesToRender = [];
	this.visibleTiles = [];
	this.tilesToRequest = [];
	this.postRenderers = [];

	// Init default texture
	var gl = this.renderContext.gl;
	this.defaultTexture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, this.defaultTexture);
	var defaultColor = options.defaultColor ? options.defaultColor : [200,200,200,255];
	var pixel = new Uint8Array(defaultColor);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, 
	              gl.RGBA, gl.UNSIGNED_BYTE, pixel);
	
	// Tile requests : limit to 4 at a given time
	this.maxRequests = 4;
	this.availableRequests = [];
	for ( var i=0; i < this.maxRequests; i++ )
	{
		this.availableRequests[i] = new TileRequest(this);
	}
	this.pendingRequests = [];
	this.completedRequests = [];
				
	this.level0TilesLoaded = false;
	
	// Configuration for tile
	this.tileConfig = {
		tesselation: 9,
		skirt: true,
		cullSign: 1.0,
		imageSize: 256,
		vertexSize: this.renderContext.lighting ? 6 : 3, 
		normals: this.renderContext.lighting,
		coordinateSystem: this.parent.coordinateSystem
	};
	this.level0Tiles = this.tiling.generateLevelZeroTiles(this.tileConfig,this.tilePool);
		
	// Shared index and texture coordinate buffer : all tiles uses the same
	this.tcoordBuffer = null;
	this.tileIndexBuffer = new TileIndexBuffer(this.renderContext,this.tileConfig);

	// HACK : to fix sky rendering
	this.renderTileWithoutTexture = options.hasOwnProperty('renderTileWithoutTexture') ? options.renderTileWithoutTexture : true;

	// For debug
	this.freeze = false;

	// Stats
	this.numTilesGenerated = 0;
	this.frameNumber = 0;

	this.vertexShader = "\
	attribute vec3 vertex;\n\
	attribute vec2 tcoord;\n\
	uniform mat4 modelViewMatrix;\n\
	uniform mat4 projectionMatrix;\n\
	varying vec2 texCoord;\n";
	if ( this.renderContext.lighting )
		this.vertexShader += "attribute vec3 normal;\nvarying vec3 color;\n";
	this.vertexShader += "\
	void main(void) \n\
	{\n\
		gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n";
	if ( this.renderContext.lighting )
		this.vertexShader += "vec4 vn = modelViewMatrix * vec4(normal,0);\ncolor = max( vec3(-vn[2],-vn[2],-vn[2]), 0.0 );\n";
	this.vertexShader += "\
		texCoord = tcoord;\n\
	}\n\
	";

	this.fragmentShader = "\
	precision lowp float; \n\
	varying vec2 texCoord;\n";
	if ( this.renderContext.lighting )
		this.fragmentShader += "varying vec3 color;\n";
	this.fragmentShader += "\
	uniform sampler2D colorTexture;\n\
	void main(void)\n\
	{\n\
		gl_FragColor.rgb = texture2D(colorTexture, texCoord).rgb;\n";
	if ( this.renderContext.lighting )
		this.fragmentShader += "gl_FragColor.rgb *= color;\n";
	this.fragmentShader += "\
		gl_FragColor.a = 1.0;\n\
	}\n\
	";
	
	this.program = new Program(this.renderContext);
	this.program.createFromSource( this.vertexShader, this.fragmentShader );
}

/**************************************************************************************************************/

/** 
	Add post renderer
 */
TileManager.prototype.addPostRenderer = function(renderer)
{	
	this.postRenderers.push( renderer );
	
	this.postRenderers.sort( function(r1,r2) {
		var z1 = r1.zIndex | 0;
		var z2 = r2.zIndex | 0;
		return z1 - z2;
	});
	
	if ( renderer.generate )
	{
		this.visitTiles( function(tile) {
		
			renderer.generate(tile);
		} );
	}
}

/**************************************************************************************************************/

/** 
	Remove a post renderer
 */
TileManager.prototype.removePostRenderer = function(renderer)
{
	var rendererIndex = this.postRenderers.indexOf(renderer);
	if ( rendererIndex != -1 )
	{
		// Remove the renderer from all the tiles if it has a cleanupTile method
		if ( renderer.cleanupTile )
			this.visitTiles( function(tile) { renderer.cleanupTile(tile); } );
			
		// Remove renderer from the list
		this.postRenderers.splice( rendererIndex, 1 );
	}
}

/**************************************************************************************************************/

/** 
	Set the imagery provider to be used
 */
TileManager.prototype.setImageryProvider = function(ip)
{
	this.reset();
	this.imageryProvider = ip;
	
	if (ip)
	{
		// Clean tile pool
		this.tilePool.disposeAll();
		
		this.tiling = ip.tiling;

		// Rebuild level zero tiles
		this.tileConfig.imageSize = ip.tilePixelSize;
		this.level0Tiles = this.tiling.generateLevelZeroTiles(this.tileConfig,this.tilePool);

		// Update program
		if ( ip.customShader )
		{
			this.program.dispose();
			this.program = new Program(this.renderContext);

			// Memorize current fragment shader
			this.currentFragmentShader = ip.customShader.fragmentCode ? ip.customShader.fragmentCode : this.fragmentShader;
			this.program.createFromSource( ip.customShader.vertexCode ? ip.customShader.vertexCode : this.vertexShader,
											this.currentFragmentShader );
		}
		else
		{	
			// Revert to default if needed
			if ( this.currentFragmentShader != null )
			{
				this.program.dispose();
				this.program = new Program(this.renderContext);
				this.program.createFromSource( this.vertexShader, this.fragmentShader );
				this.currentFragmentShader = null;
			}
		}
	}
}

/**************************************************************************************************************/

/** 
	Set the elevation provider to be used
 */
TileManager.prototype.setElevationProvider = function(tp)
{	
	this.reset();
	this.elevationProvider = tp;
	
	var newTesselation = tp ? tp.tilePixelSize : 9;
	if ( newTesselation != this.tileConfig.tesselation )
	{
		this.tileConfig.tesselation = newTesselation;
		
		// Reset the shared buffers : texture coordinate and indices
		var gl = this.renderContext.gl;
		this.tileIndexBuffer.reset();
		gl.deleteBuffer( this.tcoordBuffer );
		this.tcoordBuffer = null;
	}
}

/**************************************************************************************************************/

/**
	Reset the tile manager : unload all tiles
 */
TileManager.prototype.reset = function()
{
	// Abort all pending requests
	this.abortRequests();

	// Reset all level zero tiles : destroy render data, and reset state to NONE
	for (var i = 0; i < this.level0Tiles.length; i++)
	{
		this.level0Tiles[i].deleteChildren(this.renderContext,this.tilePool);
		this.level0Tiles[i].dispose(this.renderContext,this.tilePool);
	}
	
	this.level0TilesLoaded = false;
}

/**************************************************************************************************************/

/**
 *	Abort all pending requests
 */
TileManager.prototype.abortRequests = function()
{
	for ( var i=this.pendingRequests.length-1; i>=0; i-- )
	{
		this.pendingRequests[i].abort();
	}
}

/**************************************************************************************************************/

/** 
	Tile visitor
 */
TileManager.prototype.visitTiles = function( callback )
{
	// Store the tiles to process in an array, first copy level0 tiles
	var tilesToProcess = this.level0Tiles.concat([]);
	
	while( tilesToProcess.length > 0 )
	{
		// Retreive the first tile and remove it from the array
		var tile = tilesToProcess.shift();
		
		callback( tile );
		
		// Add tile children to array to be processed later
		if ( tile.children )
		{
			tilesToProcess.push( tile.children[0] );
			tilesToProcess.push( tile.children[1] );
			tilesToProcess.push( tile.children[2] );
			tilesToProcess.push( tile.children[3] );
		}
	}
}

/**************************************************************************************************************/

/**
	Traverse tiless tiles
 */
 TileManager.prototype.traverseTiles = function()
 {		
	this.tilesToRender.length = 0;
	this.visibleTiles.length = 0;
	this.tilesToRequest.length = 0;
	this.numTraversedTiles = 0;
	
	// First load level 0 tiles if needed
	if ( !this.level0TilesLoaded )
	{
		this.level0TilesLoaded = true;
		for ( var i = 0; i < this.level0Tiles.length; i++ )
		{
			var tile = this.level0Tiles[i];

			var tileIsLoaded = tile.state == Tile.State.LOADED;
			
			// Update frame number
			tile.frameNumber = this.frameNumber;
			
			this.level0TilesLoaded = this.level0TilesLoaded && tileIsLoaded;
			if ( !tileIsLoaded )
			{		
				// Request tile if necessary
				if ( tile.state == Tile.State.NONE )
				{
					tile.state = Tile.State.REQUESTED;
					this.tilesToRequest.push(tile);
				}
				else if ( tile.state == Tile.State.ERROR && this.imageryProvider )
				{
					this.parent.publish("baseLayersError", this.imageryProvider);
				}
			}
		}
		if ( this.level0TilesLoaded && this.imageryProvider  )
		{
			this.parent.publish("baseLayersReady");
		}
	}
	
	// Traverse tiles
	if ( this.level0TilesLoaded )
	{
		// Normal traversal, iterate through level zero tiles and process them recursively
		for ( var i = 0; i < this.level0Tiles.length; i++ )
		{
			var tile = this.level0Tiles[i];
			if ( !tile.isCulled(this.renderContext) )
			{
				this.processTile(tile,0);
			}
			else 
			{
				// Delete its children
				tile.deleteChildren(this.renderContext,this.tilePool);
			}
		}
	}
}

/**************************************************************************************************************/

/**
	Process a tile
 */
TileManager.prototype.processTile = function(tile,level)
{
	this.numTraversedTiles++;
	
	// Update frame number
	tile.frameNumber = this.frameNumber;
	
	var isLeaf = true;

	// Request the tile if needed
	if ( tile.state == Tile.State.NONE )
	{
		tile.state = Tile.State.REQUESTED;
		
		// Add it to the request
		this.tilesToRequest.push(tile);
	}
		
	// Check if the tiles needs to be refined
	// We only refine loaded tile
	if ( tile.state == Tile.State.LOADED  )
	{
		if ( this.imageryProvider )
		{
			isLeaf = level >= this.imageryProvider.numberOfLevels;
		}
		else
		{
			isLeaf = false;
		}
		
		isLeaf |= !tile.needsToBeRefined( this.renderContext );
	}
	
	if ( isLeaf )
	{
		// Push the tiles to render only if the texture is valid or there is no imagery provider defined
		if ( tile.texture || this.renderTileWithoutTexture )
		{
			this.tilesToRender.push( tile );
		}
		this.visibleTiles.push( tile );
	}
	else
	{
		// Create the children if needed
		if ( tile.children == null )
		{
			tile.createChildren();
		}
		
		for ( var i = 0; i < 4; i++ )
		{
			if (!tile.children[i].isCulled(this.renderContext))
			{
				this.processTile(tile.children[i],level+1);
			}
			else
			{
				tile.children[i].deleteChildren(this.renderContext,this.tilePool);
			}
		}
	}
	
	// Traverse extension
	for ( var x in tile.extension ) 
	{
		var e = tile.extension[x];
		if ( e.traverse ) e.traverse(tile,isLeaf);
	}
}

/**************************************************************************************************************/

/**
 	Generate tile
 */
TileManager.prototype.generateTile = function(tile, tileRequest)
{
	// Generate the tile using data from tileRequest if defined
	tile.generate( this.tilePool, tileRequest.image, tileRequest.elevations );

	// Now post renderers can generate their data on the new tile
	for (var i=0; i < this.postRenderers.length; i++ )
	{
		if ( this.postRenderers[i].generate )
			this.postRenderers[i].generate( tile );
	}
	
	this.numTilesGenerated++;
	this.renderContext.requestFrame();
}

/**************************************************************************************************************/

/**
	Generate tiles
 */
 TileManager.prototype.generateReceivedTiles = function()
 {
	while ( this.completedRequests.length > 0 )
	{
		var tileRequest = this.completedRequests.pop();
		var tile = tileRequest.tile;
		if ( tile.frameNumber == this.frameNumber )
		{
			this.generateTile( tile, tileRequest );
		}
		else
		{
			tile.state = Tile.State.NONE;			
		}
		this.availableRequests.push(tileRequest);
	}
	
	// All requests have been processed, send endBackgroundLoad event
	if ( this.availableRequests.length == this.maxRequests && this.imageryProvider )
		this.parent.publish("endBackgroundLoad");

}

/**************************************************************************************************************/

/**
	Render tiles
 */
 TileManager.prototype.renderTiles = function()
 {
	var rc = this.renderContext;
	var gl = rc.gl;
	
	// Compute near/far from tiles
	var nr;
	var fr;
	if ( this.tileConfig.cullSign < 0 )
	{
		// When in "Astro" mode, do not compute near/far from tiles not really needed
		// And the code used for "Earth" does not works really well, when the earth is seen from inside...
		nr = 0.2 * this.tileConfig.coordinateSystem.radius;
		fr = 1.1 * this.tileConfig.coordinateSystem.radius;
	}
	else
	{
		nr = 1e9;
		fr = 0.0;
		for ( var i = 0; i < this.visibleTiles.length; i++ )
		{
			var tile = this.visibleTiles[i];
			// Update near/far to take into account the tile
			nr = Math.min( nr, tile.distance - 1.5 * tile.radius );
			fr = Math.max( fr, tile.distance + 1.5 * tile.radius );
		}
	}
	rc.near = Math.max( rc.minNear, nr );
	rc.far = Math.max( rc.minFar, fr );

	if ( this.tilesToRender.length != 0 )
	{
		// Set state (depends if geo or astro)
		if ( this.tileConfig.cullSign < 0 )
		{
			gl.depthMask(false);
			gl.disable(gl.DEPTH_TEST);
			gl.disable(gl.CULL_FACE);
		}
		else
		{
			gl.enable(gl.POLYGON_OFFSET_FILL);
			gl.polygonOffset(0,4);
		}
		
		// Check if the program of imagery provider changed
		// Only for fragment shader for now
		if ( this.currentFragmentShader && this.currentFragmentShader != this.imageryProvider.customShader.fragmentCode )
		{
			this.program.dispose();
			this.program = new Program(this.renderContext);

			if ( this.imageryProvider && this.imageryProvider.customShader )
			{
				this.currentFragmentShader = this.imageryProvider.customShader.fragmentCode ? this.imageryProvider.customShader.fragmentCode : this.fragmentShader;
				this.program.createFromSource( this.imageryProvider.customShader.vertexShader ? this.imageryProvider.customShader.vertexShader : this.vertexShader,
											   this.currentFragmentShader );
			}
		}

		// Setup program
		this.program.apply();
		
		var attributes = this.program.attributes;
			
		// Update projection matrix with new near and far values
		mat4.perspective(rc.fov, rc.canvas.width / rc.canvas.height, rc.near, rc.far, rc.projectionMatrix);

		// Update uniforms if needed
		if ( this.imageryProvider && this.imageryProvider.customShader )
			this.imageryProvider.customShader.updateUniforms(gl, this.program);

		// Setup state
		gl.activeTexture(gl.TEXTURE0);
		gl.uniformMatrix4fv(this.program.uniforms["projectionMatrix"], false, rc.projectionMatrix);
		gl.uniform1i(this.program.uniforms["colorTexture"], 0);
		
		// Bind the texture coordinate buffer (shared between all tiles
		if ( !this.tcoordBuffer )
			this.buildSharedTexCoordBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);
		gl.vertexAttribPointer(attributes['tcoord'], 2, gl.FLOAT, false, 0, 0);
		
		var currentIB = null;
		
		for ( var i = 0; i < this.tilesToRender.length; i++ )
		{
			var tile = this.tilesToRender[i];
			
			var isLoaded = ( tile.state == Tile.State.LOADED );
			var isLevelZero = ( tile.parentIndex == -1 );
			
			// Bind tile texture if defined, the default texture otherwise
			if ( tile.texture )
			{
				gl.bindTexture(gl.TEXTURE_2D, tile.texture);
			}
			else
			{
				gl.bindTexture(gl.TEXTURE_2D, this.defaultTexture);
			}

			// Update uniforms for modelview matrix
			mat4.multiply( rc.viewMatrix, tile.matrix, rc.modelViewMatrix );
			gl.uniformMatrix4fv(this.program.uniforms["modelViewMatrix"], false, rc.modelViewMatrix);
		
			// Bind the vertex buffer
			gl.bindBuffer(gl.ARRAY_BUFFER, tile.vertexBuffer);
			gl.vertexAttribPointer(attributes['vertex'], 3, gl.FLOAT, false, 4*this.tileConfig.vertexSize, 0);
			if (this.tileConfig.normals)
				gl.vertexAttribPointer(attributes['normal'], 3, gl.FLOAT, false, 4*this.tileConfig.vertexSize, 12);
					
			var indexBuffer = ( isLoaded || isLevelZero ) ? this.tileIndexBuffer.getSolid() : this.tileIndexBuffer.getSubSolid(tile.parentIndex);
			// Bind the index buffer only if different (index buffer is shared between tiles)
			if ( currentIB != indexBuffer )
			{	
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
				currentIB = indexBuffer;
			}
			
			// Finally draw the tiles
			gl.drawElements(gl.TRIANGLES, currentIB.numIndices, gl.UNSIGNED_SHORT, 0);
		}
		
		if ( this.tileConfig.cullSign < 0 )
		{
			gl.depthMask(true);
			gl.enable(gl.DEPTH_TEST);
		}
		else		
		{
			gl.disable(gl.POLYGON_OFFSET_FILL);
		}
	}
	
	for (var i=0; i < this.postRenderers.length; i++ )
	{
		this.postRenderers[i].render( this.visibleTiles );
	}
}

// Internal function to sort tiles
var _sortTilesByDistance = function(t1,t2)
{
	return t1.distance - t2.distance;
};

/**************************************************************************************************************/

/**
	Request tiles
 */
 TileManager.prototype.launchRequests = function()
 {
	// Process request
	this.tilesToRequest.sort( _sortTilesByDistance );
	
	var trl = this.tilesToRequest.length; 
	for ( var i = 0; i < trl; i++ )
	{
		var tile = this.tilesToRequest[i];
		if ( this.availableRequests.length > 0 ) // Check to limit the number of requests done per frame
		{
			// First launch request, send an event
			if ( this.availableRequests.length == this.maxRequests && this.imageryProvider )
				this.parent.publish("startBackgroundLoad");
			
			var tileRequest = this.availableRequests.pop();
			tileRequest.launch( tile );
		}
		else
		{
			tile.state = Tile.State.NONE;
		}
	}
}

/**************************************************************************************************************/

/**
	Render the tiles
 */
TileManager.prototype.render = function()
{
	if ( this.imageryProvider && !this.imageryProvider._ready )
	{
		return;
	}
	
	// Specific case when the image provider has a level zero image : generate the texture for each level zero tile
	if ( !this.level0TilesLoaded && this.imageryProvider && this.imageryProvider.levelZeroImage )
	{
		this.imageryProvider.generateLevel0Textures( this.level0Tiles, this.tilePool );
		
		for (var n = 0; n < this.level0Tiles.length; n++ )
		{
			var tile = this.level0Tiles[n];
			// Generate the tile without tile request
			this.generateTile( tile, {} );
		}

		this.level0TilesLoaded = true;

		this.parent.publish("baseLayersReady");
	}

	var stats = this.renderContext.stats;
	
	if (!this.freeze)
	{
		if (stats) stats.start("traverseTime");
		this.traverseTiles();
		if (stats) stats.end("traverseTime");
	}

	if ( this.level0TilesLoaded || !this.imageryProvider )
	{
		if (stats) stats.start("renderTime");
		this.renderTiles();
		if (stats) stats.end("renderTime");
	}
	
	if (stats) stats.start("generateTime");
	this.generateReceivedTiles();
	if (stats) stats.end("generateTime");
	
	if (stats) stats.start("requestTime");
	this.launchRequests();
	if (stats) stats.end("requestTime");
		
	this.frameNumber++;
}

/**************************************************************************************************************/

/**
	Returns visible tile for given longitude/latitude, null otherwise
 */
TileManager.prototype.getVisibleTile = function(lon, lat)
{
	return this.tiling.findInsideTile(lon, lat, this.visibleTiles);
}

/**************************************************************************************************************/

/**
	Build shared texture coordinate buffer
 */
TileManager.prototype.buildSharedTexCoordBuffer = function()
{
	var size = this.tileConfig.tesselation;
	var skirt = this.tileConfig.skirt;
	var bufferSize = 2*size*size;
	if (skirt)
		bufferSize += 2*size*6;

	var tcoords = new Float32Array( bufferSize );

	var step = 1.0 / (size-1);
	
	var offset = 0;
	var v = 0.0;
	for ( var j=0; j < size; j++)
	{
		var u = 0.0;
		for ( var i=0; i < size; i++)
		{
			tcoords[offset] = u;
			tcoords[offset+1] = v;

			offset += 2;
			u += step;
		}
		
		v += step;
	}
	
	if ( skirt )
	{
		// Top skirt
		u = 0.0;
		v = 0.0;
		for ( var i=0; i < size; i++)
		{
			tcoords[offset] = u;
			tcoords[offset+1] = v;
			u += step;
			offset += 2;
		}
		// Bottom skirt
		u = 0.0;
		v = 1.0;
		for ( var i=0; i < size; i++)
		{
			tcoords[offset] = u;
			tcoords[offset+1] = v;
			u += step;
			offset += 2;
		}
		// Left skirt
		u = 0.0;
		v = 0.0;
		for ( var i=0; i < size; i++)
		{
			tcoords[offset] = u;
			tcoords[offset+1] = v;
			v += step;
			offset += 2;
		}
		// Right skirt
		u = 1.0;
		v = 0.0;
		for ( var i=0; i < size; i++)
		{
			tcoords[offset] = u;
			tcoords[offset+1] = v;
			v += step;
			offset += 2;
		}
		
		// Center skirt
		u = 0.0;
		v = 0.5;
		for ( var i=0; i < size; i++)
		{
			tcoords[offset] = u;
			tcoords[offset+1] = v;
			u += step;
			offset += 2;
		}
		
		// Middle skirt
		u = 0.5;
		v = 0.0;
		for ( var i=0; i < size; i++)
		{
			tcoords[offset] = u;
			tcoords[offset+1] = v;
			v += step;
			offset += 2;
		}
	}
	
	var gl = this.renderContext.gl;
	var tcb = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, tcb);
	gl.bufferData(gl.ARRAY_BUFFER, tcoords, gl.STATIC_DRAW);
	
	this.tcoordBuffer = tcb;
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/



/**************************************************************************************************************/

/** @constructor
	VectorRenderererManager constructor
 */
var VectorRendererManager = function(globe)
{
	// Create the registered renderers
	this.renderers = [];
	for ( var i = 0; i < VectorRendererManager.factory.length; i++ )
	{
		this.renderers.push( VectorRendererManager.factory[i](globe) );
	}
	
	// The array of renderables used during rendering
	this.renderables = [];
	
	// To uniquely identify buckets created by the renderers
	this.bucketId = 0;
}

/**************************************************************************************************************/

/**
	The factory for renderers
 */
VectorRendererManager.factory = [];

/**************************************************************************************************************/

/**
	Get a renderer
 */
VectorRendererManager.prototype.getRenderer = function(geometry,style)
{
	for ( var i = 0; i < this.renderers.length; i++ )
	{
		if ( this.renderers[i].canApply(geometry.type,style) )
		{
			return this.renderers[i];
		}
	}
	
	return null;
}

/**************************************************************************************************************/

/**
 *	Generate the tile data
 */
VectorRendererManager.prototype.generate = function(tile)
{
	if ( !tile.parent )
	{
		for ( var i=0; i < this.renderers.length; i++ )
		{
			this.renderers[i].generateLevelZero(tile);
		}
	}
	else
	{
		var tileData = tile.parent.extension.renderer;
		if ( tileData )
		{
			// delete renderer created at init time
			delete tile.extension.renderer;
			
			// Now generate renderables
			for ( var i = 0; i < tileData.renderables.length; i++ )
			{
				var renderable = tileData.renderables[i];
				if ( renderable.generateChild )
				{
					renderable.generateChild( tile );
				}
			}
		}
	}
}

/**************************************************************************************************************/

/**
 	Add a geometry to the renderer
 */
VectorRendererManager.prototype.addGeometry = function(layer, geometry, style)
{
	var renderer = this.getRenderer(geometry,style);
	renderer.addGeometry(layer, geometry, style);
}

/**************************************************************************************************************/

/**
 	Remove a geometry from the renderer
 */
VectorRendererManager.prototype.removeGeometry = function(geometry,layer)
{
	var bucket = geometry._bucket;
	if ( bucket && bucket.layer == layer )
	{
		bucket.renderer.removeGeometry(geometry);
		return true;
	}
	return false;
}

/**************************************************************************************************************/

/**
	Add a geometry to a tile
 */
VectorRendererManager.prototype.addGeometryToTile = function(layer, geometry, style, tile)
{
	var renderer = this.getRenderer(geometry,style);
	renderer.addGeometryToTile(layer, geometry, style, tile);
}
	

/**************************************************************************************************************/

/**
	Remove a geometry from a tile
 */
VectorRendererManager.prototype.removeGeometryFromTile = function(geometry,tile)
{
	var bucket = geometry._bucket;
	bucket.renderer.removeGeometryFromTile(geometry,tile);
}


/**************************************************************************************************************/

/**
	Function to sort with zIndex, then bucket
 */
var renderableSort = function(r1,r2)
{
	var zdiff = r1.bucket.style.zIndex - r2.bucket.style.zIndex;
	if ( zdiff == 0 )
		return r1.bucket.id - r2.bucket.id;
	else
		return zdiff;
};

/**************************************************************************************************************/

/**
	Render all
 */
VectorRendererManager.prototype.render = function()
{
	// Add main renderables
	for ( var j = 0; j < this.renderers.length; j++ )
	{
		var buckets = this.renderers[j].buckets;
		for ( var i = 0; i < buckets.length; i++ )
		{
			if ( buckets[i].layer._visible && buckets[i].mainRenderable )
			{
				this.renderables.push( buckets[i].mainRenderable );
			}
		}
	}
	
	// Renderable sort
	this.renderables.sort( renderableSort );
	
	//var renderCall = 0;
	
	var i = 0;
	while ( i < this.renderables.length )
	{
		var j = i + 1;
		
		var currentRenderer = this.renderables[i].bucket.renderer;
		while ( j < this.renderables.length && this.renderables[j].bucket.renderer == currentRenderer )
		{
			j++;
		}
		currentRenderer.render( this.renderables, i, j );
		//renderCall++;
		
		i = j;
	}
	
	//console.log( "# of render calls "  + renderCall );
	
	this.renderables.length = 0;
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 
 
/**************************************************************************************************************/

/**
 * Ray constructor
 */
var Ray = function(orig,dir)
{
	this.orig = orig;
	this.dir = dir;
}

/**************************************************************************************************************/

 /**
  * Create a ray from a pixel
  */
Ray.createFromPixel = function( renderContext, x, y )
{
	// reverse y because (0,0) is top left but opengl's normalized
	// device coordinate (-1,-1) is bottom left
	var nx = ((x / renderContext.canvas.width) * 2.0) - 1.0;
	var ny = -(((y / renderContext.canvas.height) * 2.0) - 1.0);
	
	var tmpMat = mat4.create();
	mat4.multiply(renderContext.projectionMatrix, renderContext.viewMatrix, tmpMat);
	mat4.inverse(tmpMat);
	// Transform pos to world using inverse viewProjection matrix
	var pos3D = mat4.multiplyVec4(tmpMat, [ nx, ny, -1, 1]);
	pos3D[0] /= pos3D[3];
	pos3D[1] /= pos3D[3];
	pos3D[2] /= pos3D[3];
	
//	console.log('Old EP ' + renderContext.eyePosition );
	var inverseViewMatrix = mat4.create();
	mat4.inverse( renderContext.viewMatrix, inverseViewMatrix );
	vec3.set( [ 0.0, 0.0, 0.0 ], renderContext.eyePosition );
	mat4.multiplyVec3( inverseViewMatrix, renderContext.eyePosition );
//	console.log('New EP ' + renderContext.eyePosition );

	
	var orig = vec3.create( renderContext.eyePosition );
	var dir = vec3.subtract( pos3D, renderContext.eyePosition, vec3.create() );
	vec3.normalize(dir);
	
	return new Ray(orig,dir);
};

/**************************************************************************************************************/

 /**
  * Create a ray from an event
  */
Ray.createFromEvent = function( renderContext, event )
{
	var pos = renderContext.getXYRelativeToCanvas(event);
	return Ray.createFromPixel( pos[0], pos[1] );
};

/**************************************************************************************************************/

/**
 * Intersection object returned
 */
Ray.Intersection = function( t )
{
	this.t = t;
	this.geometry = null;
};

/**************************************************************************************************************/

 /**
  * Compute a point on the ray given its t parameter
  */
Ray.prototype.computePoint = function( t )
{
	var pt = vec3.create();
	vec3.scale( this.dir, t, pt );
	vec3.add( pt, this.orig );
	return pt;
};

/**************************************************************************************************************/

 /**
  *	Compute intersection between a plan and ray
  * @return the nearest intersection, < 0 if no intersection
  */
Ray.prototype.planeIntersect = function( pt, normal )
{
    // Assuming vectors are all normalized
    var denom = vec3.dot(normal, this.dir);
	var epsilon = 1e-6;
    if (Math.abs(denom) > epsilon) {
        var p0l0 = vec3.create();
        vec3.subtract(pt, this.orig, p0l0);
        var t = vec3.dot(p0l0, normal) / denom;
        return t;
    }
    return -1;
}

/**************************************************************************************************************/

 /**
  * Compute intersection between a sphere and ray
  * @return the nearest intersection, < 0 if no intersection
  */
Ray.prototype.sphereIntersect = function( center, radius )
{
    // cf. http://wiki.cgsociety.org/index.php/Ray_Sphere_Intersection

    var rs = vec3.subtract( this.orig, center, vec3.create() );
    // rayDirection is normalized so a = 1
    // var a = vec3.dot(rayDirection, rayDirection);
    var b = 2.0 * vec3.dot(this.dir, rs);
    var c = vec3.dot(rs, rs) - radius*radius;

    // as a == 1, discriminant = b^2 - (4*c)
    // var discr = (b*b) - (4*a*c);
    var discr = (b*b) - (4*c);
    if (discr < 0)
        return -1;

    // t0 = (-b - sqrt(discr)) / 2a, t1 = (-b + sqrt(discr)) / 2a, a == 1
    discr = Math.sqrt(discr);
    var tNear = (-b - discr) / 2;
    var tFar  = (-b + discr) / 2;
    if (tNear > tFar) // Swap t values
    {
        var tmp = tNear;
        tNear = tFar;
        tFar = tmp;
    }

    if (tFar < 0) // Hit is beyond ray origin
        return -1;
    
    return tNear < 0 ? tFar : tNear;
};

var EPS = 1e-6;

/**************************************************************************************************************/
	
 /**
  * Ray triangle intersection optimized
  */
Ray.prototype.triangleIntersectOptimized = function( verts, i0, i1, i2 )
{
	var e1x = verts[i1] - verts[i0];
	var e1y = verts[i1+1] - verts[i0+1];
	var e1z = verts[i1+2] - verts[i0+2];
	
	var e2x = verts[i2] - verts[i0];
	var e2y = verts[i2+1] - verts[i0+1];
	var e2z = verts[i2+2] - verts[i0+2];

    var px = this.dir[1] * e2z - this.dir[2] * e2y;
	var py = this.dir[2] * e2x - this.dir[0] * e2z;
    var pz = this.dir[0] * e2y - this.dir[1] * e2x;
	
	var det = e1x * px + e1y * py + e1z * pz;
	
	if ( det > -EPS && det < EPS )
		return null;
		
	var inv_det = 1.0 / det;
	
	var tx =  this.orig[0] - verts[i0];
	var ty = this.orig[1] - verts[i0+1];
	var tz = this.orig[2] - verts[i0+2];
	
	var u = (tx * px + ty * py + tz * pz) * inv_det;
	if ( u < 0.0 ||u > 1.0 )
		return null;
		
    var qx = ty * e1z - tz * e1y;
	var qy = tz * e1x - tx * e1z;
    var qz = tx * e1y - ty * e1x;
		
	var v = (this.dir[0] * qx + this.dir[1] * qy + this.dir[2]  * qz) * inv_det;
	if ( v < 0.0 || u+v > 1.0 )
		return null;
		
	var t = (e2x * qx + e2y * qy + e2z * qz) * inv_det;
	if ( t >= 0 )
		return new Ray.Intersection(t);
	else
		return null;
}

/**************************************************************************************************************/
	
 /**
  * Ray triangle intersection
  */
/*Ray.prototype.triangleIntersect = function( vert0, vert1, vert2 )
{
	var edge1 = vec3.subtract( vert1, vert0, vec3.create() );
	var edge2 = vec3.subtract( vert2, vert0, vec3.create() );
	
	var pvec = vec3.cross( this.dir, edge2, vec3.create() );
	
	var det = vec3.dot( edge1, pvec );
	
	if ( det > -EPS && det < EPS )
		return null;
		
	var inv_det = 1.0 / det;
	
	var tvec = vec3.subtract( this.orig, vert0, vec3.create() );
	
	var u = vec3.dot( tvec, pvec ) * inv_det;
	if ( u < 0.0 || u > 1.0 )
		return null;
		
	var qvec = vec3.cross( tvec, edge1, vec3.create() );
	
	var v = vec3.dot( this.dir, qvec ) * inv_det;
	if ( v < 0.0 || u+v > 1.0 )
		return null;
		
	var t = vec3.dot( edge2, qvec ) * inv_det;
	
	return new Ray.Intersection(t);
	
};*/

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 

/**************************************************************************************************************/

/** 
	@name Event
	@class
	A light-weight event object.
 */
var Event = function()
{	
	// Event callbacks
	this.callbacks = {};
}

/**************************************************************************************************************/

/** 
	Subscribe to an event
	
	@param name Event name
		<ul>
			<li>startNavigation : called when navigation is started (by the user or through animation)</li>
			<li>endNavigation : called when navigation is ended (by the user or through animation)t</li>
			<li>baseLayersReady : called when the base layers are ready to be displayed</li>
			<li>baseLayersError : called when the base layers are not valid, or not accessible, in that case nothing is displayed so this event is useful to provide an error message to the user</li>
			<li>startBackgroundLoad : called when background layers (imagery and/or elevation) start to be loaded</li>
			<li>endBackgroundLoad : called when background layers (imagery and/or elevation) end loading</li>
			<li>startLoad : called when a layer start to be loaded</li>
			<li>endLoad : called whena layer end loading</li>
		</ul>
	@param callback Callback function
*/
Event.prototype.subscribe = function(name,callback)
{
	if ( !this.callbacks[name] ) {
		this.callbacks[name] = [ callback ];
	} else {
		this.callbacks[name].push( callback );
	}
}

/**************************************************************************************************************/

/** 
	Unsubscribe to an event 
	
	@param name Event name {@link Globe#subscribe}
	@param callback Callback function
*/
Event.prototype.unsubscribe = function(name,callback)
{
	if( this.callbacks[name] ) {
		var i = this.callbacks[name].indexOf( callback );
		if ( i != -1 ) {
			this.callbacks[name].splice(i,1);
		}
	}
}

/**************************************************************************************************************/

/**
	Publish an event
	
	@param name Event name
	@param context Context
	
	@private
*/
Event.prototype.publish = function(name,context)
{
	if ( this.callbacks[name] ) {
		var cbs = this.callbacks[name];
		for ( var i = 0; i < cbs.length; i++ ) {
			cbs[i](context);
		}
	}
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 

/**************************************************************************************************************/

/** 
	@name Globe
	@class
	Create a virtual globe in a HTML canvas element, passed in options parameter.
	The virtual globe data is set using setBaseImage/addLayer methods.
	
	@param options Configuration properties for the Globe :
		<ul>
			<li>canvas : the canvas for WebGL, can be string (id) or a canvas element</li>
			<li>renderContext : <RenderContext> object to use the existing render context</li>
			<li>backgroundColor : the background color of the canvas (an array of 4 floats)</li>
			<li>shadersPath : the path to shaders file</li>
			<li>continuousRendering: if true rendering is done continuously, otherwise it is done only if needed</li>
			<li>defaultColor : Texture color without imagery provider</li>
		</ul>
	
 */
var Globe = function(options)
{
	Event.prototype.constructor.call( this );
	
	if ( options.coordinateSystem )
	{
		this.coordinateSystem = options.coordinateSystem;
	}
	else
	{
		this.coordinateSystem = new CoordinateSystem();
	}

	if ( !options.renderContext )
	{
		this.renderContext = new RenderContext(options);
	}
	else
	{
		this.renderContext = options.renderContext;
	}
	this.tileManager = new TileManager( this, options );
	this.vectorRendererManager = new VectorRendererManager( this );
	this.attributionHandler = null;
	this.baseImagery = null;
	this.preRenderers = [];
	this.nbCreatedLayers = 0;
	
	this.tileManager.addPostRenderer( this.vectorRendererManager );

	this.renderContext.renderers.push(this);
	this.renderContext.requestFrame();
}

/**************************************************************************************************************/

Utils.inherits( Event, Globe );

/**************************************************************************************************************/

/** 
	Dispose the globe and all its ressources
 */
Globe.prototype.dispose = function()
{	
	this.tileManager.tilePool.disposeAll();
	this.tileManager.reset();
}

/**************************************************************************************************************/

/**
 	Destroy globe
 */
 Globe.prototype.destroy = function()
 {
 	this.dispose();
 	this.tileManager.removePostRenderer( this.vectorRendererManager );
 	this.renderContext.renderers.splice( this.renderContext.renderers.indexOf(this.globe), 1 );
 }


/**************************************************************************************************************/

/** 
  Refresh rendering, must be called when canvas size is modified
 */
Globe.prototype.refresh = function()
{
	this.renderContext.requestFrame();
}

/**************************************************************************************************************/

/** 
  Set the base imagery layer for the globe
  
  @param {RasterLayer} layer the layer to use, must be an imagery RasterLayer
*/
Globe.prototype.setBaseImagery = function(layer)
{
	if ( this.baseImagery == layer )
		return;

	if ( this.baseImagery )
	{
		this.removeLayer( this.baseImagery );
		this.baseImagery = null;
	}
	// Attach the layer to the globe 
	if ( layer )
	{
		layer._overlay = false;
		this.addLayer(layer);
		this.baseImagery = layer;
	}
	// Modify the tile manager after the layer has been attached
	this.tileManager.setImageryProvider(layer);
}

/**************************************************************************************************************/

/** 
  Set the base elevation layer for the globe
  
  @param {RasterLayer} layer the layer to use, must be an elevation RasterLayer
*/
Globe.prototype.setBaseElevation = function(layer)
{
	if ( this.tileManager.elevationProvider )
	{
		this.removeLayer( this.tileManager.elevationProvider );
	}
	this.tileManager.setElevationProvider(layer);
	if ( layer )
	{
		layer._overlay = false;
		this.addLayer(layer);
	}
}


/**************************************************************************************************************/

/** 
  Add a layer to the globe.
  A layer must be added to be visualized on the globe.
  
  @param layer the layer to add
*/
Globe.prototype.addLayer = function(layer)
{
	layer.id = this.nbCreatedLayers;
	layer._attach(this);
	this.renderContext.requestFrame();
	this.nbCreatedLayers++;
}

/**************************************************************************************************************/

/** 
  Remove a layer
  
  @param layer the layer to remove
*/
Globe.prototype.removeLayer = function(layer)
{
	layer._detach();
	this.renderContext.requestFrame();
}

/**************************************************************************************************************/

/** 
  Add an animation
  
  @param anim the animation to add
*/
Globe.prototype.addAnimation = function(anim)
{
	anim.renderContext = this.renderContext;
}

/**************************************************************************************************************/

/** 
  Remove an animation
  
  @param anim the animation to remove
*/
Globe.prototype.removeAnimation = function(anim)
{
	anim.renderContext = null;
}

/**************************************************************************************************************/

/** 
  Get the elevation at a geo position
  
  @param lon the longitude in degree
  @param lat  the latitude in degree
  @return the elevation in meter at the position [lon,lat]
*/
Globe.prototype.getElevation = function(lon,lat)
{
	// Use imagery provider tiling if defined, otherwise use globe default one
	var tiling = this.tileManager.tiling;
	if ( this.baseImagery ) {
		var tiling = this.baseImagery.tiling;
	}
	var levelZeroTile = this.tileManager.level0Tiles[ tiling.lonlat2LevelZeroIndex(lon,lat) ];
	if ( levelZeroTile.state == Tile.State.LOADED )
		return levelZeroTile.getElevation(lon,lat);
	else
		return 0.0;
}

/**************************************************************************************************************/

/** 
	Get the viewport geo bound

	@param transformCallback
		Callback transforming the frustum/globe intersection coordinates if needed

    @return the geo bound of the viewport
*/
Globe.prototype.getViewportGeoBound = function(transformCallback)
{
	var rc = this.renderContext;
	var tmpMat = mat4.create();
	
	// Compute eye in world space
	mat4.inverse(rc.viewMatrix, tmpMat);
	var eye = [tmpMat[12], tmpMat[13], tmpMat[14]];
	
	// Compute the inverse of view/proj matrix
	mat4.multiply(rc.projectionMatrix, rc.viewMatrix, tmpMat);
	mat4.inverse(tmpMat);
	
	// Transform the four corners of the frustum into world space
	// and then for each corner compute the intersection of ray starting from the eye with the earth
	var points = [ [ -1, -1, 1, 1 ], [ 1, -1, 1, 1 ], [ -1, 1, 1, 1 ], [ 1, 1, 1, 1 ] ];
	var earthCenter = [ 0, 0, 0 ];
	for ( var i = 0; i < 4; i++ )
	{
		mat4.multiplyVec4( tmpMat, points[i] );
		vec3.scale( points[i], 1.0 / points[i][3] );
		vec3.subtract(points[i], eye, points[i]);
		vec3.normalize( points[i] );

		var ray = new Ray( eye, points[i] );
		var t = ray.sphereIntersect( earthCenter, this.coordinateSystem.radius );
		if ( t < 0.0 )
			return null;
		var pos3d = ray.computePoint(t);
		points[i] = this.coordinateSystem.from3DToGeo( pos3d );
		if (transformCallback) 
		{
			points[i] = transformCallback(points[i]);
		}
	}

	var geoBound = new GeoBound();
	geoBound.computeFromCoordinates( points );

	return geoBound;
}

/**************************************************************************************************************/

/** 
	Get the lon-lat from a pixel.
	The pixel is expressed in the canvas frame, i.e. (0,0) corresponds to the lower-left corner of the pixel
	
	@param 	x the pixel x coordinate
	@param 	y the pixel y coordinate
	@return	an array of two numbers [lon,lat] or null if the pixel is not on the globe
 */
Globe.prototype.getLonLatFromPixel = function(x,y)
{	
	var ray = Ray.createFromPixel(this.renderContext, x, y);
	var intersection;
	if ( this.coordinateSystem.isFlat )
	{
		intersection =  ray.planeIntersect( [0,0,0], [0,0,1] );
	}
	else
	{
		intersection = ray.sphereIntersect( [0,0,0], this.coordinateSystem.radius );
	}
	
	if ( intersection >= 0 )
	{
		return this.coordinateSystem.from3DToGeo( ray.computePoint(intersection) );
	}
	else
	{
		return null;
	}
}

/**************************************************************************************************************/

/** 
	Get pixel from lon-lat
	The pixel is expressed in the canvas frame, i.e. (0,0) corresponds to the lower-left corner of the pixel
	
	@param lon	the longitude
	@param lat	the latitude
	@return	an array of two numbers [x,y] or null if the pixel is not on the globe
 */
Globe.prototype.getPixelFromLonLat = function(lon,lat)
{	
	var pos3d = vec3.create();
	this.coordinateSystem.fromGeoTo3D([lon,lat], pos3d);
	var pixel = this.renderContext.getPixelFrom3D(pos3d[0],pos3d[1],pos3d[2]);
	return pixel
}

/**************************************************************************************************************/

/**
	Render the globe
	TODO : private for now because it is automatically called in requestAnimationFrame.
	@private
 */
Globe.prototype.render = function()
{
	// Call pre-renderers
	for ( var i = 0 ; i < this.preRenderers.length; i++ )
		this.preRenderers[i].preRender();
		
	// Render tiles
	this.tileManager.render();
}

/**************************************************************************************************************/

/**
	Set coordinate system
 */
Globe.prototype.setCoordinateSystem = function(coordinateSystem)
{
	this.coordinateSystem = coordinateSystem;
	this.tileManager.tileConfig.coordinateSystem = coordinateSystem;
	this.dispose();
	this.tileManager.level0Tiles = this.tileManager.tiling.generateLevelZeroTiles(this.tileManager.tileConfig,this.tileManager.tilePool);
}

/**************************************************************************************************************/

/**
	Display some render statistics
	@private
 */
Globe.prototype.getRenderStats = function()
{
	return "# rendered tiles : " + this.tileManager.tilesToRender.length;
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 
 
/**************************************************************************************************************/


/** @name BaseLayer
	@class
	Base class for layer.
	@param options Configuration properties for a BaseLayer:
		<ul>
			<li>name : the layer name</li>
			<li>description :  its description</li>
			<li>attribution : its attribution</li>
			<li>icon : an icon to represent the layer</li>
			<li>visible : a boolean flag to set the layer visible, default is true </li>
			<li>opacity : an opacity value, default is 1.0</li>
		</ul>
 */
var BaseLayer = function(options)
{
	Event.prototype.constructor.call( this, options );

	this.globe = null;
	this.name = options && options.hasOwnProperty('name') ? options['name'] : "";
	this.attribution = options && options.hasOwnProperty('attribution') ? options['attribution'] : "";
	this.icon = options && options.hasOwnProperty('icon') ? options['icon'] : "";
	this.description = options && options.hasOwnProperty('description') ? options['description'] : "";
	this._visible = options && options.hasOwnProperty('visible') ? options['visible'] : true;
	this._opacity = options && options.hasOwnProperty('opacity') ? options['opacity'] : 1.0;
}

/**************************************************************************************************************/

Utils.inherits( Event,BaseLayer );

/**************************************************************************************************************/

/** 
  Attach the raster layer to the globe
 */
BaseLayer.prototype._attach = function( g )
{
	this.globe = g;
	if ( this.attribution && this.globe.attributionHandler && this._visible )
	{
		this.globe.attributionHandler.addAttribution(this);
	}
}

/**************************************************************************************************************/

/** 
  Detach the vector layer from the globe
 */
BaseLayer.prototype._detach = function()
{
	if ( this.attribution && this.globe.attributionHandler )
	{
		this.globe.attributionHandler.removeAttribution(this);
	}
	
	this.globe = null;
}

/**************************************************************************************************************/

/**
  Get/Set the layer visible
 */
BaseLayer.prototype.visible = function( arg )
{
	if ( typeof arg == "boolean" )
	{
		if (  this._visible != arg && this.attribution && this.globe.attributionHandler )
		{
			this.globe.attributionHandler.toggleAttribution(this);
		}

		this._visible = arg;
		if ( this.globe ) this.globe.renderContext.requestFrame();
		this.publish("visibility:changed", this);
	}
	return this._visible;
}

/**************************************************************************************************************/

/**
  Get/Set the opacity of the layer
 */
BaseLayer.prototype.opacity = function( arg )
{
	if ( typeof arg == "number" )
	{
		this._opacity = arg;
		if ( this.globe ) this.globe.renderContext.requestFrame();
		this.publish("opacity:changed");
	}
	return this._opacity;
};
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/



/**************************************************************************************************************/

/** @constructor
	RendererTileData constructor
	Contains a list of renderables for the tiles
	
	A renderable contains the following attributes/methods :
		Attributes :
			bucket : the renderable bucket
			initChild (opt) : create a child at "init" time (children are created but not yet loaded)
			generateChild (opt) : generate a child at "generate" time (children are loaded)
			dispose : discard any gl data
			add : add a geometry to the renderable
			remove: remove a geometry from the renderable
 */
var RendererTileData = function(manager)
{
	this.manager = manager;
	this.renderables = [];
}

/**************************************************************************************************************/

/**
 * Initialize a child tile
 */
RendererTileData.prototype.initChild = function(childTile,i,j)
{
	var childData;
	for ( var n = 0; n < this.renderables.length; n++ ) 
	{
		if ( this.renderables[n].initChild )
		{		
			var r = this.renderables[n].initChild(i,j,childTile);
			if (r)
			{
				if (!childData)
					childData = childTile.extension.renderer = new RendererTileData(this.manager);
				childData.renderables.push( r );
			}
		}
	}
}

/**************************************************************************************************************/

/**
 * Traverse the renderer data
 */
RendererTileData.prototype.traverse = function(tile,isLeaf)
{
	for ( var i = 0; i < this.renderables.length; i++ ) 
	{
		var renderable = this.renderables[i];
		var bucket = renderable.bucket;
		if ( bucket.layer._visible && bucket.layer._opacity > 0 )
		{
			if ( renderable.traverse )
			{
				renderable.traverse( this.manager, tile, isLeaf  );
			}
			else
			{
				if ( renderable.hasChildren 
					&& !isLeaf )
					continue;
				
				this.manager.renderables.push( renderable );
			}
		}
	}
}

/**************************************************************************************************************/

/**
	Get a renderable from the tile, given the bucket
 */
RendererTileData.prototype.getRenderable = function(bucket)
{
	for ( var i=0; i < this.renderables.length; i++ )
	{
		if ( bucket == this.renderables[i].bucket )
		{
			return this.renderables[i];
		}
	}
	return null;
}

/**************************************************************************************************************/

/**
	Dispose renderable data from tile
 */
RendererTileData.prototype.dispose = function(renderContext,tilePool)
{
	for ( var i=0; i < this.renderables.length; i++ )
	{
		this.renderables[i].dispose(renderContext,tilePool);
	}
	this.renderables.length = 0;
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/



/**************************************************************************************************************/

/** 
	@constructor
	RasterOverlayRenderer constructor
 */
var RasterOverlayRenderer = function(globe)
{
	this.vertexShader = "\
	attribute vec3 vertex;\n\
	attribute vec2 tcoord;\n\
	uniform mat4 modelViewMatrix;\n\
	uniform mat4 projectionMatrix;\n\
	uniform vec4 textureTransform; \n\
	varying vec2 texCoord;\n\
	void main(void) \n\
	{\n\
		gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n\
		texCoord = tcoord * textureTransform.xy + textureTransform.zw;\n\
	}\n\
	";

	this.fragmentShader = "\
	precision lowp float;\n\
	varying vec2 texCoord;\n\
	uniform sampler2D overlayTexture;\n\
	uniform float opacity; \n\
	void main(void)\n\
	{\n\
		gl_FragColor.rgba = texture2D(overlayTexture, texCoord.xy); \n\
		gl_FragColor.a *= opacity; \n\
	}\n\
	";
	
	this.rendererManager = globe.vectorRendererManager;
	this.tileManager = globe.tileManager;
	this.programs = [];
	this.program = this.createProgram( {
		vertexCode: this.vertexShader,
		fragmentCode: this.fragmentShader,
		updateUniforms: null
	});
	
	this.buckets = [];
	this.imageRequests = [];
	this.frameNumber = 0;
	
	
	var self = this;
	for ( var i = 0; i < 4; i++ ) {
		var imageRequest = new ImageRequest({
			successCallback: function(){
				if ( this.renderable )
				{
					if ( this.renderable.bucket.layer.handleImage )
						this.renderable.bucket.layer.handleImage(this);

					this.renderable.ownTexture = self.tileManager.tilePool.createGLTexture(this.image);
					this.renderable.texture = this.renderable.ownTexture;
					this.renderable.uvScale = 1.0;
					this.renderable.uTrans = 0.0;
					this.renderable.vTrans = 0.0;
					this.renderable.updateChildrenTexture();
					this.renderable.onRequestFinished(true);
					this.renderable = null;
					self.tileManager.renderContext.requestFrame();
				}
			},
			failCallback: function(){
				if ( this.renderable )
				{
					this.renderable.onRequestFinished(true);
					this.renderable = null;
				}
			},
			abortCallback: function(){
				//console.log("Raster overlay request abort.");
				if ( this.renderable )
				{
					this.renderable.onRequestFinished(false);
					this.renderable = null;
				}
			}
		});

		this.imageRequests.push( imageRequest );
	}
}

/**************************************************************************************************************/

/** 
	@constructor
	Create a renderable for the overlay.
	There is one renderable per overlay and per tile.
 */
var RasterOverlayRenderable = function( bucket )
{
	this.bucket = bucket;
	this.ownTexture = null;
	this.texture = null;
	this.request = null;
	this.requestFinished = false;
	this.tile = null;
	this.uvScale = 1.0;
	this.uTrans = 0.0;
	this.vTrans = 0.0;
}

/**************************************************************************************************************/

/** 
	Called when a request is started
 */
RasterOverlayRenderable.prototype.onRequestStarted = function(request)
{
	this.request = request;
	this.requestFinished = false;
	var layer = this.bucket.layer;
	if ( layer._numRequests == 0 )
	{
		layer.globe.publish('startLoad',layer);
	}
	layer._numRequests++;
}

/**************************************************************************************************************/

/** 
	Called when a request is finished
 */
RasterOverlayRenderable.prototype.onRequestFinished = function(completed)
{
	this.request = null;
	this.requestFinished = completed;
	var layer = this.bucket.layer;
	layer._numRequests--;
	if ( layer.globe && layer._numRequests == 0 )
	{
		layer.globe.publish('endLoad',layer);
	}
}

/**************************************************************************************************************/

/**
 * Initialize a child renderable
 */
RasterOverlayRenderable.prototype.initChild = function(i,j,childTile)
{				
	// Request finished and no texture  : no init needed for children
/*	// TODO : does not work because sometimes level 0 cannot be loaded
	if (this.requestFinished && !this.ownTexture)
		return null;*/
		
	var renderable = this.bucket.createRenderable();
	renderable.tile = childTile;	
	if ( this.texture )
	{
		renderable.texture = this.texture;
		renderable.uvScale = this.uvScale;
		renderable.uTrans = this.uTrans;
		renderable.vTrans = this.vTrans;
	}
	
	return renderable;
}

/**************************************************************************************************************/

/** 
	Generate child renderable
 */
RasterOverlayRenderable.prototype.generateChild = function( tile )
{
	// Request finished and no texture  : no generate needed for children
/*	// TODO : does not work because sometimes level 0 cannot be loaded
	if (this.requestFinished && !this.ownTexture)
		return;*/

	var r = this.bucket.renderer;
	r.addOverlayToTile( tile, this.bucket, this );
}

/**************************************************************************************************************/

/** 
	Update the children texture
 */
 RasterOverlayRenderable.prototype.updateChildrenTexture = function()
{
	if ( this.tile.children )
	{
		for ( var i = 0; i < 4; i++ )
		{
			var rd = this.tile.children[i].extension.renderer;
			if ( rd )
			{
				var cr = rd.getRenderable(this.bucket);
				if ( cr && !cr.ownTexture )
				{
					cr.updateTextureFromParent( this );
					cr.updateChildrenTexture();
				}
			}
		}
	}
}

/**************************************************************************************************************/

/** 
	Update texture from its parent
 */
RasterOverlayRenderable.prototype.updateTextureFromParent = function( parent )
{
	if ( this.tile.state == Tile.State.LOADED )
	{
		this.texture = parent.texture;
		this.uvScale = parent.uvScale * 0.5;
		this.uTrans = parent.uTrans;
		this.vTrans = parent.vTrans;
		
		this.uTrans += (this.tile.parentIndex & 1) ? this.uvScale : 0;
		this.vTrans += (this.tile.parentIndex & 2) ? this.uvScale : 0;
	}
	else
	{
		this.texture = parent.texture;
		this.uvScale = parent.uvScale;
		this.uTrans = parent.uTrans;
		this.vTrans = parent.vTrans;
	}
}

/**************************************************************************************************************/

/** 
	Traverse renderable : add it to renderables list if there is a texture
	Request the texture
 */
 RasterOverlayRenderable.prototype.traverse = function( manager, tile, isLeaf  )
{
	if ( isLeaf && this.texture )
	{
		manager.renderables.push( this );
	}
	
	if (!this.requestFinished && this.tile.state == Tile.State.LOADED)
	{
		this.bucket.renderer.requestOverlayTextureForTile( this);
	}
}

/**************************************************************************************************************/

/** 
	Dispose the renderable
 */
RasterOverlayRenderable.prototype.dispose = function(renderContext,tilePool)
{
	if ( this.ownTexture ) 
	{
		tilePool.disposeGLTexture(this.ownTexture);
		this.ownTexture = null;
	}
}


/**************************************************************************************************************/

/**
	Bucket constructor for RasterOverlay
 */
var Bucket = function(layer)
{
	this.layer = layer;
	this.renderer = null;
	// TODO : hack
	this.style = layer;
}

/**************************************************************************************************************/

/**
	Create a renderable for this bucket
 */
Bucket.prototype.createRenderable = function()
{
	return new RasterOverlayRenderable(this);
}

/**************************************************************************************************************/

/**
	Add an overlay into the renderer.
	The overlay is added to all loaded tiles.
 */
RasterOverlayRenderer.prototype.addOverlay = function( overlay )
{
	// Initialize num requests to 0
	overlay._numRequests = 0;

	var bucket = new Bucket(overlay);
	bucket.renderer = this;
	bucket.id = this.rendererManager.bucketId++;
	this.buckets.push( bucket );
	
	overlay._bucket = bucket;
	
	for ( var i = 0; i < this.tileManager.level0Tiles.length; i++ )
	{
		var tile = this.tileManager.level0Tiles[i];
		if ( tile.state == Tile.State.LOADED )
		{
			this.addOverlayToTile( tile, bucket );
		}
	}
}

/**************************************************************************************************************/

/**
	Remove an overlay
	The overlay is removed from all loaded tiles.
 */
RasterOverlayRenderer.prototype.removeOverlay = function( overlay )
{
	var index = this.buckets.indexOf( overlay._bucket );
	this.buckets.splice(index,1);
	
	var rc = this.tileManager.renderContext;
	var tp = this.tileManager.tilePool;
	this.tileManager.visitTiles( function(tile) 
			{
				var rs = tile.extension.renderer;
				var renderable = rs ?  rs.getRenderable( overlay._bucket ) : null;
				if ( renderable ) 
				{
					// Remove the renderable
					var index = rs.renderables.indexOf(renderable);
					rs.renderables.splice(index,1);
					
					// Dispose its data
					renderable.dispose(rc,tp);
					
					// Remove tile data if not needed anymore
					if ( rs.renderables.length == 0 )
						delete tile.extension.renderer;
				}
			}
	);
}

/**************************************************************************************************************/

/**
	Add an overlay into a tile.
	Create tile data if needed, and create the renderable for the overlay.
 */
RasterOverlayRenderer.prototype.addOverlayToTile = function( tile, bucket, parentRenderable )
{
	if (!this.overlayIntersects( tile.geoBound, bucket.layer ))
		return;
		
	if ( !tile.extension.renderer )
		tile.extension.renderer = new RendererTileData(this.rendererManager);
	
	var renderable = bucket.createRenderable();
	renderable.tile = tile;
	tile.extension.renderer.renderables.push( renderable );
	
	if ( parentRenderable && parentRenderable.texture )
	{
		renderable.updateTextureFromParent( parentRenderable );
	}
	
	if ( tile.children )
	{
		// Add the overlay to loaded children
		for ( var i = 0; i < 4; i++ )
		{
			if ( tile.children[i].state == Tile.State.LOADED )
			{
				this.addOverlayToTile( tile.children[i], bucket, renderable );
			}
		}
	}

}

/**************************************************************************************************************/

/**
	Create an interpolated for polygon clipping
 */	
var _createInterpolatedVertex = function( t, p1, p2 )
{
	return [ p1[0] + t * (p2[0] - p1[0]), p1[1] + t * (p2[1] - p1[1]) ];
}

/**************************************************************************************************************/

/**
	Clip polygon to a side (used by bound-overlay intersection)
 */	
RasterOverlayRenderer.prototype.clipPolygonToSide = function( coord, sign, value, polygon )
{
	var clippedPolygon = [];

	// iterate through vertices
	for ( var i = 0; i < polygon.length; i++ )
	{
		var p1 = polygon[i];
		var p2 = polygon[ (i+1) % polygon.length ];
		var val1 = p1[coord];
		var val2 = p2[coord];

		// test containement
		var firstInside = (val1 - value) * sign >= 0.0;
		var secondInside = (val2 - value) * sign >= 0.0;
	
		// output vertices for inside polygon
		if ( !firstInside && secondInside )
		{
			var t = (value - val1) / (val2- val1);
			var newPoint = _createInterpolatedVertex( t, p1, p2 );
			clippedPolygon.push( newPoint );
			clippedPolygon.push( p2 );
		}
		else if ( firstInside && secondInside )
		{
			clippedPolygon.push( p2 );
		}
		else if ( firstInside && !secondInside )
		{
			var t = (value - val1) / (val2- val1);
			var newPoint = _createInterpolatedVertex( t, p1, p2 );
			clippedPolygon.push( newPoint );
		}
	}
	
	return clippedPolygon;
}

/**************************************************************************************************************/

/**
	Check the intersection between a geo bound and an overlay
 */	
RasterOverlayRenderer.prototype.overlayIntersects = function( bound, overlay )
{
	if ( overlay.coordinates )
	{
		var c;
		c = this.clipPolygonToSide( 0, 1, bound.west, overlay.coordinates );
		c = this.clipPolygonToSide( 0, -1, bound.east, c );
		c = this.clipPolygonToSide( 1, 1, bound.south, c );
		c = this.clipPolygonToSide( 1, -1, bound.north, c );
		return c.length > 0;
	}
	else if ( overlay.geoBound )
	{
		return overlay.geoBound.intersects( bound );
	}
	
	// No geobound or coordinates : always return true
	return true;
}

/**************************************************************************************************************/

/**
	Generate Raster overlay data on the tile.
	The method is called by TileManager when a new tile has been generated.
 */
RasterOverlayRenderer.prototype.generateLevelZero = function( tile )
{
	// Traverse all overlays
	for ( var i = 0; i < this.buckets.length; i++ )
	{
		this.addOverlayToTile(tile,this.buckets[i]);
	}
}

/**************************************************************************************************************/

/**
	Request the overlay texture for a tile
 */
RasterOverlayRenderer.prototype.requestOverlayTextureForTile = function( renderable )
{	
	if ( !renderable.request )
	{
		var imageRequest;
		for ( var i = 0; i < this.imageRequests.length; i++ )
		{
			if ( !this.imageRequests[i].renderable  ) 
			{
				imageRequest = this.imageRequests[i];
				break;
			}
		}
		
		if ( imageRequest )
		{
			renderable.onRequestStarted(imageRequest);
			imageRequest.renderable = renderable;
			imageRequest.frameNumber = this.frameNumber;
			imageRequest.send(renderable.bucket.layer.getUrl(renderable.tile), renderable.bucket.layer.crossOrigin);
		}
	}
	else
	{
		renderable.request.frameNumber = this.frameNumber;
	}
}

/**************************************************************************************************************/

/**
 	Create program from customShader object
 */
RasterOverlayRenderer.prototype.createProgram = function(customShader)
{
	var program = new Program(this.tileManager.renderContext);
	program.createFromSource(this.vertexShader, customShader.fragmentCode);
	
    // Add program
    program.id = this.programs.length;
    this.programs.push({ 
    	fragmentCode: customShader.fragmentCode,
    	program: program
	});
	return program;
}

/**************************************************************************************************************/

/**
 	Get program if known by renderer, create otherwise
 */
RasterOverlayRenderer.prototype.getProgram = function(customShader) {

	var program;

    for(var id=0; id<this.programs.length; id++)
    {
        if( this.programs[id].fragmentCode == customShader.fragmentCode )
        {
        	program = this.programs[id].program;
        }
    }

    if ( !program )
    {
    	program = this.createProgram(customShader);
    }
    return program;
}

/**************************************************************************************************************/

/**
 *	Render the raster overlays for the given tiles
 */
RasterOverlayRenderer.prototype.render = function( renderables, start, end )
{
	var rc = this.tileManager.renderContext;
 	var gl = rc.gl;

	// Update gl states
	gl.enable(gl.BLEND);
	gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );
	gl.depthFunc( gl.LEQUAL );
	
	var modelViewMatrix = mat4.create();
	
	var currentTile = null;
	var currentIB = null;
	var currentProgram = null;

	for ( var n = start; n < end; n++ )
	{
		var renderable = renderables[n];
		var bucket = renderable.bucket;
		var layer = bucket.layer;
		
		var updateUniforms;
		var program;
		if ( layer.customShader )
		{
			program = this.getProgram(layer.customShader);
			updateUniforms = layer.customShader.updateUniforms;
		}
		else
		{
			program = this.getProgram({
				vertexCode: this.vertexShader,
				fragmentCode: this.fragmentShader,
				updateUniforms: null
			});
		}
		
		// Apply program if changed
		if ( program != currentProgram )
		{
			currentProgram = program;
			program.apply();
							
			gl.uniformMatrix4fv(program.uniforms["projectionMatrix"], false, rc.projectionMatrix);
			gl.uniform1i(program.uniforms["overlayTexture"], 0);
			
			// Bind tcoord buffer
			gl.bindBuffer(gl.ARRAY_BUFFER, this.tileManager.tcoordBuffer);
			gl.vertexAttribPointer(program.attributes['tcoord'], 2, gl.FLOAT, false, 0, 0);
		}	
		
		if (updateUniforms)
			updateUniforms(gl, program);
		
		// Bind the vertex buffer
		gl.bindBuffer(gl.ARRAY_BUFFER, renderable.tile.vertexBuffer);
		gl.vertexAttribPointer(program.attributes['vertex'], 3, gl.FLOAT, false, 4*renderable.tile.config.vertexSize, 0);
		
		// Bind the index buffer only if different (index buffer is shared between tiles)
		var indexBuffer = ( renderable.tile.state == Tile.State.LOADED ) ? this.tileManager.tileIndexBuffer.getSolid() : this.tileManager.tileIndexBuffer.getSubSolid(renderable.tile.parentIndex);
		if ( currentIB != indexBuffer )
		{	
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer );
			currentIB = indexBuffer;
		}

		// Bind the tile tile matrix
		mat4.multiply( rc.viewMatrix, renderable.tile.matrix, modelViewMatrix );
		gl.uniformMatrix4fv(program.uniforms["modelViewMatrix"], false, modelViewMatrix);
					
		gl.uniform1f(program.uniforms["opacity"], layer._opacity );
		gl.uniform4f(program.uniforms["textureTransform"], renderable.uvScale, renderable.uvScale, renderable.uTrans, renderable.vTrans );
		
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, renderable.texture );
		
		// Finally draw the tiles
		gl.drawElements(gl.TRIANGLES, currentIB.numIndices, gl.UNSIGNED_SHORT, 0);
	}
	
	// reset gl states
	gl.disable(gl.BLEND);
	//gl.disable(gl.POLYGON_OFFSET_FILL);
	gl.depthFunc( gl.LESS );
}

/**************************************************************************************************************/

/**
 * Check if renderer is applicable
 */
RasterOverlayRenderer.prototype.canApply = function(type,style)
{
	return false;
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/



/**
 *	Cache storing <RasterLayer> tile requests in browser's local storage
 *	Due to performance reasons, it's recommended to use it only for tiles of level 0
 *	@param options
 *		<ul>
 *			<li>layer: Layer which will contain the given cache(required)</li>
 *			<li>cacheLevel: the maximum level of tiles to be cached</li>
 *		</ul>
 */
var Cache = function(options) {
	
	this.layer = options.layer;

	this.cacheLevel = options.hasOwnProperty('cacheLevel') ? options.cacheLevel : 1;

	if ( !localStorage.getItem(this.layer.name) )
	{
		// Create cache space in local storage named after layer
		localStorage.setItem(this.layer.name, JSON.stringify({}));
	}

	this._cacheMap = JSON.parse(localStorage.getItem(this.layer.name));

	this.imgCanvas = document.createElement("canvas");
	// Make sure canvas is as big as layer requests
	this.imgCanvas.width = options['tilePixelSize'] || 256;
	this.imgCanvas.height = options['tilePixelSize'] || 256;

	this.imgContext = this.imgCanvas.getContext("2d");
}


/**************************************************************************************************************/

/**
 *	Get tile request from cache for the given tile
 *	@returns The image(TODO: handle elevations) corresponding to the given tile, null if doesn't exist in cache
 */
Cache.prototype.getFromCache = function( tile )
{
	var cachedTileRequest = null;
	if ( this.cacheLevel >= tile.level )
	{
		var tileId = this.layer.getUrl(tile);
		var tileInfo = this._cacheMap[tileId];
		if ( tileInfo )
		{
			// Update access info
			tileInfo.lastAccess = Date.now();

			var image = new Image();
			image.src = tileInfo.dataUrl;
			image.dataType = "byte";
			cachedTileRequest = {
				image: image,
				elevations: tileInfo.elevations
			};
		}
	}
	return cachedTileRequest;
};

/**************************************************************************************************************/

/**
 *	Internal method to generate data url from HTML image object
 */
Cache.prototype._createDataURL = function( image )
{
	// Draw image into canvas element
	this.imgContext.drawImage(image, 0, 0, image.width, image.height);

	// Save image as a data URL
	return this.imgCanvas.toDataURL("image/png");
};

/**************************************************************************************************************/

/**
 *	Store tile request in cache
 */
Cache.prototype.storeInCache = function( tileRequest )
{
	var tile = tileRequest.tile;
	if ( this.cacheLevel >= tile.level )
	{
		var tileId = this.layer.getUrl(tile);
		this._cacheMap[tileId] = {
			dataUrl: this._createDataURL(tileRequest.image),
			elevations: tileRequest.elevations,
			lastAccess: Date.now()
		};
		console.log("Stored for " + tileRequest.image.src);

		// Update local storage with new cache
		localStorage.setItem(this.layer.name, JSON.stringify(this._cacheMap));
	}
};
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 

/**************************************************************************************************************/


/** @name RasterLayer
	@class
	Base class for raster layer
	@augments BaseLayer
	@param options Configuration properties for the RasterLayer. See {@link BaseLayer} for base properties :
		<ul>
			<li>tilePixelSize : the image size for a tile, default is 256.</li>
			<li>numberOfLevels : the maximum number of levels</li> 
			<li>geoBound : the extent of the layer</li>
			<li>cache : Object containing cache options</li>
		</ul>
*/
var RasterLayer = function( options )
{
	BaseLayer.prototype.constructor.call( this, options );
	
	// Base properties
	this.tilePixelSize = -1;
	this.tiling = null;
	this.numberOfLevels = -1;
	this.geoBound = options.geoBound || null;
	this.coordinates = options.coordinates || null;
	this.zIndex = options.zIndex || 0;
	this.crossOrigin = options.crossOrigin || 'anonymous';

	// Init cache if defined
	if ( options.cache )
	{
		options.cache.layer = this;
		this.cache = new Cache(options.cache);
	}
	
	// Internal
	this._overlay = true; 
	this._ready = true; // Ready is use by TileManager
}

/**************************************************************************************************************/

Utils.inherits( BaseLayer,RasterLayer );

/**************************************************************************************************************/

/** 
  Attach the raster layer to the globe
 */
RasterLayer.prototype._attach = function( g )
{
	if ( !this._overlay )
	{
		// Override id of background layer because of unicity of background not overlayed layer
		this.id = 0;
	}

	BaseLayer.prototype._attach.call( this, g );
		
	if ( this._overlay )
	{
		// Create the renderer if needed
		if ( !g.rasterOverlayRenderer )
		{
			var renderer = new RasterOverlayRenderer(g);
			g.vectorRendererManager.renderers.push( renderer );
			g.rasterOverlayRenderer = renderer;
		}
		g.rasterOverlayRenderer.addOverlay(this);
	}
}

/**************************************************************************************************************/

/** 
  Detach the raster layer from the globe
 */
RasterLayer.prototype._detach = function()
{
	// Remove raster from overlay renderer if needed
	if ( this._overlay && this.globe.rasterOverlayRenderer )
	{
		this.globe.rasterOverlayRenderer.removeOverlay(this);
	}
	
	BaseLayer.prototype._detach.call(this);
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
 


/**************************************************************************************************************/


/** @name WMSLayer
	@class
	A layer to display WMS (Web Map Service) data.
	@augments RasterLayer
	@param options Configuration properties for the WMSLayer. See {@link RasterLayer} for base properties :
		<ul>
			<li>baseUrl : the base Url to access the WMS server</li>
			<li>layers : the list of layers to request (WMS parameter)</li>
			<li>srs : the spatial system reference to use, default is EPSG:4326 (WMS parameter)</li>
			<li>format : the file format to request, default is image/jpeg (WMS parameter)</li>
		</ul>
 */
var WMSLayer = function( options )
{
	RasterLayer.prototype.constructor.call( this, options );
	
	this.baseUrl = options['baseUrl'];
	this.tilePixelSize = options['tilePixelSize'] || 256;
	this.tiling = new GeoTiling( 4, 2 );
	this.numberOfLevels = options['numberOfLevels'] || 21;
	
	// Build the base GetMap URL
	var url = this.baseUrl;
	if ( url.indexOf('?',0) == -1 )
	{
		url += '?service=wms';
	}
	else
	{
		url += '&service=wms';
	}
	url += "&version="
	url += options.hasOwnProperty('version') ? options['version'] : '1.1.1';
	url += "&request=GetMap";
	url += "&layers=" + options['layers'];
	url += "&styles=";
	if ( options.hasOwnProperty('styles') )
	{
		url += options.styles;
	}
	url += "&format=";
	url += options.hasOwnProperty('format') ? options['format'] : 'image/jpeg';
	if ( options.hasOwnProperty('transparent') )
	{
		url += "&transparent=" + options.transparent;
	}
	url += "&width=";
	url += this.tilePixelSize;
	url += "&height=";
	url += this.tilePixelSize;
	if ( options.hasOwnProperty('time') )
	{
		url += "&time=" + options.time;
	}
	
	this.getMapBaseUrl = url;
}

/**************************************************************************************************************/

Utils.inherits(RasterLayer,WMSLayer);

/**************************************************************************************************************/

/**
	Get an url for the given tile
 */
WMSLayer.prototype.getUrl = function(tile)
{
	// Just add the bounding box to the GetMap URL
	var bound = tile.bound;
	var url = this.getMapBaseUrl;
	
	url += "&srs=" + tile.config.srs;
	url += "&bbox=";
	
	url += bound.west;
	url += ",";
	url += bound.south;
	url += ",";
	url += bound.east;
	url += ",";
	url += bound.north;

//	console.log(url);
	
	return url;
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
 


/**************************************************************************************************************/


/** @export
	@constructor
	WMTSLayer constructor
 */
var WMTSLayer = function( options )
{
	RasterLayer.prototype.constructor.call( this, options );
	
	this.baseUrl = options['baseUrl'];
	this.tilePixelSize = options['tilePixelSize'] || 256;
	this.tiling = new GeoTiling( 4, 2 );
	this.numberOfLevels = options['numberOfLevels'] || 21;
	this.type = "ImageryRaster";
	this.startLevel = options['startLevel'] || 1;
	
	// Build the base GetTile URL
	var url = this.baseUrl;
	if ( url.indexOf('?',0) == -1 )
	{
		url += '?service=wmts';
	}
	else
	{
		url += '&service=wmts';
	}
	url += "&version="
	url += options['version'] || '1.0.0';
	url += "&request=GetTile";
	url += "&layer=" + options['layer'];
	url += "&tilematrixset=" + options['matrixSet'];
	if ( options['style'] )
	{
		url += "&style=" + options.style;
	}
	url += "&format=";
	url += options['format'] || 'image/png';
	if ( options['time'] )
	{
		url += "&time=" + options.time;
	}
	
	this.getTileBaseUrl = url;
}

/**************************************************************************************************************/

Utils.inherits(RasterLayer,WMTSLayer);

/**************************************************************************************************************/

/**
	Get an url for the given tile
 */
WMTSLayer.prototype.getUrl = function(tile)
{
	var url = this.getTileBaseUrl;
	url += "&tilematrix=";
	url += tile.level + this.startLevel;
	url += "&tilecol=" + tile.x;
	url += "&tilerow=" + tile.y;
	
	return url;
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
 


/**************************************************************************************************************/


/** @name WCSElevationLayer
	@class
	Create a layer for elevation data using WCS protocol.
	The only supported format is right now image/x-aaigrid. It is an ASCII format that is easily parsed in Javascript.
	@augments RasterLayer
	@param options Configuration properties for the WCSElevationLayer. See {@link RasterLayer} for base properties :
		<ul>
			<li>baseUrl : the base Url to access the WCS server</li>
			<li>coverage : the name of the coverage to use (WCS parameter)</li>
			<li>crs : the coordinate reference system to use (WCS parameter)</li>
			<li>version : 2.0.x or 1.0.x is supported</li>
			<li>scale : elevation scale value</li>
		</ul>
 */
var WCSElevationLayer = function( options )
{
	RasterLayer.prototype.constructor.call( this, options );
	
	this.baseUrl = options['baseUrl'];
	this.tilePixelSize = options['tilePixelSize'] || 33;
	this.tiling = new GeoTiling( 4, 2 );
	this.numberOfLevels = options['numberOfLevels'] || 21;
	this.version = options['version'] || '2.0.0';
	this.format = options['format'] || 'image/x-aaigrid';
	this.minElevation = options['minElevation'] || 0;
	this.scale = options['scale'] || 1;
	
	// Build the base GetMap URL
	var url = this.baseUrl;
	if ( url.indexOf('?',0) == -1 )
	{
		url += '?service=wcs';
	}
	else
	{
		url += '&service=wcs';
	}
	url += "&version=" + this.version;
	url += "&request=GetCoverage";

	switch (this.version.substring(0,3)) 
	{
		case '2.0':
			this.crs = options['outputCRS'] || options['crs'] || 'http://www.opengis.net/def/crs/EPSG/0/4326';
			url += '&outputCRS=' + this.crs;
			url += "&size=x(" + this.tilePixelSize + ")";
			url += "&size=y(" + this.tilePixelSize + ")";
			url += "&coverageid=" + options['coverage'];
			break;
		case '1.0':
			url += "&width=" + this.tilePixelSize;
			url += "&height=" + this.tilePixelSize;
			url += '&crs=' + (options['crs'] || 'EPSG:4326');
			url += "&coverage=" + options['coverage'];
			break;
	}
	url += '&format=' + this.format;
	
	this.getCoverageBaseUrl = url;
}

Utils.inherits(RasterLayer,WCSElevationLayer);


/**************************************************************************************************************/

/**
	Parse a elevation response
 */
WCSElevationLayer.prototype.parseElevations = function(text)
{
	if (text == null) {
		return this._returnZeroElevations();
	}
	switch(this.format) {
	case "image/x-aaigrid":
		return this._parseAAIGrid(text);
	default:
		console.log("Format '" + this.format + "' could not be parsed.");
		return this._returnZeroElevations();
	}
}

/**************************************************************************************************************/


/**
	Fallback elevations when no data was returned
 */
WCSElevationLayer.prototype._returnZeroElevations = function()
{
	var elevations = [];
	for( var i = 0; i < this.tilePixelSize * this.tilePixelSize; ++i ) {
		elevations.push(0);
	}
	return elevations;
}


/**************************************************************************************************************/


/**
	Parse a elevation response from AAIGrid
 */
WCSElevationLayer.prototype._parseAAIGrid = function(text)
{
	var elevations = [];
	var lines = text.trim().split('\n');

	var dataLinesStart = 0;
	for ( var i = 0; i < lines.length; ++i ) {
		if (lines[i].substring(0, 1) === " ") {
			dataLinesStart = i;
			break;
		}
	}

	for ( var i = dataLinesStart; i < lines.length; i++ )
	{
		var elts = lines[i].trim().split(/\s+/);
		for ( var n=0; n < elts.length; n++ )
		{
			var elevation = parseInt(elts[n]);
			if ( elevation < this.minElevation ) 
				elevation = this.minElevation;
			elevations.push( elevation * this.scale );
		}
	}

	return elevations;
}


/**************************************************************************************************************/

/**
	Get an url for the given tile
 */
WCSElevationLayer.prototype.getUrl = function(tile)
{
	var geoBound = tile.geoBound;
	var url = this.getCoverageBaseUrl;

	if (this.version.substring(0,3) === '2.0') 
	{
		url += '&subset=x,' + this.crs + '(' + geoBound.west + ',' + geoBound.east + ')';
		url += '&subset=y,' + this.crs + '(' + geoBound.south + ',' + geoBound.north + ')';
	}
	else if (this.version.substring(0,3) === '1.0') 
	{
		url += "&bbox=";	
		url += geoBound.west;
		url += ",";
		url += geoBound.south;
		url += ",";
		url += geoBound.east;
		url += ",";
		url += geoBound.north;
	}
	
	return url;
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 

/**************************************************************************************************************/

/** @constructor
	MercatorTiling constructor
 */
var MercatorTiling = function(startLevel)
{
	this.startLevel = startLevel;
	this.level0NumTilesX = Math.pow(2,this.startLevel);
}

/** inherits from geotiling */
MercatorTiling.prototype = new GeoTiling;


var lon2merc = function(lon) {
	return lon * 20037508.34 / 180;
};

var lat2merc = function(lat) {
	var y = Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180);
	return y * 20037508.34 / 180;
};

/**************************************************************************************************************/

/** 
	Generate the tiles for level zero
 */
MercatorTiling.prototype.generateLevelZeroTiles = function(config)
{
	config.skirt = true;
	config.cullSign = 1;
	config.srs = 'EPSG:3857';
	config.project = function(coord) {
		return [ lon2merc(coord[0]), lat2merc(coord[1]) ];
	};
	
	var level0Tiles = [];
	
	var level0NumTilesX = Math.pow(2,this.startLevel);
	var level0NumTilesY = Math.pow(2,this.startLevel);
	
	for (var j = 0; j < level0NumTilesY; j++)
	{
		for (var i = 0; i < level0NumTilesX; i++)
		{
			var tile = new MercatorTile( this.startLevel, i, j );
			tile.config = config;
			level0Tiles.push( tile );
		}
	}

	return level0Tiles;
}

/**************************************************************************************************************/

/** 
	Locate a level zero tile
 */
MercatorTiling.prototype._lon2LevelZeroIndex = function(lon)
{	
	var x = (lon + 180) / 360; 
	return Math.min(  this.level0NumTilesX-1, Math.floor( x * this.level0NumTilesX ) );
}

/**************************************************************************************************************/

/** 
	Locate a level zero tile
 */
MercatorTiling.prototype._lat2LevelZeroIndex = function(lat)
{	
	var sinLatitude = Math.sin(lat * Math.PI / 180);
	var y = 0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * Math.PI);
	return Math.min(  this.level0NumTilesX-1, Math.floor( y * this.level0NumTilesX ) );
}


/**************************************************************************************************************/

var tile2long = function(x,z) {
	return ( x /Math.pow(2,z) * 360 - 180 );
}

var tile2lat = function(y,z) {
	var n = Math.PI - 2 * Math.PI * y / Math.pow(2,z);
	return ( 180 / Math.PI * Math.atan(0.5*(Math.exp(n)-Math.exp(-n))));
}		

/**************************************************************************************************************/

/** @constructor
	Tile constructor
 */
var MercatorTile = function( level, x, y )
{
    // Call ancestor constructor
    Tile.prototype.constructor.call(this);
	
	this.level = level;
	this.x = x;
	this.y = y;
	
	this.geoBound = new GeoBound( tile2long(x,level), tile2lat(y+1,level), tile2long(x+1,level), tile2lat(y,level) );	
	this.bound = new GeoBound( lon2merc(this.geoBound.west), lat2merc(this.geoBound.south), lon2merc(this.geoBound.east), lat2merc(this.geoBound.north) );
}

/**************************************************************************************************************/

/** Inhertis from tile */
MercatorTile.prototype = new Tile;

/**************************************************************************************************************/

/** @export
  Get elevation at a geo position
*/
MercatorTile.prototype.getElevation = function(lon,lat)
{
	// TODO
	return 0.0;
}

/**************************************************************************************************************/

/**
	Create the children
 */
MercatorTile.prototype.createChildren = function()
{
	// Create the children
	var tile00 = new MercatorTile( this.level+1, 2*this.x, 2*this.y );
	var tile10 = new MercatorTile( this.level+1, 2*this.x+1, 2*this.y );
	var tile01 = new MercatorTile( this.level+1, 2*this.x, 2*this.y+1 );
	var tile11 = new MercatorTile( this.level+1, 2*this.x+1, 2*this.y+1 );
	
	tile00.initFromParent( this, 0, 0 );
	tile10.initFromParent( this, 1, 0 );
	tile01.initFromParent( this, 0, 1 );
	tile11.initFromParent( this, 1, 1 );
	
	this.children = [ tile00, tile10, tile01, tile11 ];	
}

/**************************************************************************************************************/

/**
	Convert coordinates in longitude,latitude to coordinate in "tile space"
	Tile space means coordinates are between [0,tesselation-1] if inside the tile
	Used by renderers algorithm to clamp coordinates on the tile
 */
MercatorTile.prototype.lonlat2tile = function(coordinates)
{
	var tpl = Math.pow(2,this.level);
	var factor = this.config.tesselation-1;
	
	var tileCoords = [];
	for ( var i = 0; i < coordinates.length; i++ )
	{
		var x = ( coordinates[i][0] + 180.) / 360.; 
		var sinLat = Math.sin(coordinates[i][1] * Math.PI / 180.);
		var y = 0.5 - Math.log((1 + sinLat) / (1 - sinLat)) / (4. * Math.PI);
		
		tileCoords.push( [ factor * (x * tpl - this.x), factor * (y * tpl - this.y) ] );	
	}
	
	return tileCoords;
}

/**************************************************************************************************************/

/**
	Generate vertices for tile
 */
MercatorTile.prototype.generateVertices = function(elevations)
{	 
	// Compute tile matrix
	this.matrix = this.config.coordinateSystem.getLHVTransform( this.geoBound.getCenter() );
	var invMatrix = mat4.create();
	mat4.inverse( this.matrix, invMatrix );
	this.inverseMatrix = invMatrix;

	// Build the vertices
	var size = this.config.tesselation;
	var vertices = new Float32Array( 3*size*(size+6) );
	var step = 1.0 / (size-1);
	var radius = this.config.coordinateSystem.radius;
	var scale = this.config.coordinateSystem.heightScale;
	var offset = 0;
	
	var twoPowLevel = Math.pow(2,this.level);
	
	var v = this.y;
	for ( var j=0; j < size; j++)
	{
		var n = Math.PI * (1.0  - 2.0 * v / twoPowLevel);
		var lat = Math.atan( 0.5 * (Math.exp(n) - Math.exp(-n)) );
	
		var cosLat = Math.cos( lat );
		var sinLat = Math.sin( lat );
		
		var u = this.x;
				
		for ( var i=0; i < size; i++)
		{
			var lon = Math.PI * ( 2.0 * u / twoPowLevel - 1.0 );
			var height = elevations ? scale * elevations[ offset ] : 0.0;
			
			var x = (radius + height) * Math.cos( lon ) * cosLat;
			var y = (radius + height) * Math.sin( lon ) * cosLat;
			var z = (radius + height) * sinLat;
			
			var vertexOffset = offset * 3;
			vertices[vertexOffset] = invMatrix[0]*x + invMatrix[4]*y + invMatrix[8]*z + invMatrix[12];
			vertices[vertexOffset+1] = invMatrix[1]*x + invMatrix[5]*y + invMatrix[9]*z + invMatrix[13];
			vertices[vertexOffset+2] = invMatrix[2]*x + invMatrix[6]*y + invMatrix[10]*z + invMatrix[14];
						
			offset++;
			u += step;
		}
		
		v += step;
	}
	
	return vertices;
}


/**************************************************************************************************************/

/**
	Override buildSkirtVertices for mercator.
	Use skirt to "fill" the pole
 */
 MercatorTile.prototype.buildSkirtVertices = function(center,srcOffset,srcStep,dstOffset)
{
	var size = this.config.tesselation;
	var vertexSize = this.config.vertexSize;
	var numTilesY = Math.pow(2,this.level);
	
	// Check if the tile is at the north (isTop) or south (isBottom) pole
	var isTop = this.y == 0 && dstOffset == vertexSize * (size * size);
	var isBottom = this.y == numTilesY-1 && dstOffset == vertexSize * ((size+1) * size);
		
	if ( isTop || isBottom )
	{
		var vertices = this.vertices;
		
		var pt = this.config.coordinateSystem.fromGeoTo3D( isTop ? [ 0.0, 90.0, 0.0 ] : [ 0.0, -90.0, 0.0 ] );
		mat4.multiplyVec3( this.inverseMatrix, pt );
		
		for ( var i = 0; i < size; i++)
		{			
			vertices[ dstOffset ] = pt[0];
			vertices[ dstOffset+1 ] = pt[1];
			vertices[ dstOffset+2 ] = pt[2];
			
			for (var n = 3; n < vertexSize; n++)
			{
				vertices[ dstOffset+n ] = vertices[srcOffset+n];
			}
			
			dstOffset += vertexSize;
		}	
		
		// Recompute the bbox to have correct culling
		//this.bbox.compute(this.vertices,dstOffset + vertexSize*size,vertexSize);
		//this.radius = this.bbox.getRadius();
	}
	else
	{
		Tile.prototype.buildSkirtVertices.call(this,center,srcOffset,srcStep,dstOffset);
	}
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 

/**************************************************************************************************************/


/** @name OSMLayer
	@class
	A layer to display data coming from OpenStreetMap server.
	@augments RasterLayer
	@param options Configuration properties for the OSMLayer. See {@link RasterLayer} for base properties :
		<ul>
			<li>baseUrl : the base Url to access the OSM server</li>
		</ul>
 */
var OSMLayer = function( options )
{
	RasterLayer.prototype.constructor.call( this, options );
	this.tilePixelSize = options.tilePixelSize || 256;
	this.tiling = new MercatorTiling( options.baseLevel || 2 );
	this.numberOfLevels = options.numberOfLevels || 21;
	this.baseUrl = options.baseUrl;
}

/**************************************************************************************************************/

Utils.inherits(RasterLayer,OSMLayer);

/**************************************************************************************************************/

/**
	Get an url for the given tile
 */
OSMLayer.prototype.getUrl = function(tile)
{
	var url = this.baseUrl + '/' + tile.level + '/' + tile.x + '/' + tile.y + '.png';
	return url;
}


/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/



/**************************************************************************************************************/

var BingTileSystem = (function() 
{
	var EarthRadius = 6378137;
	var MinLatitude = -85.05112878;
	var MaxLatitude = 85.05112878;
	var MinLongitude = -180;
	var MaxLongitude = 180;


	// <summary>
	// Clips a number to the specified minimum and maximum values.
	// </summary>
	// <param name="n">The number to clip.</param>
	// <param name="minValue">Minimum allowable value.</param>
	// <param name="maxValue">Maximum allowable value.</param>
	// <returns>The clipped value.</returns>
	function Clip( n, minValue, maxValue)
	{
		return Math.min(Math.max(n, minValue), maxValue);
	}
        

	// <summary>
	// Determines the map width and height (in pixels) at a specified level
	// of detail.
	// </summary>
	// <param name="levelOfDetail">Level of detail, from 1 (lowest detail)
	// to 23 (highest detail).</param>
	// <returns>The map width and height in pixels.</returns>
	function MapSize(levelOfDetail)
	{
		return 256 << levelOfDetail;
	}


	// <summary>
	// Determines the ground resolution (in meters per pixel) at a specified
	// latitude and level of detail.
	// </summary>
	// <param name="latitude">Latitude (in degrees) at which to measure the
	// ground resolution.</param>
	// <param name="levelOfDetail">Level of detail, from 1 (lowest detail)
	// to 23 (highest detail).</param>
	// <returns>The ground resolution, in meters per pixel.</returns>
	function GroundResolution(latitude, levelOfDetail)
	{
		latitude = Clip(latitude, MinLatitude, MaxLatitude);
		return Math.cos(latitude * Math.PI / 180.0) * 2.0 * Math.PI * EarthRadius / MapSize(levelOfDetail);
	}



	// <summary>
	// Determines the map scale at a specified latitude, level of detail,
	// and screen resolution.
	// </summary>
	// <param name="latitude">Latitude (in degrees) at which to measure the
	// map scale.</param>
	// <param name="levelOfDetail">Level of detail, from 1 (lowest detail)
	// to 23 (highest detail).</param>
	// <param name="screenDpi">Resolution of the screen, in dots per inch.</param>
	// <returns>The map scale, expressed as the denominator N of the ratio 1 : N.</returns>
	function MapScale( latitude, levelOfDetail, screenDpi)
	{
		return GroundResolution(latitude, levelOfDetail) * screenDpi / 0.0254;
	}

	// <summary>
	// Converts a point from latitude/longitude WGS-84 coordinates (in degrees)
	// into pixel XY coordinates at a specified level of detail.
	// </summary>
	// <param name="latitude">Latitude of the point, in degrees.</param>
	// <param name="longitude">Longitude of the point, in degrees.</param>
	// <param name="levelOfDetail">Level of detail, from 1 (lowest detail)
	// to 23 (highest detail).</param>
	// <param name="pixelX">Output parameter receiving the X coordinate in pixels.</param>
	// <param name="pixelY">Output parameter receiving the Y coordinate in pixels.</param>
	function LatLongToPixelXY(latitude, longitude, levelOfDetail)
	{
		latitude = Clip(latitude, MinLatitude, MaxLatitude);
		longitude = Clip(longitude, MinLongitude, MaxLongitude);

		var x = (longitude + 180) / 360; 
		var sinLatitude = Math.sin(latitude * Math.PI / 180);
		var y = 0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * Math.PI);

		var mapSize = MapSize(levelOfDetail);
		var pixelX = Clip(x * mapSize + 0.5, 0, mapSize - 1);
		var pixelY = Clip(y * mapSize + 0.5, 0, mapSize - 1);
		
		return [ Math.floor(pixelX),  Math.floor(pixelY) ];
	}



	// <summary>
	// Converts a pixel from pixel XY coordinates at a specified level of detail
	// into latitude/longitude WGS-84 coordinates (in degrees).
	// </summary>
	// <param name="pixelX">X coordinate of the point, in pixels.</param>
	// <param name="pixelY">Y coordinates of the point, in pixels.</param>
	// <param name="levelOfDetail">Level of detail, from 1 (lowest detail)
	// to 23 (highest detail).</param>
	// <param name="latitude">Output parameter receiving the latitude in degrees.</param>
	// <param name="longitude">Output parameter receiving the longitude in degrees.</param>
	function PixelXYToLatLong( pixelX, pixelY, levelOfDetail)
	{
		var mapSize = MapSize(levelOfDetail);
		var x = (Clip(pixelX, 0, mapSize - 1) / mapSize) - 0.5;
		var y = 0.5 - (Clip(pixelY, 0, mapSize - 1) / mapSize);

		var latitude = 90 - 360 * Math.atan(Math.exp(-y * 2 * Math.PI)) / Math.PI;
		var longitude = 360 * x;
		
		return [ latitude, longitude ];
	}



	// <summary>
	// Converts pixel XY coordinates into tile XY coordinates of the tile containing
	// the specified pixel.
	// </summary>
	// <param name="pixelX">Pixel X coordinate.</param>
	// <param name="pixelY">Pixel Y coordinate.</param>
	// <param name="tileX">Output parameter receiving the tile X coordinate.</param>
	// <param name="tileY">Output parameter receiving the tile Y coordinate.</param>
	function PixelXYToTileXY( pixelXY )
	{
		return [ pixelXY[0] / 256, pixelXY[1] / 256 ];
	}



	// <summary>
	// Converts tile XY coordinates into pixel XY coordinates of the upper-left pixel
	// of the specified tile.
	// </summary>
	// <param name="tileX">Tile X coordinate.</param>
	// <param name="tileY">Tile Y coordinate.</param>
	// <param name="pixelX">Output parameter receiving the pixel X coordinate.</param>
	// <param name="pixelY">Output parameter receiving the pixel Y coordinate.</param>
	function TileXYToPixelXY( tileXY )
	{
		return [ tileXY[0] * 256, tileXY[1] * 256 ];
	}



	// <summary>
	// Converts tile XY coordinates into a QuadKey at a specified level of detail.
	// </summary>
	// <param name="tileX">Tile X coordinate.</param>
	// <param name="tileY">Tile Y coordinate.</param>
	// <param name="levelOfDetail">Level of detail, from 1 (lowest detail)
	// to 23 (highest detail).</param>
	// <returns>A string containing the QuadKey.</returns>
	function TileXYToQuadKey( tileX,  tileY, levelOfDetail)
	{
		var quadKey = "";
		for ( var i = levelOfDetail; i > 0; i--)
		{
			var digit = '0';
			var mask = 1 << (i - 1);
			if ((tileX & mask) != 0)
			{
				digit++;
			}
			if ((tileY & mask) != 0)
			{
				digit++;
				digit++;
			}
			quadKey += digit;
		}
		return quadKey;
	}



	// <summary>
	// Converts a QuadKey into tile XY coordinates.
	// </summary>
	// <param name="quadKey">QuadKey of the tile.</param>
	// <param name="tileX">Output parameter receiving the tile X coordinate.</param>
	// <param name="tileY">Output parameter receiving the tile Y coordinate.</param>
	// <param name="levelOfDetail">Output parameter receiving the level of detail.</param>
	function QuadKeyToTileXY( quadKey)
	{
		var tileX = 0, tileY = 0;
		var levelOfDetail = quadKey.length();
		for (var i = levelOfDetail; i > 0; i--)
		{
			var mask = 1 << (i - 1);
			switch (quadKey[levelOfDetail - i])
			{
				case '0':
					break;

				case '1':
					tileX |= mask;
					break;

				case '2':
					tileY |= mask;
					break;

				case '3':
					tileX |= mask;
					tileY |= mask;
					break;

				default:
					throw new ArgumentException("Invalid QuadKey digit sequence.");
			}
		}
	}
	
	return {
		tileXYToQuadKey: TileXYToQuadKey,
		latLongToPixelXY : LatLongToPixelXY
	}
})();
 
/**************************************************************************************************************/


/** @name BingLayer
	@class
	A layer to display Bing imagery data.
	@augments RasterLayer
	@param options Configuration properties. See {@link RasterLayer} for base properties :
		<ul>
			<li>imageSet : the image set to use, can be Aerial, Road</li>
			<li>key : the bing key to use</li>
		</ul>
 */
var BingLayer = function( options )
{
	// Call ancestor
	RasterLayer.prototype.constructor.call( this, options );
	
	this.tilePixelSize = 256;
	this.tiling = new MercatorTiling( options.baseLevel || 2 );
	this.numberOfLevels = 18;
	this.baseUrl = "";
	this.baseUrlSubDomains = [];
	this._ready = false;
	
	var self = this;
	
	// Need to provide a global callback for JSONP
	window["_bingTileProviderCallback"] = function(result) {
	
			self.baseUrl = result.resourceSets[0].resources[0].imageUrl;
			self.baseUrlSubDomains = result.resourceSets[0].resources[0].imageUrlSubdomains;
			self._ready = true;
			
			// Call callback if set
			if (options.onready && options.onready instanceof Function)
			{
				options.onready(self);
			}
			
			// Request a frame
			if ( self.globe )
			{
				self.globe.renderContext.requestFrame();
			}
	};
	
	// JSONP Call : needed because of cross-site origin policy
	var script = document.createElement("script");
	script.type = "text/javascript";
	script.src = "http://dev.virtualearth.net/REST/V1/Imagery/Metadata/" + options.imageSet + "?jsonp=_bingTileProviderCallback&key=" + options.key;
	script.id = "_bingTileProviderCallback";
	document.getElementsByTagName("head")[0].appendChild(script);
}

Utils.inherits(RasterLayer,BingLayer);

/**************************************************************************************************************/

/**
	Get an url for the given tile
 */
BingLayer.prototype.getUrl = function(tile)
{
	var url = this.baseUrl.replace( "{quadkey}", BingTileSystem.tileXYToQuadKey(tile.x,tile.y,tile.level) );	
	return url.replace( "{subdomain}", this.baseUrlSubDomains[ Math.floor( Math.random() * this.baseUrlSubDomains.length ) ] );
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 
 
 
// Simple colors
var simple_colors = {
   aliceblue: 'f0f8ff',
   antiquewhite: 'faebd7',
   aqua: '00ffff',
   aquamarine: '7fffd4',
   azure: 'f0ffff',
   beige: 'f5f5dc',
   bisque: 'ffe4c4',
   black: '000000',
   blanchedalmond: 'ffebcd',
   blue: '0000ff',
   blueviolet: '8a2be2',
   brown: 'a52a2a',
   burlywood: 'deb887',
   cadetblue: '5f9ea0',
   chartreuse: '7fff00',
   chocolate: 'd2691e',
   coral: 'ff7f50',
   cornflowerblue: '6495ed',
   cornsilk: 'fff8dc',
   crimson: 'dc143c',
   cyan: '00ffff',
   darkblue: '00008b',
   darkcyan: '008b8b',
   darkgoldenrod: 'b8860b',
   darkgray: 'a9a9a9',
   darkgreen: '006400',
   darkkhaki: 'bdb76b',
   darkmagenta: '8b008b',
   darkolivegreen: '556b2f',
   darkorange: 'ff8c00',
   darkorchid: '9932cc',
   darkred: '8b0000',
   darksalmon: 'e9967a',
   darkseagreen: '8fbc8f',
   darkslateblue: '483d8b',
   darkslategray: '2f4f4f',
   darkturquoise: '00ced1',
   darkviolet: '9400d3',
   deeppink: 'ff1493',
   deepskyblue: '00bfff',
   dimgray: '696969',
   dodgerblue: '1e90ff',
   feldspar: 'd19275',
   firebrick: 'b22222',
   floralwhite: 'fffaf0',
   forestgreen: '228b22',
   fuchsia: 'ff00ff',
   gainsboro: 'dcdcdc',
   ghostwhite: 'f8f8ff',
   gold: 'ffd700',
   goldenrod: 'daa520',
   gray: '808080',
   green: '008000',
   greenyellow: 'adff2f',
   honeydew: 'f0fff0',
   hotpink: 'ff69b4',
   indianred : 'cd5c5c',
   indigo : '4b0082',
   ivory: 'fffff0',
   khaki: 'f0e68c',
   lavender: 'e6e6fa',
   lavenderblush: 'fff0f5',
   lawngreen: '7cfc00',
   lemonchiffon: 'fffacd',
   lightblue: 'add8e6',
   lightcoral: 'f08080',
   lightcyan: 'e0ffff',
   lightgoldenrodyellow: 'fafad2',
   lightgrey: 'd3d3d3',
   lightgreen: '90ee90',
   lightpink: 'ffb6c1',
   lightsalmon: 'ffa07a',
   lightseagreen: '20b2aa',
   lightskyblue: '87cefa',
   lightslateblue: '8470ff',
   lightslategray: '778899',
   lightsteelblue: 'b0c4de',
   lightyellow: 'ffffe0',
   lime: '00ff00',
   limegreen: '32cd32',
   linen: 'faf0e6',
   magenta: 'ff00ff',
   maroon: '800000',
   mediumaquamarine: '66cdaa',
   mediumblue: '0000cd',
   mediumorchid: 'ba55d3',
   mediumpurple: '9370d8',
   mediumseagreen: '3cb371',
   mediumslateblue: '7b68ee',
   mediumspringgreen: '00fa9a',
   mediumturquoise: '48d1cc',
   mediumvioletred: 'c71585',
   midnightblue: '191970',
   mintcream: 'f5fffa',
   mistyrose: 'ffe4e1',
   moccasin: 'ffe4b5',
   navajowhite: 'ffdead',
   navy: '000080',
   oldlace: 'fdf5e6',
   olive: '808000',
   olivedrab: '6b8e23',
   orange: 'ffa500',
   orangered: 'ff4500',
   orchid: 'da70d6',
   palegoldenrod: 'eee8aa',
   palegreen: '98fb98',
   paleturquoise: 'afeeee',
   palevioletred: 'd87093',
   papayawhip: 'ffefd5',
   peachpuff: 'ffdab9',
   peru: 'cd853f',
   pink: 'ffc0cb',
   plum: 'dda0dd',
   powderblue: 'b0e0e6',
   purple: '800080',
   red: 'ff0000',
   rosybrown: 'bc8f8f',
   royalblue: '4169e1',
   saddlebrown: '8b4513',
   salmon: 'fa8072',
   sandybrown: 'f4a460',
   seagreen: '2e8b57',
   seashell: 'fff5ee',
   sienna: 'a0522d',
   silver: 'c0c0c0',
   skyblue: '87ceeb',
   slateblue: '6a5acd',
   slategray: '708090',
   snow: 'fffafa',
   springgreen: '00ff7f',
   steelblue: '4682b4',
   tan: 'd2b48c',
   teal: '008080',
   thistle: 'd8bfd8',
   tomato: 'ff6347',
   turquoise: '40e0d0',
   violet: 'ee82ee',
   violetred: 'd02090',
   wheat: 'f5deb3',
   white: 'ffffff',
   whitesmoke: 'f5f5f5',
   yellow: 'ffff00',
   yellowgreen: '9acd32'
};

var parseHex = /^(\w{2})(\w{2})(\w{2})$/;
var parseRgb = /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/;
var parseRgba = /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3},\s*(\d{1,3}))\)$/;


/**************************************************************************************************************/

/** @name FeatureStyle
	@class
	The style to display a Feature
	@param style an object containing the following style properties
		<ul>
			<li>strokeColor : the color for line, or polygon outline</li>
			<li>strokeWidth : the width of a line</li>
			<li>fillColor : the color for solid polygon or point</li>
			<li>fillTextureUrl : the texture for solid polygon</li>
			<li>iconUrl : the icon to be used for point</li>
			<li>pointMaxSize : maximum size (in meter) for a point</li>
			<li>extrusionScale : extrusion scale (in meter)</li>
		</ul>
 */
var FeatureStyle = function(style)
{
	// Color used for lines or polygon outline
	this.strokeColor = [1.0, 0.0, 0.0, 1.0];
	// Color used to full polygon
	this.fillColor = [1.0, 0.0, 0.0, 1.0];
	this.fillTextureUrl = null;
    this.fillTexture = null;
    this.fillShader = null;
	this.strokeWidth = 1;
	this.iconUrl = null;
	this.icon = null;
	this.label = null;
	this.textColor = [1.0, 1.0, 1.0, 1.0];
	this.fill = false;
	this.pointMaxSize = 40;
	this.opacity = 1.;
	this.zIndex = 0;
	this.extrusionScale = 1.;

	if ( style )
	{
		for ( var s in style )
		{
			this[s] = style[s];
		}
	}
}


/**************************************************************************************************************/

/**
 * Convert a color from a string to RGB
 */
FeatureStyle.fromStringToColor = function(color_string)
{
	var r = 0, g = 0, b = 0, a = 255;
	var match;
	
	color_string = color_string.trim();
	color_string = color_string.toLowerCase();
	// strip any leading #
	if (color_string.charAt(0) == '#') { // remove # if any
	   color_string = color_string.substr(1,6);
	}
	
	// Convert a litteral color to rgb string
	if ( simple_colors.hasOwnProperty(color_string) )
	{
		color_string = simple_colors[color_string];
	}
	
	match = parseHex.exec(color_string);
	if ( match )
	{
		r = parseInt(match[1],16);
		g = parseInt(match[2],16);
		b = parseInt(match[3],16);
	}
	
	match = parseRgb.exec(color_string);
	if ( match )
	{
		r = parseInt(match[1]);
		g = parseInt(match[2]);
		b = parseInt(match[3]);
	}
	
	match = parseRgba.exec(color_string);
	if ( match )
	{
		r = parseInt(match[1]);
		g = parseInt(match[2]);
		b = parseInt(match[3]);
		a = parseInt(match[4]);
	}

	// validate/cleanup values
	r = (r < 0) ? 0 : ((r > 255) ? 255 : r);
	g = (g < 0) ? 0 : ((g > 255) ? 255 : g);
	b = (b < 0) ? 0 : ((b > 255) ? 255 : b);
	a = (a < 0) ? 0 : ((a > 255) ? 255 : a);

	return [r / 255.0, g / 255.0, b / 255.0, a / 255.0];
}

/**************************************************************************************************************/

/** 
 * Convert an internal color to a string based color representation
 */
FeatureStyle.fromColorToString = function(color)
{		
   var hashColor = '#';
   for ( var i=0; i<3; i++ )
   {
      var component = parseInt( color[i] * 255.0 ).toString(16)
      hashColor += (component < 10) ? '0'+component : component;
   }

	return hashColor;
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
 


/**************************************************************************************************************/

/** @name VectorLayer
	@class
	Create a layer to display vector data in GeoJSON format.
	@augments BaseLayer
	@param options Configuration properties for VectorLayer. See {@link BaseLayer} for base properties :
		<ul>
			<li>style : the style to use. See {@link FeatureStyle}</li>
			<li>minLevel : minimum rendering level depending on tile level</li>
			<li>maxLevel : maximum rendering level depending on tile level</li>
		</ul>
 */
var VectorLayer = function( options )
{
	BaseLayer.prototype.constructor.call( this, options );
	
	// Set style
	if ( options && options['style'] )
		this.style = options['style'];
	else
		this.style = new FeatureStyle();
	
	this.minLevel = options && options.hasOwnProperty('minLevel') ? options['minLevel'] : 0.0;
	this.maxLevel = options && options.hasOwnProperty('maxLevel') ? options['maxLevel'] : 15.0;

	this.features = [];
}

/**************************************************************************************************************/

Utils.inherits( BaseLayer,VectorLayer );

/**************************************************************************************************************/

/** 
  Attach the vector layer to the globe
 */
VectorLayer.prototype._attach = function( g )
{
	BaseLayer.prototype._attach.call( this, g );
	
	// Add the feature to renderers
	for ( var i=0; i < this.features.length; i++ )
	{
		this._addFeatureToRenderers( this.features[i] );
	}
}

/**************************************************************************************************************/

/** 
  Detach the vector layer from the globe
 */
VectorLayer.prototype._detach = function()
{
	// Remove feature from renderers
	for ( var i=0; i < this.features.length; i++ )
	{
		this._removeFeatureFromRenderers( this.features[i] );
	}
	
	BaseLayer.prototype._detach.call(this);
}

/**************************************************************************************************************/

/** @export
  Adds a feature collection, in GeoJSON format
 */
VectorLayer.prototype.addFeatureCollection = function( featureCollection )
{
	// Note : use property defined as ['']  to avoid renaming when compiled in advanced mode with the closure compiler
	var features = featureCollection['features'];
	if ( features )
	{
		for ( var i = 0; i < features.length; i++)
		{
			this.addFeature( features[i] );
		}
	}
}

/**************************************************************************************************************/

/** @export
  Removes a feature collection, in GeoJSON format
*/
VectorLayer.prototype.removeFeatureCollection = function( featureCollection )
{
	// Note : use property defined as ['']  to avoid renaming when compiled in advanced mode with the closure compiler
	var features = featureCollection['features'];
	if ( features )
	{
		for ( var i = 0; i < features.length; i++)
		{
			this.removeFeature( features[i] );
		}
	}
}

/**************************************************************************************************************/

/** 
  Add a feature to renderers
*/
VectorLayer.prototype._addFeatureToRenderers = function( feature )
{
	var geometry = feature['geometry']
	
	// Manage style, if undefined try with properties, otherwise use defaultStyle
	var style = this.style;
	var props = feature['properties'];
	if ( props && props['style'] )
	{
		style = props['style'];
	}

	// Manage geometry collection
	if ( geometry.type == "GeometryCollection" )
	{
		var geoms = geometry["geometries"];
		for ( var i = 0; i < geoms.length; i++ )
		{
			this.globe.vectorRendererManager.addGeometry( this, geoms[i], style );
		}
	}
	else
	{
		// Add geometry to renderers
		this.globe.vectorRendererManager.addGeometry( this, geometry, style );
	}
}

/**************************************************************************************************************/

/** 
  Remove a feature from renderers
*/
VectorLayer.prototype._removeFeatureFromRenderers = function( feature )
{
	var geometry = feature['geometry']
	
	// Manage geometry collection
	if ( geometry.type == "GeometryCollection" )
	{
		var geoms = geometry["geometries"];
		var res = false;
		for ( var i = 0; i < geoms.length; i++ )
		{
			res = this.globe.vectorRendererManager.removeGeometry( geoms[i], this );
		}
		return res;
	}
	else
	{
		return this.globe.vectorRendererManager.removeGeometry( geometry, this );
	}
}

/**************************************************************************************************************/

/** @export
  Add a feature to the layer
*/
VectorLayer.prototype.addFeature = function( feature )
{
	// Check feature geometry : only add valid feature
	var geometry = feature['geometry'];
	if ( !geometry || !geometry.type )
		return;
	this.features.push( feature );
	
	// Add features to renderer if layer is attached to globe
	if ( this.globe )
	{			
		this._addFeatureToRenderers(feature);
		if (this._visible) this.globe.renderContext.requestFrame();
	}
}

/**************************************************************************************************************/

/** @export
  Remove a feature from the layer
*/
VectorLayer.prototype.removeFeature = function( feature )
{
	var index = this.features.indexOf( feature );
	this.features.splice( index, 1 );
	if ( this.globe )
	{
		this._removeFeatureFromRenderers( feature );
		if (this._visible) this.globe.renderContext.requestFrame();
	}
}

/**************************************************************************************************************/

/** @export
  Remove all feature from the layer
*/
VectorLayer.prototype.removeAllFeatures = function()
{
	// Remove feature from renderers
	if ( this.globe )
	{
		for ( var i = 0; i < this.features.length; i++ )
		{
			this._removeFeatureFromRenderers( this.features[i] );
		}
	}
	this.features.length = 0;
	
	// Refresh rendering if needed
	if ( this.globe && this._visible )
	{
		this.globe.renderContext.requestFrame();
	}
}

/**************************************************************************************************************/

/** @export
  Modify feature style
*/
VectorLayer.prototype.modifyFeatureStyle = function( feature, style )
{
	if ( this._removeFeatureFromRenderers( feature ) ) {
		feature.properties.style = style;
		this._addFeatureToRenderers( feature );
	}
}

/**************************************************************************************************************/

/** @export
  Modify the vector layer style
*/
VectorLayer.prototype.modifyStyle = function(style)
{
	for ( var i=0; i<this.features.length; i++ )
	{
		this._removeFeatureFromRenderers( this.features[i] );
	}
	
	this.style = style;
	
	for ( var i=0; i<this.features.length; i++ )
	{
		this._addFeatureToRenderers( this.features[i] );
	}
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
 


//*************************************************************************

/** 
	@constructor
 */
var GroundOverlayRenderer = function(tileManager)
{
	this.renderContext = tileManager.renderContext;
	this.tileManager = tileManager;
	
	var vertexShader = "\
	attribute vec3 vertex;\n\
	attribute vec2 tcoord;\n\
	uniform mat4 modelViewMatrix;\n\
	uniform mat4 projectionMatrix;\n\
	uniform vec4 extent; \n\
	\
	varying vec2 texCoord;\n\
	\
	void main(void) \n\
	{\n\
		gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n\
		texCoord.x = tcoord.x * (extent[1] - extent[0]) + extent[0];\n\
		texCoord.y = tcoord.y * (extent[3] - extent[2]) + extent[2];\n\
	}\n\
	";

	var fragmentShader = "\
	#ifdef GL_ES\n\
	precision highp float;\n\
	#endif\n\
	\n\
	varying vec2 texCoord;\n\
	uniform sampler2D overlayTexture;\n\
	uniform mat3 transform;\n\
	uniform float opacity; \n\
	\n\
	void main(void)\n\
	{\n\
		vec3 tc = transform * vec3(texCoord,1.0); \n\
		tc.xy /= tc.z; \n\
		gl_FragColor.rgba = texture2D(overlayTexture, tc.xy); \n\
		gl_FragColor.a = (tc.x >= 0.0 && tc.x <= 1.0 && tc.y >= 0.0 && tc.y <= 1.0) ? opacity * gl_FragColor.a  : 0.0; \n\
	}\n\
	";
	
    this.program = new Program(this.renderContext);
	this.program.createFromSource( vertexShader, fragmentShader );
	
	this.groundOverlays = [];
}

//*************************************************************************

/*
	Render the ground overlays above the tiles in parameter
 */
GroundOverlayRenderer.prototype.render = function( tiles )
{
 	var gl = this.renderContext.gl;

	// Setup program
    this.program.apply();
	
	var attributes = this.program.attributes;
		
	gl.uniformMatrix4fv(this.program.uniforms["projectionMatrix"], false, this.renderContext.projectionMatrix);
	gl.uniform1i(this.program.uniforms["overlayTexture"], 0);
	gl.enable(gl.BLEND);
	gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );
	gl.depthFunc( gl.LEQUAL );
	gl.depthMask(false);
	
	var modelViewMatrix = mat4.create();
	
	var currentIB = null;

	for ( var j=0; j < this.groundOverlays.length; j++ )
	{
		var go = this.groundOverlays[j];
		
		// Image is not loaded, nothing to be done
		if ( !go.image.complete )
		{
			continue;
		}
		
		if ( !go.texture )
		{
			go.texture = this.renderContext.createNonPowerOfTwoTextureFromImage(go.image,go.flipY);
		}
		
		var initialized = false;
		
		for ( var i = 0; i < tiles.length; i++ )
		{
			var tile = tiles[i];
			if ( go.geoBound.intersects( tile.geoBound ) )
			{
				if (!initialized)
				{					
					gl.uniformMatrix3fv(this.program.uniforms["transform"], false, go.inverseTransform );
					gl.uniform1f(this.program.uniforms["opacity"], go.opacity );

					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, go.texture);
			
					gl.bindBuffer(gl.ARRAY_BUFFER, this.tileManager.tcoordBuffer);
					gl.vertexAttribPointer(attributes['tcoord'], 2, gl.FLOAT, false, 0, 0);
						
					initialized = true;
				}

				var extent = (tile.state == Tile.State.LOADED) ? tile.bound : tile.parent.bound;
				
				gl.uniform4f(this.program.uniforms["extent"], extent.west, extent.east, extent.north, extent.south );
				mat4.multiply( this.renderContext.viewMatrix, tile.matrix, modelViewMatrix );
				gl.uniformMatrix4fv(this.program.uniforms["modelViewMatrix"], false, modelViewMatrix);

				// Bind the vertex buffer
				gl.bindBuffer(gl.ARRAY_BUFFER, tile.vertexBuffer);
				gl.vertexAttribPointer(attributes['vertex'], 3, gl.FLOAT, false, 0, 0);
					
				// Bind the index buffer only if different (index buffer is shared between tiles)
				var indexBuffer = ( tile.state == Tile.State.LOADED ) ? this.tileManager.tileIndexBuffer.getSolid() : this.tileManager.tileIndexBuffer.getSubSolid(tile.parentIndex);
				if ( currentIB != indexBuffer )
				{
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
					currentIB = indexBuffer;
				}
				
				// Finally draw the tiles
				gl.drawElements(gl.TRIANGLES, indexBuffer.numIndices, gl.UNSIGNED_SHORT, 0);
			}
		}
	}

	gl.disable(gl.BLEND);
	gl.depthMask(true);
}

//*************************************************************************;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/




/**************************************************************************************************************/

/** @constructor
	@export
	This layer draws an image overlay draped onto the terrain
	Arg : options
		image : the image to drape on the terrain, can be an Image element or a string (url of the image)
		quad : An array of 4 points to define the area on the terrain to drape the image
		opacity : opacity of the layer
		flipY : flip or not the image
 */
var GroundOverlayLayer = function( options )
{
	BaseLayer.prototype.constructor.call( this, options );
	
	this.quad = options.quad;
	this.opacity = options.opacity || 1.0;
	if ( typeof options.flipY === 'undefined' )
	{
		this.flipY = true;
	}
	else
	{
		this.flipY = options.flipY;
	}
	
	// Compute the geo bound of the ground overlay
	this.geoBound = new GeoBound();
	this.geoBound.computeFromCoordinates( this.quad );

	if (typeof options.image == "string")
	{
		this.image = new Image();
		this.image.crossOrigin = '';
		this.image.src = options.image;
	}
	else if ( options.image instanceof HTMLImageElement )
	{
		this.image = options.image;
	}
	this.globe = null;
}

/**************************************************************************************************************/

Utils.inherits( BaseLayer,GroundOverlayLayer );

/**************************************************************************************************************/

/**
	Attach layer to the globe
 */
GroundOverlayLayer.prototype._attach = function( globe )
{
	// Add layer to ground overlay renderer, create one if needed
	var renderer = globe.groundOverlayRenderer;
	if ( !renderer )
	{
		renderer = new GroundOverlayRenderer(globe.tileManager);
		globe.tileManager.addPostRenderer( renderer );
		globe.groundOverlayRenderer = renderer;
	}
	renderer.groundOverlays.push( this );
	
	this.globe = globe;
	
	this.computeTransform();
}

//*************************************************************************

/**
	Dtach layer from the globe
 */
GroundOverlayLayer.prototype._detach = function( globe )
{
	// Remove layer from the globe renderer for ground overlay
	var prevRenderer = this.globe.groundOverlayRenderer;
	if ( prevRenderer )
	{
		var index = prevRenderer.groundOverlays.indexOf( this );
		if ( index != - 1 )
		{
			prevRenderer.groundOverlays.splice(index,1);
			
			if ( prevRenderer.groundOverlays.length == 0 )
			{
				this.globe.tileManager.removePostRenderer( prevRenderer );
				this.globe.groundOverlayRenderer = null;
			}
		}
	}
}

//*************************************************************************

/**
	Transform a geographic position into the unit square of the ground overlay
 */
// GroundOverlayLayer.prototype.transformFromSquare = function( point )
// {
	// var x = this.transform[0] * point[0] + this.transform[3] * point[1] + this.transform[6];
	// var y = this.transform[1] * point[0] + this.transform[4] * point[1] + this.transform[7];
	// var w = 1.0 / (this.transform[2] * point[0] + this.transform[5] * point[1] + this.transform[8]);
	// x *= w;
	// y *= w;
	// return [ x, y ];
// }

//*************************************************************************

/**
	Transform from the unit square of the ground overlay into a unit square
 */
// GroundOverlayLayer.prototype.transformToSquare = function( point )
// {
	// var x = this.inverseTransform[0] * point[0] + this.inverseTransform[3] * point[1] + this.inverseTransform[6];
	// var y = this.inverseTransform[1] * point[0] + this.inverseTransform[4] * point[1] + this.inverseTransform[7];
	// var w = 1.0 / (this.inverseTransform[2] * point[0] + this.inverseTransform[5] * point[1] + this.inverseTransform[8]);
	// x *= w;
	// y *= w;
	// return [ x, y ];
// }

//*************************************************************************

/**
	Compute the inverse transform from unit square to geo position
	Code taken from QTransform
 */
GroundOverlayLayer.prototype.computeInverse = function()
{
    var det =  this.transform[0] * (this.transform[8] * this.transform[4] - this.transform[5] * this.transform[7]) -
        this.transform[3] * (this.transform[8] * this.transform[1] -  this.transform[7]) *  this.transform[3] 
			+  this.transform[6] * ( this.transform[5] * this.transform[1] - this.transform[4] * this.transform[2]);

    var h11, h12, h13,
        h21, h22, h23,
        h31, h32, h33;
    h11 = this.transform[4]*this.transform[8] - this.transform[5]*this.transform[7];
    h21 = this.transform[5]*this.transform[6] - this.transform[3]*this.transform[8];
    h31 = this.transform[3]*this.transform[7] - this.transform[4]*this.transform[6];
    h12 = this.transform[2]*this.transform[7] - this.transform[1]*this.transform[8];
    h22 = this.transform[0]*this.transform[8] - this.transform[2]*this.transform[6];
    h32 = this.transform[1]*this.transform[6] - this.transform[0]*this.transform[7];
    h13 = this.transform[1]*this.transform[5] - this.transform[2]*this.transform[4];
    h23 = this.transform[2]*this.transform[3] - this.transform[0]*this.transform[5];
    h33 = this.transform[0]*this.transform[4] - this.transform[1]*this.transform[3];

    this.inverseTransform = [ h11 / det, h12 / det, h13 / det,
							 h21 / det, h22 / det, h23 / det,
							 h31 / det, h32 / det, h33 / det ];
}

//*************************************************************************

/**
	Compute the transform from geo position to unit square
	Code taken from QTransform
 */
GroundOverlayLayer.prototype.computeTransform = function()
{	
	var q1 = this.quad[0];
	var q2 = this.quad[1]; 
	var q3 = this.quad[2]; 
	var q4 = this.quad[3];
	
	var tileConfig = this.globe.tileManager.tileConfig;
	if ( tileConfig.srs != 'EPSG:4326' ) {
		q1 = tileConfig.project(q1);
		q2 = tileConfig.project(q2);
		q3 = tileConfig.project(q3);
		q4 = tileConfig.project(q4);
	}
	
    var dx0 = q1[0];
    var dx1 = q2[0];
    var dx2 = q3[0];
    var dx3 = q4[0];

    var dy0 = q1[1];
    var dy1 = q2[1];
    var dy2 = q3[1];
    var dy3 = q4[1];

    var ax  = dx0 - dx1 + dx2 - dx3;
    var ay  = dy0 - dy1 + dy2 - dy3;
	
    if (!ax && !ay) { //afine transform
        this.transform = [ dx1 - dx0, dy1 - dy0,  0,
							dx2 - dx1, dy2 - dy1,  0,
							dx0,       dy0,  1 ];
    }
	else
	{
        var ax1 = dx1 - dx2;
        var ax2 = dx3 - dx2;
        var ay1 = dy1 - dy2;
        var ay2 = dy3 - dy2;

        /*determinants */
        var gtop    =  ax  * ay2 - ax2 * ay;
        var htop    =  ax1 * ay  - ax  * ay1;
        var bottom  =  ax1 * ay2 - ax2 * ay1;

        var a, b, c, d, e, f, g, h;  /*i is always 1*/

        if (!bottom)
            return;

        g = gtop/bottom;
        h = htop/bottom;

        a = dx1 - dx0 + g * dx1;
        b = dx3 - dx0 + h * dx3;
        c = dx0;
        d = dy1 - dy0 + g * dy1;
        e = dy3 - dy0 + h * dy3;
        f = dy0;

        this.transform = [ a, d, g,
                        b, e, h,
                        c, f, 1.0 ];
    }
	
	this.computeInverse();
}

//*************************************************************************;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/



/**************************************************************************************************************/

/** @export
	@constructor
	Mouse_navigationHandler constructor
	@param options Configuration properties for the Mouse_navigationHandler :
			<ul>
				<li>zoomOnDblClick : if true defines animation on double click</li>
			</ul>
 */
var MouseNavigationHandler = function(options){
	
	/**************************************************************************************************************/
	
	/**
 	 * Private variables
	 */
	 
	var _navigation = null;
	var _pressedButton = -1;
	var _lastMouseX = -1;
	var _lastMouseY = -1;
	var _dx = 0;
	var _dy = 0;
	var _panButton = (options && options.panButton) || 0;
	var _rotateButton = (options && options.rotateButton) || 1;

	/**************************************************************************************************************/
	
	/**
 	 * Private methods
	 */

	/**
		Event handler for mouse wheel
	 */
	var _handleMouseWheel = function(event)
	{	
		var factor;

		// Check differences between firefox and the rest of the world
		if ( event.wheelDelta === undefined)
		{
			factor = event.detail;
		}
		else
		{
			factor = -event.wheelDelta / 120.0;	
		}
		_navigation.zoom(factor);
		
		// Stop all animations when an event is received
		_navigation.stopAnimations();
		
		// Launch inertia if needed
		if ( _navigation.inertia )
		{
			_navigation.inertia.launch("zoom", factor < 0 ? -1 : 1 );
		}

		// Stop mouse wheel to be propagated, because default is to scroll the page
		// This is need when using Firefox event listener on DOMMouseScroll
		if ( event.preventDefault )
		{
			event.preventDefault();
		}
		event.returnValue = false;
					
		// Return false to stop mouse wheel to be propagated when using onmousewheel
		return false;
	};

	/**
	 * Event handler for mouse down
	 */
	var _handleMouseDown = function(event)
	{
		document.addEventListener("mouseup", _handleMouseUp);
		_pressedButton = event.button;
		
		// Stop all animations when an event is received
		_navigation.stopAnimations();

		if ( event.button == _panButton || event.button == _rotateButton )
		{		
			_lastMouseX = event.clientX;
			_lastMouseY = event.clientY;
			_dx = 0;
			_dy = 0;
						
			// Return false to stop mouse down to be propagated when using onmousedown
			return false;
		}
		
		return true;
	};

	/**
	 * Event handler for mouse up
	 */
	var _handleMouseUp = function(event)
	{
		// No button pressed anymore
		_pressedButton = -1;
		document.removeEventListener("mouseup", _handleMouseUp);

		if ( _navigation.inertia && (_dx != 0 || _dy != 0)  )
		{	
			if ( event.button == _panButton )
			{
				_navigation.inertia.launch("pan", _dx, _dy );
			
			}
			if ( event.button == _rotateButton )
			{
				_navigation.inertia.launch("rotate", _dx, _dy );
			}
		}

		if ( event.button == _panButton || event.button == _rotateButton )
		{
			event.preventDefault();
			
			// Stop mouse up event
			return false;
		}

		return true;
	};

	/**
		Event handler for mouse move
	*/
	var _handleMouseMove = function(event)
	{
		// No button pressed
		if (_pressedButton < 0)
			return;
		
		_dx = (event.clientX - _lastMouseX);
		_dy = (event.clientY - _lastMouseY);
		
		if ( _dx == 0 && _dy == 0 )
			return;
		
		var ret = false;
		// Pan
		if ( _pressedButton == _panButton )
		{
			_navigation.pan( _dx, _dy );
			ret = true;
		}
		// Rotate
		else if ( _pressedButton == _rotateButton )
		{
			_navigation.rotate(_dx,_dy);
			ret = true;
		}
		
		_lastMouseX = event.clientX;
		_lastMouseY = event.clientY;
		
		return ret;
	};

	/**
		Event handler for mouse double click
	 */
	var _handleMouseDblClick = function(event)
	{
		if (event.button == 0)
		{
			var pos = _navigation.globe.renderContext.getXYRelativeToCanvas(event);
			var geo = _navigation.globe.getLonLatFromPixel( pos[0], pos[1] );
		
			if (geo)
			{
				_navigation.zoomTo(geo);
			}
		}
	};

	/**************************************************************************************************************/
	
	 /**
	  * Public methods
	  */
			
	/** 
	 *	Setup the default event handlers for the _navigation
	 */
	this.install = function(nav)
	{
		_navigation = nav;
		
		var canvas = _navigation.renderContext.canvas;
		
		// Setup the mouse event handlers
		canvas.addEventListener("mousedown", _handleMouseDown);
		canvas.addEventListener("mousemove", _handleMouseMove);
		
		if ( options && options.zoomOnDblClick )
			canvas.addEventListener("dblclick", _handleMouseDblClick);
			
		// For Firefox
		canvas.addEventListener("DOMMouseScroll", _handleMouseWheel);
		canvas.addEventListener("mousewheel", _handleMouseWheel);
		
		// Fix for Google Chrome : avoid dragging
		// TODO : a hack, should be more robust (restore on uninstall?)
		canvas.addEventListener("dragstart", function(event){event.preventDefault(); return false;});

		if ( _rotateButton == 2 ) 
		{
			canvas.addEventListener("contextmenu", function(e) { e.preventDefault(); return false; }, false);
		}
	};

	/** 
	 *	Remove the default event handlers for the _navigation
	 */
	this.uninstall = function()
	{
		// Setup the mouse event handlers
		var canvas = _navigation.renderContext.canvas;

		canvas.removeEventListener("mousedown", _handleMouseDown);
		canvas.removeEventListener("mousemove", _handleMouseMove);
		
		if ( options && options.zoomOnDblClick )
			canvas.removeEventListener("dblclick", _handleMouseDblClick);
			
		// For Firefox
		canvas.removeEventListener("DOMMouseScroll", _handleMouseWheel);
		canvas.removeEventListener("mousewheel", _handleMouseWheel);
	};
};
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/



/**************************************************************************************************************/

/** @export
	@constructor
	KeyboardNavigationHandler constructor
	@param options Configuration properties for the KeyboardNavigationHandler :
			<ul>
				<li>panFactor  : Factor for panning within the scene</li>
				<li>zoomFactor : Factor for zooming into the scene</li>
				<li>installOnDocument : True to install the event listener on the document and not on the canvas</li>
			</ul>
 */
var KeyboardNavigationHandler = function(options){
	
	/**************************************************************************************************************/
	
	/**
 	 * Private variables
	 */
	var _navigation = null;
	var self = this;
	
	/**
	 * Public variables
	 */
	this.panFactor = 10.;
	this.zoomFactor = 1.;
	
	// Setup options
	if ( options )
	{
		if ( options['panFactor'] && typeof options['panFactor'] == 'number' )
			this.panFactor = options['panFactor'];
		if ( options['zoomFactor'] && typeof options['zoomFactor'] == 'number' )
			this.zoomFactor = options['zoomFactor'];
	}
	
	/**************************************************************************************************************/
	
	/**
 	 * Private methods
	 */

	/**
	 * Set focus
	 */
	var _setFocus = function(event)
	{
		this.focus();
		return false;
	};
	  
	/**
	 *	Event handler for key down
	 */
	var _handleKeyDown = function(event)
	{
		switch( event.keyCode ){
			case 32 :
				// space bar
				// Stop all animations when an event is received
				_navigation.stopAnimations();
				break;
			case 187 :
				// + on Safari
			case 61 :
				// +(=) on Firefox and Opera
			case 107 :
				// + on other
				_navigation.zoom(-self.zoomFactor);
				break;
			case 189 :
				// - on Safari
			case 54 :
				// -(6) on Firefox and Opera
			case 109 :
				// - on other
				_navigation.zoom(self.zoomFactor);
				break;
			case 81 :
				// q
			case 37 :
				// Left arrow
				if ( event.shiftKey )
				{
					_navigation.rotate( self.panFactor, 0 );
				}
				else
				{
					_navigation.pan( self.panFactor, 0 );
				}
				break;
			case 90 :
				// z
			case 38 :
				// Up arrow
				if ( event.shiftKey )
				{
					_navigation.rotate( 0, self.panFactor );
				}
				else
				{

					_navigation.pan( 0, self.panFactor );
				}
				break;
			case 68 :
				// d
			case 39 :
				// Right arrow
				if ( event.shiftKey )
				{
					_navigation.rotate( -self.panFactor, 0 );
				}
				else
				{
					_navigation.pan( -self.panFactor, 0 );
				}
				break;
			case 83 :
				// s
			case 40 :
				// Down arrow
				if ( event.shiftKey )
				{
					_navigation.rotate( 0, -self.panFactor );
				}
				else
				{

					_navigation.pan( 0, -self.panFactor );
				}
				break;
		}
	};

	/**************************************************************************************************************/
	
	 /**
	  * Public methods
	  */

	/** 
		Setup the default event handlers for the navigation
	 */
	this.install = function(navigation)
	{
		// Setup the keyboard event handlers
		_navigation = navigation;
		
		if ( options && options.installOnDocument )
		{
			document.addEventListener("keydown", _handleKeyDown);
		}
		else
		{
			var canvas = _navigation.renderContext.canvas;
			canvas.addEventListener("keydown", _handleKeyDown);
			// Setup focus handling to receive keyboard event on canvas
			canvas.tabIndex = "0";
			canvas.addEventListener("mousedown", _setFocus);
		}
	};

	/** 
		Remove the default event handlers for the navigation
	 */
	this.uninstall = function()
	{	
		if ( options && options.installOnDocument )
		{
			document.removeEventListener("keydown", _handleKeyDown);
		}
		else
		{
			var canvas = _navigation.renderContext.canvas;
			canvas.removeEventListener("keydown", _handleKeyDown);
			canvas.removeEventListener("mousedown", _setFocus);
		}
	};
	
};
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/



/**************************************************************************************************************/

/**
 *	Types of actions for inertia execution
 */
var Type = {
	PAN : 0,
	ROTATE : 1,
	TILT : 2,
	ZOOM : 3
};

/** @export
	@constructor
	TouchNavigationHandler constructor
	@param options Configuration properties for the TouchNavigationHandler :
			<ul>
				<li>inversed : if true inverse the sens of touching events</li>
				<li>zoomOnDblClick : if true defines animation on double click</li>
			</ul>
 */
var TouchNavigationHandler = function(options){

	/**************************************************************************************************************/
	
	/**
 	 * Private variables
	 */
	 
	var _navigation = null;
	var _lastFingerDistance;

	var _startTouches = [];
	var _lastTouches;
	var _lastAngle;

	var _dx, _dy;
	var _type;

	// Parameters for intertia management
	var _actionHits = [0, 0, 0, 0];
	var _lastTapDate;
	var _rotation;


	// Double tap
	var _doubletap_interval = 300;
	var _inversed = (options && options.hasOwnProperty('inversed')) ? options.inversed : false;

	/**************************************************************************************************************/
	
	/**
 	 * Private methods
	 */

	/**
	 * Calculate the angle between two coordinates
	 */
	var _getAngle = function(touch1, touch2) {
		var y = touch2.clientY - touch1.clientY,
			x = touch2.clientX - touch1.clientX;
		return Math.atan2(y, x) * 180 / Math.PI;
	};

	/**************************************************************************************************************/

	/**
	 * Calculate the rotation degrees between two touchLists (fingers)
	 */
	var _getRotation = function(start, end) {
		// Need two fingers
		if(start.length >= 2 && end.length >= 2) {
			return _getAngle(end[1], end[0]) - _getAngle(start[1], start[0]);
		}
		return 0;
    };

    /**************************************************************************************************************/

	/** 
	  Handle touch start event
	 */
	var _handleTouchStart = function(event)
	{
		//console.log("# events : " + event.touches.length );
		_lastTouches = event.touches;
		_startTouches = event.touches;
		
		_actionHits = [0, 0, 0, 0];

		// Stop all animations when an event is received
		_navigation.stopAnimations();
		_dx = 0;
		_dy = 0;
		if ( event.touches.length == 2 )
		{
			var dx = event.touches[0].clientX - event.touches[1].clientX;
			var dy = event.touches[0].clientY - event.touches[1].clientY;
			_lastFingerDistance = Math.sqrt( dx * dx + dy * dy );
			console.log("Finger distance : " + _lastFingerDistance );
			
			_lastAngle = _getRotation( _startTouches, event.touches );
		}
				
		if ( event.preventDefault )
		{
			event.preventDefault();
		}
		event.returnValue = false;

		// Return false to stop event to be propagated
		return false;
	};

	/**************************************************************************************************************/

	/** 
	  Handle touch move event
	 */
	var _handleTouchMove = function(event)
	{
		_dx = event.touches[0].clientX - _lastTouches[0].clientX;
		_dy = event.touches[0].clientY - _lastTouches[0].clientY;
		if ( event.touches.length == 1 )
		{	
			// Pan
	       	_navigation.pan(_dx, _dy);
	        _actionHits[Type.PAN]++;
		}
		else
		{
			// Depending on direction of two fingers, decide if tilt OR rotation
			var sameDirection = ( (event.touches[0].clientY - _lastTouches[0].clientY) * (event.touches[1].clientY - _lastTouches[1].clientY) > 0 );
			if ( sameDirection )
			{
				// Tilt
				_navigation.rotate(0., -_dy);
				_actionHits[Type.TILT]++;
			}
			else
			{
				// Rotation
				var rotation = _getRotation( _startTouches, event.touches );
				var dx = rotation - _lastAngle;
				_lastAngle = rotation;

				if ( _inversed )
				{
					dx *= -1;
				}
				
				_rotation = dx * 10;
				_navigation.rotate(_rotation, 0);
				_actionHits[Type.ROTATE]++;
			}

			// Zoom
			var dx = event.touches[0].clientX - event.touches[1].clientX;
			var dy = event.touches[0].clientY - event.touches[1].clientY;
			var fingerDistance = Math.sqrt( dx * dx + dy * dy );
			var deltaDistance = (fingerDistance - _lastFingerDistance);

			var scale;
			if ( _inversed )
			{
				scale = fingerDistance/_lastFingerDistance;
			}
			else
			{
				scale = _lastFingerDistance/fingerDistance;
			}

			if (_lastFingerDistance != 0)
			{
				_navigation.zoom( deltaDistance * 0.025, scale);
				_actionHits[Type.ZOOM]++;
			}
			_navigation.renderContext.requestFrame();
			_lastFingerDistance = fingerDistance;
		}

		// Update _lastTouches
		_lastTouches = event.touches;
		
		if ( event.preventDefault )
		{
			event.preventDefault();
		}
		event.returnValue = false;
		
		return false;
	};

	/**************************************************************************************************************/

	/** 
	  Handle touch end event
	 */
	var _handleTouchEnd = function(event)
	{	
		if ( options && options.zoomOnDblClick && event.touches.length == 0 && _dx == 0 && _dy == 0 )
		{
			// Handle double tap
			// TODO : take into account the distance
			var now = Date.now();
			if ( now - _lastTapDate < _doubletap_interval )
			{
				var geo = _navigation.globe.getLonLatFromPixel( _lastTouches[0].clientX, _lastTouches[0].clientY );
		
				if (geo)
				{
					_navigation.zoomTo(geo);
				}
			}
			_lastTapDate = now;
		}

		// Update last touches
		_lastTouches = event.touches;

		if ( _navigation.inertia && (_dx != 0 || _dy != 0) )
		{
			// Launch inertia depending on action hits while "moving" phase
			var hitIndex = _actionHits.indexOf( Math.max.apply(this,_actionHits) );
			if ( hitIndex == Type.PAN )
			{
				// Pan
				_navigation.inertia.launch("pan", _dx, _dy);
			}
			else if ( hitIndex == Type.ROTATE )
			{
				// Rotate
				//_navigation.inertia.launch("rotate", _rotation, 0);
			}
			else if ( hitIndex == Type.TILT )
			{
				// No inertia for tilt
			}
		}

		if ( event.preventDefault )
		{
			event.preventDefault();
		}
		event.returnValue = false;
		
		return false;
	};

	/**************************************************************************************************************/
	
	/**
	 * Public methods
	 */
			
	/** 
	 *	Setup the default event handlers for the _navigation
	 */
	this.install = function(nav)
	{
		_navigation = nav;
		
		// Setup the touch event handlers
		var canvas = _navigation.renderContext.canvas;
		
		canvas.addEventListener("touchstart", _handleTouchStart,false);
		canvas.addEventListener("touchend", _handleTouchEnd,false);
		canvas.addEventListener("touchmove", _handleTouchMove,false);
	};

	/** 
	 *	Remove the default event handlers for the _navigation
	 */
	this.uninstall = function()
	{
		// Setup the mouse event handlers
		var canvas = _navigation.renderContext.canvas;

		canvas.removeEventListener("touchstart", _handleTouchStart,false);
		canvas.removeEventListener("touchend", _handleTouchEnd,false);
		canvas.removeEventListener("touchmove", _handleTouchMove,false);
	};
};
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 
 
/**************************************************************************************************************/

/**	@constructor
	Base animation class
	Defines animation states (STOPPED, STARTED), animation base members
	and start() stop() functions.
*/
var Animation = function()
{
    this.startTime = -1;
	this.pauseTime = -1;
	this.renderContext = null;
}

/**************************************************************************************************************/

/**
  Unregister as active animation
*/
Animation.prototype._unregisterActive = function()
{
	var index = this.renderContext.activeAnimations.indexOf(this);
	if ( index >= 0 )
	{
		this.renderContext.activeAnimations.splice(index,1);
	}
}

/**************************************************************************************************************/

/**
  Get animation status
*/
Animation.prototype.getStatus = function()
{
	if ( this.startTime == -1 )
		return "STOPPED";
	else 
		return this.pauseTime == -1 ? "RUNNING" : "PAUSED";
}

/**************************************************************************************************************/

/** @export
	Start function, record the start time in startTime member
	and register the animation in the GlobWeb object.
*/
Animation.prototype.start = function()
{
	if ( !this.renderContext )
		return;
	
	if ( this.startTime == -1 || this.pauseTime != - 1 )
	{
 		var now = Date.now();
		if ( this.startTime == -1 )
		{
			this.startTime = now;
		}
		else
		{
			// resume after pause
			this.startTime += now - this.pauseTime;
			this.pauseTime = -1;
		}
		
		// Register animation as active
		this.renderContext.activeAnimations.push(this);
		this.renderContext.requestFrame();
	}
}

/**************************************************************************************************************/

/** @export
	Pause function
*/
Animation.prototype.pause = function()
{	
	if ( !this.renderContext )
		return;
		
	if ( this.startTime != -1 && this.pauseTime == -1 )
	{
		this.pauseTime = Date.now();
		this._unregisterActive(this);
	}
}

/**************************************************************************************************************/

/** @export
	Stop function, removes the animation from the GlobWeb object
*/
Animation.prototype.stop = function()
{
	this.startTime = -1;
	this.pauseTime = -1;
		
	if ( this.onstop )
		this.onstop();

    // Unregister animation
    this._unregisterActive(this);
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 
 
/**************************************************************************************************************/

var epsilon = 0.1;

/**	@constructor
 *	Animation simulating inertia for camera navigation
 *
 *	@param nav Navigation
 *	@param options Configuration of navigation
 *			<ul>
 *				<li>panFactor : Pan factor</li>
 *				<li>rotateFactor : Rotate factor</li>
 *				<li>zoomFactor : Zoom factor</li>
 *			</ul>
 */
var InertiaAnimation = function(nav, options)
{
    Animation.prototype.constructor.call(this);

    if ( options )
    {
		this.panFactor = options.hasOwnProperty('panFactor') ? options['panFactor'] : 0.95;
		this.rotateFactor = options.hasOwnProperty('rotateFactor') ? options['rotateFactor'] : 0.95;
		this.zoomFactor = options.hasOwnProperty('zoomFactor') ? options['zoomFactor'] : 0.95;
	}

	this.type = null;
	this.dx = 0;
	this.dy = 0;
	this.navigation = nav;
	this.renderContext = nav.renderContext;
}

/**************************************************************************************************************/

Utils.inherits(Animation,InertiaAnimation);

/**************************************************************************************************************/

/**
 * Update inertia
 */
InertiaAnimation.prototype.update = function(now)
{
	var hasToStop = false;
	
	switch(this.type)
	{
		case "pan":
			this.navigation.pan(this.dx,this.dy);
			this.dx *= this.panFactor;
			this.dy *= this.panFactor;
			hasToStop = (Math.abs(this.dx) < epsilon && Math.abs(this.dy) < epsilon);
			break;
		case "rotate":
			this.navigation.rotate(this.dx,this.dy);
			this.dx *= this.rotateFactor;
			this.dy *= this.rotateFactor;
			hasToStop = (Math.abs(this.dx) < epsilon && Math.abs(this.dy) < epsilon);
			break;
		case "zoom":
			this.navigation.zoom(this.dx);
			this.dx *= this.zoomFactor;
			hasToStop = (Math.abs(this.dx) < epsilon);
			break;
		default:
	}
	this.navigation.renderContext.requestFrame();

	if ( hasToStop )
		this.stop();
}

/**************************************************************************************************************/

/**
 *	@param type Type of inertia
 *				<ul>
 *					<li>pan</li>
 *					<li>rotate</li>
 *					<li>zoom</li>
 *				</ul>
 *	@param speed Starting speed
 *	@param {Int[]} inertiaVector Vector of mouvement in window coordinates(for pan and rotate inertias)
 */
InertiaAnimation.prototype.launch = function(type, dx, dy)
{
	// Set first value
 	this.type = type;
	this.dx = dx;
	this.dy = dy;

	this.start();
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 

/**************************************************************************************************************/

/** @constructor
  SegmentedAnimation is an animation defined with segments.
  Each segment has a [start,end] pair of 't' value and a [start,end] pair of
  values that will be interpolated with the interpolator set on the segment.
  When the animation runs, a t parameter is mapped to [0,1] according to
  current time and animation duration.
  The current segment is then looked up with that 't' value and used to interpolate
  the animation's current value.
 */
var SegmentedAnimation = function(duration, valueSetter)
{
    // Call ancestor constructor
    Animation.prototype.constructor.call(this);

    this.segments = [];
    this.duration = duration;
    this.valueSetter = valueSetter;
}

/**************************************************************************************************************/

Utils.inherits(Animation,SegmentedAnimation);

/**************************************************************************************************************/

/** @constructor
  Segment struct
*/
var Segment = function(start, startValue, end, endValue, interpolator)
{
    this.start = start;
    this.startValue = startValue;
    this.end = end;
    this.endValue = endValue;
    this.interpolator = interpolator;
}

/**************************************************************************************************************/

/*
	Adds a new segment to the animation.
	start, end are 't' values at which the segment will be the current segment
	startValue, endValue are animation values at 't'=start and 't'=end
	interpolator is the function that will be called to interpolate bewteen startValue and endValue.
*/
SegmentedAnimation.prototype.addSegment = function(start, startValue, end, endValue, interpolator)
{
    var count = this.segments.length;
    var index = 0;
    while (index < count && this.segments[index].end <= start) index++;
    // Insert new segment at position 'index'
    this.segments.splice(index, 0, new Segment(start, startValue, end, endValue, interpolator));
}

/**************************************************************************************************************/

/*
	Animation update method
*/
SegmentedAnimation.prototype.update = function(now)
{
    var t = Numeric.map01(now, this.startTime, this.startTime + this.duration);
    if (t >= 1)
    {
		 // Set last value
		var lastIndex = this.segments.length - 1;
		this.valueSetter(this.segments[lastIndex].endValue);
		this.stop();
    }
	else
	{
		// Find current segment
		var count = this.segments.length;
		var index = 0;
		while (index < count && this.segments[index].end < t) index++;
		index = Math.min(index, count-1);
		
		// Remap t between segment bounds
		t = Numeric.map01(t, this.segments[index].start, this.segments[index].end);
		// Interpolate value
		var value = this.segments[index].interpolator(t, this.segments[index].startValue, this.segments[index].endValue);
		// Use value
		this.valueSetter(value);
	}
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/



/**************************************************************************************************************/

/** @name BaseNavigation
	@constructor
	Base class for navigation object

	@param renderContext Render context
	@param options Configuration options
		<ul>
			<li>handlers : Array of objects defining navigation events for different supports(mouse, keyboard..)</li>
			<li>inertia : Boolean for inertia effect</li>
			<li>panFactor : Pan factor</li>
			<li>rotateFactor : Rotate factor</li>
			<li>zoomFactor : Zoom factor</li>
			<li>isMobile : Boolean indicating if navigation supports touch events</li>
		</ul>

 */
var BaseNavigation = function(renderContext, options)
{
	Event.prototype.constructor.call( this );
	
	this.renderContext = renderContext;

	// Create default handlers if none are created in options
	if ( options && options.handlers ) 
	{
		this.handlers = options.handlers;
	}
	else
	{
		// Use mouse & keyboard as default handlers if isMobile isn't defined
		if ( options && options.isMobile )
		{
			this.handlers = [ new TouchNavigationHandler(options ? options.touch : null) ];	
		}
		else
		{
			this.handlers = [ new MouseNavigationHandler(options ? options.mouse : null), new KeyboardNavigationHandler(options ? options.keyboard : null) ];
		}
	}
	
	// Inertia effect
	if( options && options.inertia )
	{
		this.inertia = new InertiaAnimation(this, options);
	}
	// ZoomTo animation
	this.zoomToAnimation = null;

	// Automatically start
	this.start();
}

/**************************************************************************************************************/

Utils.inherits( Event, BaseNavigation );

/**************************************************************************************************************/

/** @export
	Start the navigation
*/
BaseNavigation.prototype.start = function()
{
	// Install handlers
	for (var i=0; i<this.handlers.length; i++)
	{
		this.handlers[i].install(this);
	}
}

/**************************************************************************************************************/

/** @export
	Stop the navigation
*/
BaseNavigation.prototype.stop = function()
{
	// Uninstall handlers
	for (var i=0; i<this.handlers.length; i++)
	{
		this.handlers[i].uninstall();
	}
}

/**************************************************************************************************************/

/** @export
	Stop the animations running on the navigation
*/
BaseNavigation.prototype.stopAnimations = function()
{
	if ( this.inertia )
	{
		this.inertia.stop();
	}
	if( this.zoomToAnimation )
	{
		this.zoomToAnimation.stop();
		this.zoomToAnimation = null;
	}
}

/**************************************************************************************************************/

/** @export
	Get the field of view used by the navigation
	
	@return {Float[]} Fovx and fovy in degrees
*/
BaseNavigation.prototype.getFov = function()
{
	var aspect = this.renderContext.canvas.width / this.renderContext.canvas.height;
	return [ aspect * this.renderContext.fov, this.renderContext.fov ];
}

/**************************************************************************************************************/

/**
	Basic animation from current view matrix to the given one
	@param {Array[16]} mat Destination view matrix
	@param {Int} fov Final zooming fov in degrees
	@param {Int} duration Duration of animation in milliseconds
	@param {Function} callback Callback on the end of animation
 */
BaseNavigation.prototype.toViewMatrix = function(mat, fov, duration, callback)
{
	var navigation = this;
	var vm = this.renderContext.viewMatrix;

	var srcViewMatrix = mat4.toMat3( vm );
	var srcQuat = quat4.fromRotationMatrix( srcViewMatrix );
	var destViewMatrix = mat4.toMat3( mat );
	var destQuat = quat4.fromRotationMatrix( destViewMatrix );	
	var destFov = fov || 45;
	duration = duration || 1000;

	// Animate rotation matrix(with quaternion support), tranlation and fov
	var startValue = [srcQuat, [vm[12], vm[13], vm[14]], navigation.renderContext.fov];
	var endValue = [destQuat, [mat[12],mat[13],mat[14]], destFov];
	var animation = new SegmentedAnimation(
		duration,
		// Value setter
		function(value) {
			// Update rotation matrix
			var newRotationMatrix = quat4.toMat4(value[0]);
			// Need to transpose the new rotation matrix due to bug in glMatrix
			navigation.renderContext.viewMatrix = mat4.transpose(newRotationMatrix);

			// Update translation
			navigation.renderContext.viewMatrix[12] = value[1][0];
		    navigation.renderContext.viewMatrix[13] = value[1][1];
		    navigation.renderContext.viewMatrix[14] = value[1][2];

		    // Update fov
		    navigation.renderContext.fov = value[2];

			navigation.renderContext.requestFrame();
		});

	// Add segment
	animation.addSegment(
		0.0, startValue,
		1.0, endValue,
		function(t, a, b) {
			var pt = Numeric.easeOutQuad(t);
			var resQuat = quat4.create();
			quat4.slerp(a[0], b[0], pt, resQuat);

			var resTranslate = vec3.create();
			vec3.lerp(a[1], b[1], pt, resTranslate);
			
			var resFov = Numeric.lerp(pt, a[2], b[2]);
			return [resQuat,		// quaternions
					resTranslate,	// translate
					resFov]; 		// fov
		}
	);

	animation.onstop = function() {
		if ( callback )
		{
			callback();
		}
	}

	this.globe.addAnimation(animation);
	animation.start();
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 

/**************************************************************************************************************/

/** @name Navigation
	@class
	Manages the navigation in the Globe.
	@augments BaseNavigation
	
	@param globe Globe
	@param options Configuration properties for the Navigation :
		<ul>
			<li>minDistance : The minimum distance</li>
			<li>maxDistance : The maximum distance</li>
            <li>zoomDuration : The duration of zoom in ms</li>
			<li>updateViewMatrix : Boolean indicating if view matrix must be updated on initialization</li>
		</ul>
 */
var Navigation = function(globe,options)
{
	BaseNavigation.prototype.constructor.call( this, globe.renderContext, options );

	this.globe = globe;
		
	// Default values for min and max distance (in meter)
	this.minDistance = (options && options.minDistance) || 1.0;
	this.maxDistance = (options && options.maxDistance) || 3.0 * this.globe.coordinateSystem.realEarthRadius;
	
	// Initialize the navigation
	this.geoCenter = [0.0, 0.0, 0.0];
	this.heading = 0.0;
	this.tilt = 90.0;
	this.distance = 3.0 * this.globe.coordinateSystem.radius;
    this.zoomDuration = (options && options.zoomDuration) ? options.zoomDuration : 5000;
		
	// Scale min and max distance from meter to internal ratio
	this.minDistance *= this.globe.coordinateSystem.heightScale;
	this.maxDistance *= this.globe.coordinateSystem.heightScale;

	this.inverseViewMatrix = mat4.create();

	var updateViewMatrix = (options && options.hasOwnProperty('updateViewMatrix') ? options.updateViewMatrix : true);
	// Update the view matrix if needed(true by default)
	if ( updateViewMatrix )
	{
		this.computeViewMatrix();
	}
}

/**************************************************************************************************************/

Utils.inherits( BaseNavigation,Navigation );

/**************************************************************************************************************/

/** 
	Save the current navigation state.
	@return a JS object containing the navigation state
*/
Navigation.prototype.save = function()
{
	return {
		geoCenter: this.geoCenter,
		heading: this.heading,
		tilt: this.tilt,
		distance: this.distance
	};
}

/**************************************************************************************************************/

/** 
	Restore the navigation state.
	@param state a JS object containing the navigation state
*/
Navigation.prototype.restore = function(state)
{
	this.geoCenter = state.geoCenter;
	this.heading = state.heading;
	this.tilt = state.tilt;
	this.distance = state.distance;
	this.computeViewMatrix();
}

/**************************************************************************************************************/

/** 
	Zoom to a 3d position
	@param {Float[]} geoPos Array of two floats corresponding to final Longitude and Latitude(in this order) to zoom
	@param {Int} distance Final zooming distance in meters
	@param {Int} duration Duration of animation in milliseconds
	@param {Int} tilt Defines the tilt in the end of animation
	@param {Function} callback Callback on the end of animation
*/
Navigation.prototype.zoomTo = function(geoPos, distance, duration, tilt, callback )
{
	var navigation = this;
	
	var destDistance = distance || this.distance / (4.0 * this.globe.coordinateSystem.heightScale);
	duration = duration || this.zoomDuration;
	var destTilt = tilt || 90;
	
	// Create a single animation to animate geoCenter, distance and tilt
	var startValue = [this.geoCenter[0], this.geoCenter[1], this.distance, this.tilt];
	var endValue = [geoPos[0], geoPos[1], destDistance * this.globe.coordinateSystem.heightScale, destTilt];
	this.zoomToAnimation = new SegmentedAnimation(
		duration,
		// Value setter
		function(value) {
			navigation.geoCenter[0] = value[0];
			navigation.geoCenter[1] = value[1];
			navigation.distance = value[2];
			navigation.tilt = value[3];
			navigation.computeViewMatrix();
		});

	// Compute a max altitude for the animation
	var worldStart = this.globe.coordinateSystem.fromGeoTo3D(this.geoCenter);
	var worldEnd   = this.globe.coordinateSystem.fromGeoTo3D(geoPos);
	var vec = vec3.subtract(worldStart, worldEnd);
	var len = vec3.length(vec);
	var canvas = this.globe.renderContext.canvas;
	var minFov = Math.min(Numeric.toRadian(45.0),
				Numeric.toRadian(45.0 * canvas.width / canvas.height));
	var maxAltitude = 1.1 * ((len / 2.0) / Math.tan(minFov / 2.0));
	if (maxAltitude > this.distance)
	{
		// Compute the middle value
		var midValue = [startValue[0]*0.5 + endValue[0]*0.5,
				startValue[1]*0.5 + endValue[1]*0.5,
				maxAltitude, destTilt];

		// Add two segments
		this.zoomToAnimation.addSegment(
		0.0, startValue,
		0.5, midValue,
		function(t, a, b) {
			var pt = Numeric.easeInQuad(t);
			var dt = Numeric.easeOutQuad(t);
			return [Numeric.lerp(pt, a[0], b[0]), // geoPos.long
				Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
				Numeric.lerp(dt, a[2], b[2]), // distance
				Numeric.lerp(t, a[3], b[3])]; // tilt
		});

		this.zoomToAnimation.addSegment(
		0.5, midValue,
		1.0, endValue,
		function(t, a, b) {
			var pt = Numeric.easeOutQuad(t);
			var dt = Numeric.easeInQuad(t);
			return [Numeric.lerp(pt, a[0], b[0]), // geoPos.long
				Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
				Numeric.lerp(dt, a[2], b[2]), // distance
				Numeric.lerp(t, a[3], b[3])]; // tilt
		});
	}
	else
	{
		// Add only one segments
		this.zoomToAnimation.addSegment(
		0.0, startValue,
		1.0, endValue,
		function(t, a, b) {
			var pt = Numeric.easeOutQuad(t);
			var dt = Numeric.easeInQuad(t);
			return [Numeric.lerp(pt, a[0], b[0]),  // geoPos.long
				Numeric.lerp(pt, a[1], b[1]),  // geoPos.lat
				Numeric.lerp(dt, a[2], b[2]),  // distance
				Numeric.lerp(t, a[3], b[3])]; // tilt
		});
	}

	var self = this;
	this.zoomToAnimation.onstop = function() {
		if ( callback )
		{
			callback();
		}
		self.zoomToAnimation = null;
	}

	this.globe.addAnimation(this.zoomToAnimation);
	this.zoomToAnimation.start();
}

/**************************************************************************************************************/

/**
	Compute the inverse view matrix
 */
Navigation.prototype.applyLocalRotation = function(matrix)
{
	mat4.rotate( matrix, (this.heading) * Math.PI / 180.0, [ 0.0, 0.0, 1.0 ] );
	mat4.rotate( matrix, (90 - this.tilt) * Math.PI / 180.0, [ 1.0, 0.0, 0.0 ] );
}

/**************************************************************************************************************/

/**
	Compute the view matrix
 */
Navigation.prototype.computeViewMatrix = function()
{
    this.computeInverseViewMatrix();
	mat4.inverse( this.inverseViewMatrix, this.renderContext.viewMatrix );
	this.publish("modified");
	this.renderContext.requestFrame();
}

/**************************************************************************************************************/

/**
	Compute the inverse view matrix
 */
Navigation.prototype.computeInverseViewMatrix = function()
{
    this.globe.coordinateSystem.getLHVTransform(this.geoCenter, this.inverseViewMatrix);
	this.applyLocalRotation(this.inverseViewMatrix);
	mat4.translate( this.inverseViewMatrix, [0.0, 0.0, this.distance] );
}

/**************************************************************************************************************/

/**
	Zoom to the current observed location
	@param delta Delta zoom
 */
Navigation.prototype.zoom = function(delta,scale)
{
	var previousDistance = this.distance;
	
	// TODO : improve zoom, using scale or delta ? We should use scale always
	if (scale)
		this.distance *= scale;
	else
		this.distance *= (1 + delta * 0.1);
		
	if ( this.distance > this.maxDistance )
	{
		this.distance = this.maxDistance;
	}
	if ( this.distance < this.minDistance )
	{
		this.distance = this.minDistance;
	}

	this.computeViewMatrix();
	
	if ( this.hasCollision() )
	{
		this.distance = previousDistance;
		this.computeViewMatrix();
	}
}

/**************************************************************************************************************/

/**
	Check for collision
 */
Navigation.prototype.hasCollision = function()
{
	var eye = [ this.inverseViewMatrix[12], this.inverseViewMatrix[13], this.inverseViewMatrix[14] ];
	var geoEye = vec3.create();
	this.globe.coordinateSystem.from3DToGeo(eye, geoEye);
	var elevation = this.globe.getElevation( geoEye[0], geoEye[1] );
	
	return geoEye[2] < elevation + 50;
}

/**************************************************************************************************************/

/**
	Pan the navigation
	@param dx Window delta x
	@param dy Window delta y
*/
Navigation.prototype.pan = function(dx, dy)
{
	var previousGeoCenter = vec3.create();
	vec3.set( this.geoCenter, previousGeoCenter );
	
	// Get geographic frame
	var local2World = mat4.create();
	var coordinateSystem = this.globe.coordinateSystem;
	coordinateSystem.getLocalTransform(this.geoCenter, local2World);
	// Then corresponding vertical axis and north
	var z = vec3.create(); var previousNorth = vec3.create([0.0, 1.0, 0.0]);
	coordinateSystem.getUpVector( local2World, z );
	//coordinateSystem.getFrontVector( local2World, previousNorth );
	mat4.multiplyVec3(local2World, previousNorth, previousNorth);
	
	// Then apply local transform
	this.applyLocalRotation(local2World);
	// Retrieve corresponding axes
	var x = vec3.create(); var y = vec3.create();
	coordinateSystem.getSideVector( local2World, x );
	coordinateSystem.getFrontVector( local2World, y );
	// According to our local configuration, up is y and side is x
	
	// Compute direction axes
	vec3.cross(z, x, y);
	vec3.cross(y, z, x);
	vec3.normalize(x, x);
	vec3.normalize(y, y);
	
	//Normalize dx and dy
	dx = dx / this.renderContext.canvas.width;
	dy = dy / this.renderContext.canvas.height;
	
	// Move accordingly
	var position = vec3.create();
	coordinateSystem.fromGeoTo3D(this.geoCenter, position);
	vec3.scale(x, dx * this.distance, x);
	vec3.scale(y, dy * this.distance, y);
	vec3.subtract(position, x, position);
	vec3.add(position, y, position);
	
	// Clamp onto sphere
	vec3.normalize(position);
	vec3.scale(position, coordinateSystem.radius);
	
	// Update geographic center
	coordinateSystem.from3DToGeo(position, this.geoCenter);

	// Compute new north axis
	var newNorth = vec3.create([0.0, 1.0, 0.0]);
	coordinateSystem.getLocalTransform(this.geoCenter, local2World);
	mat4.multiplyVec3(local2World, newNorth, newNorth);
	
	// Take care if we traverse the pole, ie the north is inverted
	if ( vec3.dot(previousNorth, newNorth) < 0 )
	{
		this.heading = (this.heading + 180.0) % 360.0;
	}
		
	// Check for collision with terrain
	this.computeViewMatrix();
	
	if ( this.hasCollision() )
	{
		this.geoCenter = previousGeoCenter;
		this.computeViewMatrix();
	}
}

/**************************************************************************************************************/

/**
	Rotate the navigation
	@param dx Window delta x
	@param dy Window delta y
 */
Navigation.prototype.rotate = function(dx,dy)
{
	var previousHeading = this.heading;
	var previousTilt = this.tilt;
	
	this.heading += dx * 0.1;
	this.tilt += dy * 0.1;
	
	this.computeViewMatrix();

	if ( this.hasCollision() )
	{
		this.heading = previousHeading;
		this.tilt = previousTilt;
		this.computeViewMatrix();
	}
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 
 
/**************************************************************************************************************/

/** 
	@name Stats
	@class
	Display some rendering statistics in a HTML element
	@param options Configuration properties for Stats.
		<ul>
			<li>element : the HTML element to receivce statistcs, can be a string (the ID) or the DOM element itself</li>
			<li>verbose : the verbosity of the stats, default is false</li>
		</ul>
 */
var Stats = function(renderContext,options)
{
	renderContext.stats = this;
	this.renderContext = renderContext;
	
	var elt = options ? options['element'] : undefined;
	if ( elt )
	{	
		if (typeof elt == "string") 
		{
			this.element = document.getElementById(elt);
		}
		else
		{
			this.element = elt;
		}
	}
	
	this.showFPS = this.renderContext.continuousRendering;
	this.verbose = options && options['verbose'] ? options['verbose'] : false;
	this.numFrames = 0;
	
	var self = this;
	window.setInterval( function() { self.print(); }, 1000 );
}

/**************************************************************************************************************/

/** 
	Start measuring time
 */
Stats.prototype.start = function(name)
{
	this[name] = Date.now();
}

/**************************************************************************************************************/

/** 
	End measuring time
 */
Stats.prototype.end = function(name)
{
	var time = Date.now() - this[name];
	
	var max = this["max_"+name] || -1; 
	if (max < time) max = time;
	
	var sum = this["sum_"+name] || 0; 
	sum += time;
	
	this[name] = time;
	this["max_"+name] = max;
	this["sum_"+name] = sum;
	
	if ( name == "globalRenderTime" )
	{
		this.numFrames++;
	}
}

/**************************************************************************************************************/

/** 
	Print stats in an HTML element
 */
Stats.prototype.print = function()
{
	if ( this.numFrames > 0 )
	{
		var content = "";
		
		if ( this.showFPS )
		{
			content += "FPS : " + this.numFrames + "<br>";
		}
		
		content += "Average render time : " + (this["sum_globalRenderTime"] / this.numFrames).toFixed(2) + " ms";
		// FIXME: currently count stats for the first renderer in render context
		if ( this.renderContext.renderers[0].getRenderStats )
			content += "<br>" + this.renderContext.renderers[0].getRenderStats();
		
		if ( this.verbose )
		{
			content += "<br>Average traverse tiles time : " + (this["sum_traverseTime"] / this.numFrames).toFixed(2) + " ms";
			content += "<br>Average render tiles time : " + (this["sum_renderTime"] / this.numFrames).toFixed(2) + " ms";
			content += "<br>Average generate tiles time : " + (this["sum_generateTime"] / this.numFrames).toFixed(2) + " ms";
			content += "<br>Average request tiles time : " + (this["sum_requestTime"] / this.numFrames).toFixed(2) + " ms";
			content += "<br>Max render time : " + this["max_globalRenderTime"] + " ms";
			content += "<br>Max traverse tiles time : " + this["max_traverseTime"] + " ms";
			content += "<br>Max render tiles time : " + this["max_renderTime"] + " ms";
			content += "<br>Max generate tiles time : " + this["max_generateTime"]  + " ms";
			content += "<br>Max request tiles time : " + this["max_requestTime"] + " ms";
		}
		
		this.element.innerHTML = content;
		
		this["sum_globalRenderTime"] = 0;
		this["sum_traverseTime"] = 0;
		this["sum_renderTime"] = 0;
		this["sum_generateTime"] = 0;
		this["sum_requestTime"] = 0;
		this["max_globalRenderTime"] = 0;
		this["max_traverseTime"] = 0;
		this["max_renderTime"] = 0;
		this["max_generateTime"] = 0;
		this["max_requestTime"] = 0;
		this.numFrames = 0;
	}
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/



/**************************************************************************************************************/

/** @constructor
	KMLParser constructor
 */
var KMLParser = (function()
{
	var featureCollection = { type: "FeatureCollection",
				features: [] };
				
	var styles = {};
	
	var parseColor = /^(\w{2})(\w{2})(\w{2})(\w{2})$/;
	
	/*
	 * Parse a color string
	 * @param color_string : the color string
	 * @return the color
	 */
	var fromStringToColor = function(color_string)
	{
		var match = parseColor.exec(color_string);
		if ( match )
		{
			return [ parseInt(match[4],16) / 255.0, parseInt(match[3],16) / 255.0, parseInt(match[2],16) / 255.0, parseInt(match[1],16) / 255.0 ];
		}
		
		return [ 1., 1., 1., 1. ];
	};
		
	/*
	 * Parse coordinates, split them and return an array of coordinates in GeoJSON format
	 * @param coordsText : the text node value for coordinates
	 */
	var parseCoordinates = function(coordsText)
	{
		var coordinates = [];
		// Trim the coordinates, then split them
		var coords = coordsText.trim().split(/[\s,]+/);
		for ( var i = 0; i < coords.length; i += 3 )
		{
			coordinates.push( [ parseFloat(coords[i]), parseFloat(coords[i+1]), parseFloat(coords[i+2]) ] );
		}
		return coordinates;
	};
	
	/*
	 * Parse KML geometry, return a GeoJSON geometry
	 * @param node : a candiate node for geoemtry
	 */
	var checkAndParseGeometry = function(node,style)
	{
		switch ( node.nodeName )
		{
			case "MultiGeometry":
			{
				var geoms = [];
				
				var children = node.childNodes;
				for (var i = 0; i < children.length; i++)
				{
					var geometry = checkAndParseGeometry(children[i],style);
					if ( geometry )
					{
						geoms.push( geometry );
					}
				}
				
				return 	{ type: "GeometryCollection", geometries: geoms };
			}
			break;
			case "LineString":
			{
				var coordNode = node.getElementsByTagName("coordinates");
				if ( coordNode.length == 1 )
				{
					return { type: "LineString",
							coordinates: parseCoordinates( coordNode[0].textContent ) };
				}
			}
			break;
			case "Polygon":
			{
				// Take into accout extresion
				var extrude = node.getElementsByTagName("extrude");
				if ( extrude.length == 1 )
				{
					style.extrude = parseInt( extrude[0].childNodes[0].nodeValue ) != 0;
				}
				
				// TODO : check how to manage fill property
				if ( style ) {
					style.fill = true;
				}
				
				// TODO : manage holes
				var outerBoundary = node.getElementsByTagName("outerBoundaryIs");
				var coordNode = outerBoundary[0].getElementsByTagName("coordinates");
				if ( coordNode.length == 1 )
				{
					return { type: "Polygon",
							coordinates: [ parseCoordinates( coordNode[0].textContent ) ] };
				}
			}
			break;
			case "Point":
			{
				var coordNode = node.getElementsByTagName("coordinates");
				if ( coordNode.length == 1 )
				{
					var coord = coordNode[0].textContent.split(",");
					return { type: "Point",
							coordinates: [ parseFloat(coord[0]), parseFloat(coord[1]) ] };
				}
			}
			break;
		}
	
		return null;
	}
	
	/*
	 * Parse placemark
	 */
	var parsePlacemark = function(node)
	{
		// Create a feature
		var feature = { type: "Feature",
					properties: {},
					geometry: null };
		
		var shareStyle = false;
		var child = node.firstElementChild;
		while ( child )
		{
			switch ( child.nodeName )
			{
			case "name":
				feature.properties.name = child.childNodes[0].nodeValue;
				break;
			case "styleUrl":
				{
					var id = child.childNodes[0].nodeValue;
					if ( styles.hasOwnProperty(id) ) 
					{
						feature.properties.style = styles[id];
						shareStyle = true;
					}
				}
				break;
			case "Style":
				{
					var style = parseStyle(child,feature.properties.name,feature.properties.style);
					if ( style )
					{
						feature.properties.style = style;
					}
				}
				break;
			default:
				// Try with geometry
				if ( feature.geometry == null )
				{
					feature.geometry = checkAndParseGeometry(child,style);
				}
			}
			child = child.nextElementSibling;
		}
		
		if ( feature.geometry )
		{
			// Manage the fact that labels are always active with KML
			var style = feature.properties.style;
			if ( style && style.textColor[3] > 0.0 && feature.geometry.type == "Point" )
			{
				if ( shareStyle )
				{
					style = feature.properties.style = new FeatureStyle(style);
				}
				style.label = feature.properties.name;
			}
			
			featureCollection.features.push( feature );
		}
	}
		
	/*
	 * Parse Document or folder
	 */
	var parseDocumentOrFolder = function(node)
	{
		var child = node.firstElementChild;
		while ( child )
		{
			switch ( child.nodeName )
			{
			case "visibility":
				var vis = parseInt(child.textContent);
				if ( vis == 0 )
					return;
				break;
			case "Style":
				parseStyle(child);
				break;
			default:
				checkAndParseFeature(child);
			}
			child = child.nextElementSibling;
		}
	}
	
	/*
	 * Parse poly style
	 */
	var parsePolyStyle = function(node,style)
	{
		var child = node.firstElementChild;
		while ( child )
		{
			switch ( child.nodeName )
			{
			case "color":
				style.fillColor = fromStringToColor( child.childNodes[0].nodeValue );
				break;
			}
			child = child.nextElementSibling;
		}
	}
	
	/*
	 * Parse line style
	 */
	var parseLineStyle = function(node,style)
	{
		var child = node.firstElementChild;
		while ( child )
		{
			switch ( child.nodeName )
			{
			case "color":
				style.strokeColor = fromStringToColor( child.childNodes[0].nodeValue );
				break;
			case "width":
				style.strokeWidth = parseFloat( child.childNodes[0].nodeValue );
				break;
			}
			child = child.nextElementSibling;
		}
	}
	
	/*
	 * Parse icon style
	 */
	var parseIconStyle = function(node,style)
	{
		var child = node.firstElementChild;
		while ( child )
		{
			switch ( child.nodeName )
			{
			case "color":
				//style.strokeColor = fromStringToColor( child.childNodes[0].nodeValue );
				break;
			case "Icon":
				if ( child.firstElementChild )
					style.iconUrl = child.firstElementChild.childNodes[0].nodeValue;
				else
					style.iconUrl = null;
				break;
			}
			child = child.nextElementSibling;
		}
	}

	/*
	 * Parse label style
	 */
	var parseLabelStyle = function(node,style)
	{
		var child = node.firstElementChild;
		while ( child )
		{
			switch ( child.nodeName )
			{
			case "color":
				var labelColor = fromStringToColor( child.textContent.trim() );
				if ( labelColor[3] == 0 )
				{
					style.label = null;
					style.textColor = labelColor;
				}
				break;
			/*case "Icon":
				if ( child.firstElementChild )
					style.iconUrl = child.firstElementChild.childNodes[0].nodeValue;
				else
					style.iconUrl = null;
				break;*/
			}
			child = child.nextElementSibling;
		}
	}
		
	/*
	 * Parse style
	 */
	var parseStyle = function(node,parentStyle)
	{
		var id = '#' + node.getAttribute("id");

		var style = new FeatureStyle(parentStyle);
		styles[id] = style;
		
		// Iterate through child to manage all different style element
		var child = node.firstElementChild;
		while ( child )
		{
			switch ( child.nodeName )
			{
			case "PolyStyle":
				parsePolyStyle(child,style);
				break;
			case "LineStyle":
				parseLineStyle(child,style);
				break;
			case "IconStyle":
				parseIconStyle(child,style);
				break;
			case "LabelStyle":
				parseLabelStyle(child,style);
				break;
			}
			child = child.nextElementSibling;
		}
			
		return style;
	}
	
	/*
	 * Parse feature
	 */
	var checkAndParseFeature = function(node)
	{
		switch ( node.nodeName )
		{
		case "Style":
			parseStyle( node );
			break;
		case "Placemark":
			parsePlacemark( node );
			break;
		case "Document":
		case "Folder":
			parseDocumentOrFolder( node );
			break;
		}
	}
	
	/*
	 * Parse a KML document
	 */
	var parse = function(doc)
	{
		var root = doc.documentElement;
		var child = root.firstElementChild;
		while ( child )
		{
			checkAndParseFeature(child);
			child = child.nextElementSibling;
		}
		
		return featureCollection;
	}
	
	return { parse: parse };
})();
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 

/**************************************************************************************************************/

/** @export
	@constructor
  PathAnimation is an animation defined with a path.
 *	@param options Configuration of the animation
 *			<ul>
 *				<li>coords : the path coordinates</li>
 *				<li>speed : the speed value </li>
 *				<li>setter : the function used to set the value</li>
 *				<li>globe : the globe to clamp path animations on the terrain</li>
 *			</ul>
 */
var PathAnimation = function(options)
{
    // Call ancestor constructor
    Animation.prototype.constructor.call(this);
    this.globe = options.globe;
    this.speed = options.speed * this.globe.coordinateSystem.heightScale / 1000;
	this.nodes = [];
	for ( var i = 0; i < options.coords.length; i++ )
	{
		var node = {
			position: this.globe.coordinateSystem.fromGeoTo3D(options.coords[i]),
			velocity: null,
			distance: 0.0
		};
		this.nodes.push( node );
		if ( i > 0 )
		{
			var dx = this.nodes[i].position[0] - this.nodes[i-1].position[0];
			var dy = this.nodes[i].position[1] - this.nodes[i-1].position[1];
			var dz = this.nodes[i].position[2] - this.nodes[i-1].position[2];
			this.nodes[i-1].distance = Math.sqrt( dx*dx + dy*dy + dz*dz );
		}
	}
	
	for ( var i = 1; i <  options.coords.length - 1; i++ )
	{
		var vec1 = vec3.subtract( this.nodes[i+1].position, this.nodes[i].position, vec3.create() );
		var vec2 = vec3.subtract( this.nodes[i-1].position, this.nodes[i].position, vec3.create() );
		vec3.normalize(vec1);
		vec3.normalize(vec2);
		this.nodes[i].velocity = vec3.subtract( vec1, vec2, vec3.create() );
		vec3.normalize(this.nodes[i].velocity);
	}
	
	// Start velocity
	var temp = vec3.subtract( this.nodes[1].position, this.nodes[0].position, vec3.create() );
	vec3.scale( temp, ( 3 / this.nodes[0].distance ) );
	this.nodes[0].velocity = vec3.subtract( temp, this.nodes[1].velocity, vec3.create() );
	vec3.scale( this.nodes[0].velocity, 0.5 );
	
	// End velocity
	var i = options.coords.length - 1;
	var temp = vec3.subtract( this.nodes[i].position, this.nodes[i-1].position, vec3.create() );
	vec3.scale( temp, ( 3 / this.nodes[i-1].distance ) );
	this.nodes[i].velocity = vec3.subtract( temp, this.nodes[i-1].velocity, vec3.create() );
	vec3.scale( this.nodes[i].velocity, 0.5 );

	this.index = 0;
	this.currentDistance = 0;
	this.previousTime = -1;
	this.currentDirection = [];
	this.centerOffset = -0.2;
	this.altitudeOffset = 1000;
	
	var that = this;
	if ( options.setter )
	{
		this.valueSetter = options.setter;
	}
	else
	{
		this.valueSetter = function(value,direction)
		{				
			var up = vec3.normalize( value, vec3.create() );
			
			var eye;
			if ( options.globe )
			{
				var geoEye = options.globe.coordinateSystem.from3DToGeo( value );
				geoEye[2] = options.globe.getElevation( geoEye[0], geoEye[1] ) + that.altitudeOffset;
				eye =  options.globe.coordinateSystem.fromGeoTo3D( geoEye );
			}
			else
			{
				eye = value;
				eye[2] += that.altitudeOffset;;
			}
				
			var dirn = vec3.normalize( direction, vec3.create() );
			var center = vec3.add( eye, dirn, vec3.create() );
			vec3.add( center, vec3.scale(up, that.centerOffset, vec3.create()) );
			mat4.lookAt( eye, center, up, that.renderContext.viewMatrix );
		};
	}
}

/**************************************************************************************************************/

Utils.inherits(Animation,PathAnimation);

/**************************************************************************************************************/

/**
	Set the speed
 */
PathAnimation.prototype.setSpeed = function(val)
{
    this.speed = parseFloat(val) * this.globe.coordinateSystem.heightScale / 1000;
}

/**************************************************************************************************************/

/**
	Set the altitude offset
 */
PathAnimation.prototype.setAltitudeOffset = function(val)
{
	this.altitudeOffset = parseFloat(val);
}

/**************************************************************************************************************/

/**
	Set the direction angle
 */
PathAnimation.prototype.setDirectionAngle = function(vertical)
{
	this.centerOffset = Math.tan( parseFloat(vertical) * Math.PI / 180.0 );
}

/**************************************************************************************************************/

/** @export
	Start the animation
 */
PathAnimation.prototype.start = function()
{
	var previousStartTime = -1;
	if ( this.pauseTime != -1 )
	{
		previousStartTime = this.startTime;
	}

    Animation.prototype.start.call(this);
	
	if ( previousStartTime != -1 )
	{
		this.previousTime += this.startTime - previousStartTime;
	}
	else
	{
		this.previousTime = -1;
	}
}

/**************************************************************************************************************/

/*
	Animation update method
*/
PathAnimation.prototype.update = function(now)
{
	if ( this.previousTime == -1 )
	{
		this.index = 0;
		this.currentDistance = 0;
	}
	else
	{
		this.currentDistance += (now - this.previousTime) * this.speed;
	}
	this.previousTime = now;

	while ( this.currentDistance >= this.nodes[this.index].distance && this.index < this.nodes.length - 1 )
	{
		this.currentDistance -= this.nodes[this.index].distance;
		this.index = this.index + 1;
	}
	
	if ( this.index < this.nodes.length - 1 )
	{
		var t = this.currentDistance / this.nodes[this.index].distance;
		var startPos = this.nodes[this.index].position;
		var endPos = this.nodes[this.index+1].position;
		var startVel = vec3.scale( this.nodes[this.index].velocity, this.nodes[this.index].distance, vec3.create() );
		var endVel = vec3.scale( this.nodes[this.index+1].velocity, this.nodes[this.index].distance, vec3.create() );
		var position = Numeric.cubicInterpolation( t, startPos, startVel, endPos, endVel );
		var direction = Numeric.cubicInterpolationDerivative( t, startPos, startVel, endPos, endVel );
		this.valueSetter( position, direction );
	}
	else if ( this.index == this.nodes.length - 1 )
	{
		this.valueSetter( this.nodes[this.index].position, this.nodes[this.index].velocity );
	}
	else
	{
		this.stop();
	}
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 

/**************************************************************************************************************/

/** 
 * 	@class Manage the attributions
	@constructor
	Function constructor for AttributionHandler
	
	@param globe
	@param options Configuration properties
		<ul>
			<li>element : the HTML element to show attributions, can be a string (the ID) or the DOM element itself</li>
		</ul>
*/

var AttributionHandler = function(globe, options)
{
	globe.attributionHandler = this;

	var elt = options ? options['element'] : undefined;
	if ( elt )
	{	
		if (typeof elt == "string") 
		{
			this.element = document.getElementById(elt);
		}
		else
		{
			this.element = elt;
		}
	}
}

/**************************************************************************************************************/

/**
* 	Remove attribution from HTML
* 	@param layer Selected layer
*/
AttributionHandler.prototype.removeAttribution = function( layer )
{
	var div = document.getElementById( this.element.id+"_"+layer.id );
	if ( div )
		this.element.removeChild( div );
}

/**************************************************************************************************************/

/**
* 	Add attribution in HTML
* 	@param layer Selected layer
*/
AttributionHandler.prototype.addAttribution = function(layer)
{ 
	var div = document.createElement('div');
	div.innerHTML = layer.attribution;
	div.id = this.element.id + "_" + layer.id;
	
	if(layer.id == 0)
	{
		// Background layer
		this.element.insertBefore( div, this.element.firstChild );
	}
	else
	{
		this.element.appendChild( div );
	}
}

/**************************************************************************************************************/

/**
*	Toggle attribution
* 	@param layer Selected layer
*/
AttributionHandler.prototype.toggleAttribution = function(layer)
{
	var div = document.getElementById(this.element.id+"_"+layer.id);
	if ( div )
	{
		this.removeAttribution(layer);
	}
	else
	{
		this.addAttribution(layer);
	}
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/



/**************************************************************************************************************/

/** @constructor
	VectorRenderer constructor
 */
var VectorRenderer = function(globe)
{
	this.tileManager = globe.tileManager;
	this.globe = globe;
	this.buckets = [];
	this.maxTilePerGeometry = 100;
	this.levelZeroTiledGeometries = [];
}

/**************************************************************************************************************/

/**
	Find a compatible bucket
 */
VectorRenderer.prototype.findBucket = function(layer,style)
{
	// Find an existing bucket for the given style
	for ( var i = 0; i < this.buckets.length; i++ )
	{
		var bucket = this.buckets[i];
		if ( bucket.layer == layer 
			&& bucket.isCompatible(style) )
		{
			return bucket;
		}
	}

	return null;
}


/**************************************************************************************************************/

/**
 	Generate the level zero for a tile
 */
VectorRenderer.prototype.generateLevelZero = function(tile)
{
	for ( var i=0; i < this.levelZeroTiledGeometries.length; i++ )
	{
		var geometry = this.levelZeroTiledGeometries[i];
		
		// Check that the geometry is on this tile
		var isFound = false;
		for ( var n = 0; n < geometry._tileIndices.length && !isFound; n++ )
		{
			var t = this.tileManager.level0Tiles[ geometry._tileIndices[n] ];
			isFound = ( t == tile );
		}
		
		// Found the tile, so add it
		if ( isFound )
		{
			this._addGeometryToTile(geometry._bucket, geometry, tile);
		}
	}
}

/**************************************************************************************************************/

/**
 	Recursively add a geometry to a tile
*/
VectorRenderer.prototype._recursiveAddGeometryToTile = function(bucket, geometry, tile)
{
	var renderable = this._addGeometryToTile(bucket, geometry, tile);
	
	if ( renderable && renderable.generateChild && tile.children)
	{
		for ( var i = 0; i < 4; i++ )
		{
			if ( tile.children[i].state == Tile.State.LOADED )
			{
				renderable.hasChildren = true;
				this._recursiveAddGeometryToTile( bucket, geometry, tile.children[i] );
			}
		}
	}
}

/**************************************************************************************************************/

/**
 	Add a geometry to a vector renderer
 */
VectorRenderer.prototype.addGeometry = function(layer, geometry, style)
{
	var bucket = this.getOrCreateBucket(layer, geometry, style);
	geometry._bucket = bucket;
	
	var tileIndices = this.maxTilePerGeometry > 0 ? this.tileManager.tiling.getOverlappedLevelZeroTiles(geometry) : null;
	if ( tileIndices && tileIndices.length < this.maxTilePerGeometry )
	{
		// Add geometry to each tile in range
		for ( var i=0; i < tileIndices.length; i++ )
		{
			var tile = this.tileManager.level0Tiles[ tileIndices[i] ];
			if ( tile.state == Tile.State.LOADED )
			{
				this._recursiveAddGeometryToTile(bucket, geometry, tile);
			}
		}
		
		geometry._tileIndices = tileIndices;
		this.levelZeroTiledGeometries.push(geometry);
	}
	else
	{
		// Attach to mainRenderable
		if (!bucket.mainRenderable)
		{
			bucket.mainRenderable = bucket.createRenderable();
		}
		bucket.mainRenderable.add(geometry);
	}
}

/**************************************************************************************************************/

/**
 	Remove a geometry from a vector renderer
 */
VectorRenderer.prototype.removeGeometry = function(geometry)
{
	var tileIndices = geometry._tileIndices;

	if ( tileIndices )
	{
		// Remove from tile
		for ( var i = 0; i < tileIndices.length; i++ )
		{
			var tile = this.tileManager.level0Tiles[ tileIndices[i] ];
			this.removeGeometryFromTile(geometry, tile);
		}
		// Remove from geometry arrays
		this.levelZeroTiledGeometries.splice( this.levelZeroTiledGeometries.indexOf(geometry), 1 );
		
		 geometry._tileIndices = null;
	}
	else
	{
		var bucket = geometry._bucket;
		if ( bucket.mainRenderable )
		{
			var numGeometries = bucket.mainRenderable.remove(geometry);
			if ( numGeometries == 0 )
			{
				bucket.mainRenderable.dispose(this.renderContext);
				bucket.mainRenderable = null;
			}
		}
	}
}

/**************************************************************************************************************/

/**
 	Get or create a bucket for the given configuration
 */
VectorRenderer.prototype.getOrCreateBucket = function(layer, geometry, style )
{		
	// Then find an existing bucket
	var bucket = this.findBucket(layer,style);
	if (!bucket)
	{
		bucket = this.createBucket(layer,style);
		bucket.renderer = this;
		bucket.id = this.globe.vectorRendererManager.bucketId++;
		this.buckets.push( bucket );
	}
	return bucket;
}

/**************************************************************************************************************/

/**
	Add a geometry to a tile
 */
VectorRenderer.prototype.addGeometryToTile = function(layer, geometry, style, tile)
{
	var bucket = this.getOrCreateBucket(layer, geometry, style);
	geometry._bucket = bucket;
	return this._addGeometryToTile( bucket, geometry, tile );
}
	
/**************************************************************************************************************/

/**
	Internal method to add a geometry to a tile
 */
VectorRenderer.prototype._addGeometryToTile = function(bucket, geometry, tile)
{	
	var tileData = tile.extension.renderer;
	if (!tileData)
	{
		tileData = tile.extension.renderer = new RendererTileData(this.globe.vectorRendererManager);
	}
	
	var renderable = tileData.getRenderable(bucket);
	var needsToAdd = false;
	if (!renderable) 
	{
		renderable = bucket.createRenderable();
		needsToAdd = true;
	}
	
	if ( renderable.add(geometry, tile) )
	{
		if (needsToAdd)
		{
			tileData.renderables.push(renderable);
		}
		return renderable;
	}
	
	return null;
}

/**************************************************************************************************************/

/**
	Remove a geometry from a tile
 */
VectorRenderer.prototype.removeGeometryFromTile = function(geometry,tile)
{
	var tileData = tile.extension.renderer;
	if (tileData)
	{
		var i = 0;
		while ( i < tileData.renderables.length )
		{
			var renderable = tileData.renderables[i];
			var renderer = renderable.bucket.renderer;
			if ( renderer == this )
			{
				// Remove renderable
				var numGeometries = renderable.remove(geometry);
				if ( numGeometries == 0 )
				{
					tileData.renderables.splice(i,1);
				}
				else
				{
					i++;
				}
	
				// Remove geoemtry from children if needed
				if ( renderable.hasChildren && tile.children)
				{
					for ( var n = 0; n < 4; n++ )
					{
						if ( tile.children[n].state == Tile.State.LOADED )
						{
							this.removeGeometryFromTile( geometry, tile.children[n] );
						}
					}
				}
			}
			else
			{
				i++;
			}
		}
	}
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 

/**************************************************************************************************************/

/** @constructor
	Basic module to generate texture from text
 */	
var Text = (function()
{
	var fontSize = 18;
	var margin = 1;
	var canvas2d = null;
	
	var initialize = function()
	{
		canvas2d = document.createElement("canvas");
		canvas2d.width = 512;
		canvas2d.height = fontSize  + 2 * margin;
	}
	
	var generateImageData = function(text, textColor)
	{
		if (!canvas2d)
			initialize();
		
		var fillColor = textColor;
		if (!fillColor)
			fillColor = '#fff';
		else if ( fillColor instanceof Array )
			fillColor = FeatureStyle.fromColorToString(textColor);
		
		var ctx = canvas2d.getContext("2d");
		ctx.clearRect(0,0,canvas2d.width,canvas2d.height);
		ctx.fillStyle = fillColor;
		ctx.font = fontSize + 'px sans-serif';
		ctx.textBaseline = 'top';
		ctx.shadowColor = '#000';
		ctx.shadowOffsetX = 1;
		ctx.shadowOffsetY = 1;
		ctx.shadowBlur = 2;
		ctx.fillText(text, margin, margin);
		//ctx.lineWidth = 1.0;
		//ctx.strokeText(text, margin, margin);
		
		var metrics = ctx.measureText(text);
		return ctx.getImageData(0,0, Math.floor(metrics.width)+2*margin,canvas2d.height)
	}
	
	
	return { generateImageData: generateImageData };
})();

/**************************************************************************************************************/

/** @constructor
	POI Renderer constructor
 */
var PointRenderer = function(globe)
{
	VectorRenderer.prototype.constructor.call( this, globe );

	// Store object for rendering
	this.renderContext = globe.tileManager.renderContext;
	this.tileConfig = globe.tileManager.tileConfig;
	
	// For stats
	this.numberOfRenderPoints = 0;
 	
	var vertexShader = "\
	attribute vec3 vertex; // vertex have z = 0, spans in x,y from -0.5 to 0.5 \n\
	uniform mat4 viewProjectionMatrix; \n\
	uniform vec3 poiPosition; // world position \n\
	uniform vec2 poiScale; // x,y scale \n\
	uniform vec2 tst; \n\
	\n\
	varying vec2 texCoord; \n\
	\n\
	void main(void)  \n\
	{ \n\
		// Generate texture coordinates, input vertex goes from -0.5 to 0.5 (on x,y) \n\
		texCoord = vertex.xy + vec2(0.5) + tst; \n\
		// Invert y \n\
		texCoord.y = 1.0 - texCoord.y; \n\
		\n\
		// Compute poi position in clip coordinate \n\
		gl_Position = viewProjectionMatrix * vec4(poiPosition, 1.0); \n\
		gl_Position.xy += vertex.xy * gl_Position.w * poiScale; \n\
	} \n\
	";
	
	var fragmentShader = "\
	precision lowp float; \n\
	varying vec2 texCoord; \n\
	uniform sampler2D texture; \n\
	uniform float alpha; \n\
	uniform vec3 color; \n\
	\n\
	void main(void) \n\
	{ \n\
		vec4 textureColor = texture2D(texture, texCoord); \n\
		gl_FragColor = vec4(textureColor.rgb * color, textureColor.a * alpha); \n\
		if (gl_FragColor.a <= 0.0) discard; \n\
	} \n\
	";

    this.program = new Program(this.renderContext);
    this.program.createFromSource(vertexShader, fragmentShader);

	var vertices = new Float32Array([-0.5, -0.5, 0.0,
                     0.5,  -0.5, 0.0,
                     0.5,  0.5, 0.0,
                     -0.5, 0.5, 0.0]);
					 
	var gl = this.renderContext.gl;
	this.vertexBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

	this.defaultTexture = null;
}

Utils.inherits(VectorRenderer,PointRenderer);

/**************************************************************************************************************/

/*
	Build a default texture
 */
PointRenderer.prototype._buildDefaultTexture = function(bucket)
{  	
	if ( !this.defaultTexture )
	{
		var gl = this.renderContext.gl;
		this.defaultTexture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, this.defaultTexture);
		var whitePixel = new Uint8Array([255, 255, 255, 255]);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, whitePixel);
	}

	bucket.texture = this.defaultTexture;
	bucket.textureWidth = 10;
	bucket.textureHeight = 10;
}

/**************************************************************************************************************/

/*
	Build a texture from an image and store in a bucket
 */
PointRenderer.prototype._buildTextureFromImage = function(bucket,image)
{  	
	bucket.texture = this.renderContext.createNonPowerOfTwoTextureFromImage(image);
	bucket.textureWidth = image.width;
	bucket.textureHeight = image.height;
}

/**************************************************************************************************************/

/**
 * Renderable constructor for Point
 */
var PointRenderable = function(bucket) 
{
	this.bucket = bucket;
	this.points = [];
}

/**************************************************************************************************************/

/**
 * Add a geometry to the renderable
 * @return if the geometry has been successfully added to the renderable
 */
PointRenderable.prototype.add = function(geometry)
{
	var posGeo = geometry['coordinates'];
	// TODO: Find a better way to access to coordinate system
	var pos3d = this.bucket.layer.globe.coordinateSystem.fromGeoTo3D( posGeo );
	var vertical = vec3.create();
	vec3.normalize(pos3d, vertical);

	this.points.push({
		pos3d: pos3d,
		vertical: vertical,
		geometry: geometry
	});
	
	// Always add the geometry
	return true;
}

/**************************************************************************************************************/

/**
 * Remove a geometry from the renderable
 */
PointRenderable.prototype.remove = function(geometry)
{
	for ( var j = 0; j < this.points.length; j++ )
	{
		if ( this.points[j].geometry == geometry )
		{
			this.points.splice( j, 1 );
			return this.points.length;
		}
	}
	return this.points.length;
}

/**************************************************************************************************************/

/**
 * Dispose the renderable
 */
PointRenderable.prototype.dispose = function(renderContext)
{
	// Nothing to do
}


/**************************************************************************************************************/

/**
	Bucket constructor for PointRenderer
 */
var PointBucket = function(layer,style)
{
	this.layer = layer;
	this.style = new FeatureStyle(style);
	this.renderer = null;
	this.texture = null;
}

/**************************************************************************************************************/

/**
	Create a renderable for this bucket
 */
PointBucket.prototype.createRenderable = function()
{
	return new PointRenderable(this);
}

/**************************************************************************************************************/

/**
	Check if a bucket is compatible
 */
PointBucket.prototype.isCompatible = function(style)
{
	return this.style.iconUrl == style.iconUrl
		&& this.style.icon == style.icon
		&& this.style.label == style.label;
}

/**************************************************************************************************************/

/**
	Create bucket to render a point
 */
PointRenderer.prototype.createBucket = function(layer,style)
{
	// Create a bucket
	var bucket = new PointBucket(layer,style);
	
	// Initialize bucket : create the texture	
	if ( style['label'] )
	{
		var imageData = Text.generateImageData(style['label'], style['textColor']);
		this._buildTextureFromImage(bucket,imageData);
	}
	else if ( style['iconUrl'] )
	{
		var image = new Image();
		image.crossOrigin = '';
		var self = this;
		image.onload = function() {self._buildTextureFromImage(bucket,image); self.renderContext.requestFrame(); }
		image.onerror = function() { self._buildDefaultTexture(bucket); }
		image.src = style.iconUrl;
	}
	else if ( style['icon'] )
	{
		this._buildTextureFromImage(bucket,style.icon);
	}
	else
	{
		this._buildDefaultTexture(bucket);
	}
		
	return bucket;
}

/**************************************************************************************************************/

/*
	Render all the POIs
 */
PointRenderer.prototype.render = function(renderables,start,end)
{
	this.numberOfRenderPoints = 0;
	
	var renderContext = this.renderContext;
	var gl = this.renderContext.gl;
	
	// Setup states
	// gl.disable(gl.DEPTH_TEST);
	gl.enable(gl.BLEND);
	gl.blendEquation(gl.FUNC_ADD);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

	// Setup program
	this.program.apply();
	
	// The shader only needs the viewProjection matrix, use modelViewMatrix as a temporary storage
	mat4.multiply(renderContext.projectionMatrix, renderContext.viewMatrix, renderContext.modelViewMatrix)
	gl.uniformMatrix4fv(this.program.uniforms["viewProjectionMatrix"], false, renderContext.modelViewMatrix);
	gl.uniform1i(this.program.uniforms["texture"], 0);

	// Compute eye direction from inverse view matrix
	mat4.inverse(renderContext.viewMatrix, renderContext.modelViewMatrix);
	var camZ = [renderContext.modelViewMatrix[8], renderContext.modelViewMatrix[9], renderContext.modelViewMatrix[10]];
	vec3.normalize(camZ);
	vec3.scale(camZ, this.tileConfig.cullSign, camZ);
	
	// Compute pixel size vector to offset the points from the earth
	var pixelSizeVector = renderContext.computePixelSizeVector();
	
	// Warning : use quoted strings to access properties of the attributes, to work correclty in advanced mode with closure compiler
	gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
	gl.vertexAttribPointer(this.program.attributes['vertex'], 3, gl.FLOAT, false, 0, 0);

	var currentBucket = null;
	for ( var n = start; n < end; n++ )
	{
		var renderable = renderables[n];
		var bucket = renderable.bucket;
		
		if ( renderable.points.length == 0 )
			continue;
			
		if ( bucket != currentBucket )
		{
			// Bind point texture
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, bucket.texture);

			// 2.0 * because normalized device coordinates goes from -1 to 1
			var scale = [2.0 * bucket.textureWidth / renderContext.canvas.width,
						 2.0 * bucket.textureHeight / renderContext.canvas.height];
			gl.uniform2fv(this.program.uniforms["poiScale"], scale);
			gl.uniform2fv(this.program.uniforms["tst"], [ 0.5 / (bucket.textureWidth), 0.5 / (bucket.textureHeight)  ]);
		}
		
		for ( var i = 0; i < renderable.points.length; i++ )
		{	
			// Poi culling
			var worldPoi = renderable.points[i].pos3d;
			var poiVec = renderable.points[i].vertical;
			var scale = bucket.textureHeight * ( pixelSizeVector[0] * worldPoi[0] + pixelSizeVector[1] * worldPoi[1] + pixelSizeVector[2] * worldPoi[2] + pixelSizeVector[3] );
			scale *= this.tileConfig.cullSign;
			var scaleInKm = (scale / this.globe.coordinateSystem.heightScale) * 0.001;
			if ( scaleInKm > bucket.style.pointMaxSize )
				continue;
				
			if ( vec3.dot(poiVec, camZ) > 0 
				&& renderContext.worldFrustum.containsSphere(worldPoi,scale) >= 0 )
			{
				var x = poiVec[0] * scale + worldPoi[0];
				var y = poiVec[1] * scale + worldPoi[1];
				var z = poiVec[2] * scale + worldPoi[2];
				
				gl.uniform3f(this.program.uniforms["poiPosition"], x, y, z);
				gl.uniform1f(this.program.uniforms["alpha"], bucket.layer._opacity);
				var color = bucket.style.fillColor;
				gl.uniform3f(this.program.uniforms["color"], color[0], color[1], color[2] );
				
				gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
				
				this.numberOfRenderPoints++;
			}
		}
	}

//    gl.enable(gl.DEPTH_TEST);
    gl.disable(gl.BLEND);
}

/**************************************************************************************************************/

/**
 * Check if renderer is applicable
 */
PointRenderer.prototype.canApply = function(type,style)
{
	return type == "Point";
}

/**************************************************************************************************************/

// Register the renderer
VectorRendererManager.factory.push( function(globe) { return new PointRenderer(globe); } );
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 

/**************************************************************************************************************/


/** @constructor
 *	BatchRenderable constructor
 */
var BatchRenderable = function( bucket )
{
	this.bucket = bucket;
 	this.vertexBuffer = null;
 	this.indexBuffer = null;
	this.vertices = [];
	this.triIndices = [];
	this.lineIndices = [];
	this.geometryInfos = [];
	this.bufferDirty = true;
	this.vertexSize = 3;
	this.indexType = 0;
	this.vertexBufferShared = false;
}

/**************************************************************************************************************/

/**
 *	Remove a geometry from the renderable
 */
BatchRenderable.prototype.remove = function( geometry )
{
	var fiIndex = -1;

	// Find the feature
	var vertexIt = 0;
	var lineIndexIt = 0;
	var triIndexIt = 0;
	for ( var i = 0; i < this.geometryInfos.length; i++ )
	{
		var fi = this.geometryInfos[i];
		if ( fi.geometry == geometry )
		{
			// Remove feature from vertex and index buffer
			this.vertices.splice( vertexIt, fi.vertexCount );
			this.lineIndices.splice( lineIndexIt, fi.lineIndexCount );
			this.triIndices.splice( triIndexIt, fi.triIndexCount );
		
			// Update index buffer
			var vertexOffset = fi.vertexCount / this.vertexSize;
			for ( var n = lineIndexIt; n < this.lineIndices.length; n++ )
			{
				this.lineIndices[n] -= vertexOffset;
			}
			for ( var n = triIndexIt; n < this.triIndices.length; n++ )
			{
				this.triIndices[n] -= vertexOffset;
			}			
			fiIndex = i;
			
			break;
		}
		
		vertexIt += fi.vertexCount;
		lineIndexIt += fi.lineIndexCount;
		triIndexIt += fi.triIndexCount;
	}
	
	if ( fiIndex >= 0 )
	{
		this.bufferDirty = true;
					
		// Remove the feature from the infos array
		this.geometryInfos.splice( fiIndex, 1 );
				
		return this.vertices.length;
	}
	else
	{
		return this.vertices.length;
	}	
}

/**************************************************************************************************************/

/**
 *	Add a feature to the renderable
 */
BatchRenderable.prototype.add = function( geometry, tile )
{
	this.tile = tile;

	// Store previous number of vertices/indices needed for "after-build" computation
	var numVertices = this.vertices.length;
	var numLineIndices = this.lineIndices.length;
	var numTriIndices = this.triIndices.length;

	var geometryInTile = this.build( geometry, tile );
	if ( geometryInTile )
	{
		this.geometryInfos.push({
			geometry: geometry,
			vertexCount: this.vertices.length - numVertices,
			lineIndexCount: this.lineIndices.length - numLineIndices,
			triIndexCount: this.triIndices.length - numTriIndices
		});
		this.bufferDirty = true;
				
		return true;
	}
	else
	{
		// Feature not in the tile
		return false;
	}
}

/**************************************************************************************************************/

/**
 *	Dispose graphics data 
 */
BatchRenderable.prototype.dispose = function(renderContext)
{
	var gl = renderContext.gl;
	
	if ( this.indexBuffer )
		gl.deleteBuffer(this.indexBuffer);
	this.indexBuffer = null;
	if ( this.vertexBuffer && !this.vertexBufferShared)
	{
		gl.deleteBuffer(this.vertexBuffer);
		this.vertexBuffer = null;
	}
}

/**************************************************************************************************************/

/**
 *	Must be call before rendering
 */
BatchRenderable.prototype.bindBuffers = function(renderContext)
{
	var gl = renderContext.gl;
	
	if ( this.bufferDirty )
	{
		this.dispose(renderContext);

		// Create vertex buffer if needed
		if (this.vertexBuffer)
		{
			gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
		}
		else
		{
			this.vertexBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array( this.vertices ), gl.STATIC_DRAW);	
		}

		// Create index buffer
		this.indexBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
		
		var indices = this.triIndices;
		if ( this.triIndices.length > 0  )
		{
			if (this.lineIndices.length > 0)
				indices = this.triIndices.concat(this.lineIndices);
			else
				indices = this.triIndices;
		}
		else
		{
			indices = this.lineIndices;
		}
		
		var vertexCount = this.vertices.length / this.vertexSize;
		if ( vertexCount > 65535 )
		{
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array( indices ), gl.STATIC_DRAW);
			this.indexType = gl.UNSIGNED_INT;
		}
		else
		{
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array( indices ), gl.STATIC_DRAW);
			this.indexType = gl.UNSIGNED_SHORT;
		}
		this.bufferDirty = false;
	}
	else
	{
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
	}
}


/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 

/**************************************************************************************************************/


/** @constructor
 *	TiledVectorRenderable constructor
 */
var TiledVectorRenderable = function( bucket )
{
	BatchRenderable.prototype.constructor.call( this, bucket );

	this.tile = null;
	// The tiled vector renderable always has a children
	this.hasChildren = true;
}

/**************************************************************************************************************/

Utils.inherits(BatchRenderable,TiledVectorRenderable);

/**************************************************************************************************************/

/**
 * Initialize a child renderable
 */
TiledVectorRenderable.prototype.initChild = function(i,j)
{				
	var child = new TiledVectorRenderable(this.bucket);
	child.tile = this.tile;
	child.vertexBufferShared = true;
	child.vertexBuffer = this.vertexBuffer;
	child.vertices = this.vertices;
	child.buildChildrenIndices(this,j*2 + i);
	return child;
}

/**************************************************************************************************************/

/**
 * Generate a child renderable
 */
TiledVectorRenderable.prototype.generateChild = function(tile)
{				
	for ( var j = 0; j < this.geometryInfos.length; j++ )
	{
		this.bucket.renderer._addGeometryToTile( this.bucket, this.geometryInfos[j].geometry, tile );
	}
}

/**************************************************************************************************************/

/**
 * Build children indices.
 * Children indices are used to render a tile children when it is not completely loaded.
 */
TiledVectorRenderable.prototype.buildChildrenIndices = function( parent, index )
{	
	for ( var n = 0;  n < parent.triIndices.length; n+=3 )
	{	
		var vertexOffset1 = 3 * parent.triIndices[n];
		var vertexOffset2 = 3 * parent.triIndices[n+1];
		var vertexOffset3 = 3 * parent.triIndices[n+2];
		
		var x1 = parent.vertices[vertexOffset1];
		var x2 = parent.vertices[vertexOffset2];
		var x3 = parent.vertices[vertexOffset3];
		
		var i = 0;
		if ( x1 > 0 ||  ( x1 == 0 && x2 > 0 ) || (x1 == 0 && x2 == 0 && x3 > 0) )
			i = 1;			
		
		var y1 = parent.vertices[vertexOffset1+1];
		var y2 = parent.vertices[vertexOffset2+1];
		var y3 = parent.vertices[vertexOffset3+1];
		
		var j = 1;
		if ( y1 > 0 ||  ( y1 == 0 && y2 > 0 ) || (y1 == 0 && y2 == 0 && y3 > 0) )
			j = 0;
		
		if ( index == 2*j + i )
		{
			this.triIndices.push( parent.triIndices[n], parent.triIndices[n+1], parent.triIndices[n+2] )
		}
	}
	for ( var n = 0;  n < parent.lineIndices.length/2; n++ )
	{	
		var vertexOffset1 = 3 * parent.lineIndices[2*n];
		var vertexOffset2 = 3 * parent.lineIndices[2*n+1];
		
		var x1 = parent.vertices[vertexOffset1];
		var x2 = parent.vertices[vertexOffset2];
		
		var i = 0;
		if ( x1 > 0 ||  ( x1 == 0 && x2 > 0 ) )
			i = 1;			
		
		var y1 = parent.vertices[vertexOffset1+1];
		var y2 = parent.vertices[vertexOffset2+1];
		
		var j = 1;
		if ( y1 > 0 ||  ( y1 == 0 && y2 > 0 ) )
			j = 0;
		
		if ( index == 2*j + i )
		{
			this.lineIndices.push( parent.lineIndices[2*n], parent.lineIndices[2*n+1] );
		}
	}
}


/**************************************************************************************************************/

/**
 *	Add a feature to the renderable
 *	@return	Boolean indicating if geometry intersects the given tile
 */
TiledVectorRenderable.prototype.build = function( geometry, tile )
{
	this.tile = tile;
	var tileInRange = this.bucket.layer.minLevel <= tile.level && this.bucket.layer.maxLevel > tile.level;
	if ( tileInRange )
	{
		var coords = geometry['coordinates'];
		switch (geometry['type'])
		{
			case "LineString":
				this.buildVerticesAndIndices( tile, coords );
				break;
			case "Polygon":
				for ( var i = 0; i < coords.length; i++ )
					this.buildVerticesAndIndices( tile, coords[i] );
				break;
			case "MultiLineString":
				for ( var i = 0; i < coords.length; i++ )
					this.buildVerticesAndIndices( tile, coords[i] );
				break;
			case "MultiPolygon":
				for ( var j = 0; j < coords.length; j++ )
					for ( var i = 0; i < coords[j].length; i++ )
						this.buildVerticesAndIndices( tile, coords[j][i] );
				break;
		}
	}
	return tile.geoBound.intersectsGeometry(geometry);
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 

/**************************************************************************************************************/


/** @constructor
	TiledVectorRenderer constructor
 */
var TiledVectorRenderer = function(globe)
{
	VectorRenderer.prototype.constructor.call( this, globe );
	
	var vertexShader = "\
	attribute vec3 vertex; \n\
	uniform float zOffset; \n\
	uniform mat4 modelViewMatrix;\n\
	uniform mat4 projectionMatrix;\n\
	\n\
	void main(void)  \n\
	{ \n\
		gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex.x, vertex.y, vertex.z + zOffset, 1.0); \n\
	} \n\
	";
	
	var fragmentShader = "\
	#ifdef GL_ES \n\
	precision highp float; \n\
	#endif \n\
	uniform vec4 color; \n\
	\n\
	void main(void) \n\
	{ \n\
		gl_FragColor = color; \n\
	} \n\
	";

    this.program = new Program(this.tileManager.renderContext);
    this.program.createFromSource(vertexShader, fragmentShader);
}

Utils.inherits(VectorRenderer,TiledVectorRenderer);

/**************************************************************************************************************/

/**
	Render all redenrable on the given tiles
 */
TiledVectorRenderer.prototype.render = function(renderables,start,end)
{
	var renderContext = this.tileManager.renderContext;
	var gl = renderContext.gl;
	
	var modelViewMatrix = mat4.create();
	
    // Setup program
    this.program.apply();
	
	gl.depthFunc(gl.LEQUAL);
	// Do not write into z-buffer : the tiled vector are clamped to terrain, so the z of terrain should not change
	gl.depthMask(false);
 	gl.uniformMatrix4fv( this.program.uniforms["projectionMatrix"], false, renderContext.projectionMatrix);
    
	var currentStyle = null;
	
	for ( var n = start; n < end; n++ )
	{
		var renderable = renderables[n];
		var tile = renderable.tile;
		
		mat4.multiply( renderContext.viewMatrix, tile.matrix, modelViewMatrix );
		gl.uniformMatrix4fv( this.program.uniforms["modelViewMatrix"], false, modelViewMatrix );
		gl.uniform1f( this.program.uniforms["zOffset"], tile.radius * 0.0007 );
		
		var currentStyle = renderable.bucket.style;
			
		renderable.bindBuffers(renderContext);
	
		gl.vertexAttribPointer(this.program.attributes['vertex'], 3, gl.FLOAT, false, 0, 0);
			
		if ( renderable.triIndices.length > 0 ) 
		{
			gl.uniform4f( this.program.uniforms["color"], currentStyle.fillColor[0], currentStyle.fillColor[1], currentStyle.fillColor[2], 
				currentStyle.fillColor[3] * renderable.bucket.layer._opacity );
			gl.drawElements( gl.TRIANGLES, renderable.triIndices.length, renderable.indexType, 0);
		}
		
		if ( renderable.lineIndices.length > 0 ) 
		{
			gl.lineWidth( currentStyle.strokeWidth );
			gl.uniform4f( this.program.uniforms["color"], currentStyle.strokeColor[0], currentStyle.strokeColor[1], currentStyle.strokeColor[2], 
				currentStyle.strokeColor[3] * renderable.bucket.layer._opacity );
			var size = renderable.indexType == gl.UNSIGNED_INT ? 4 : 2;
			gl.drawElements( gl.LINES, renderable.lineIndices.length, renderable.indexType, renderable.triIndices.length * size);
		}
	}

	gl.depthMask(true);
	gl.depthFunc(gl.LESS);
}

/**************************************************************************************************************/;
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 

/**************************************************************************************************************/


/** @constructor
 *  @extends TiledVectorRenderable
 *	LineStringRenderable manages lineString data to be rendered on a tile.
 */
var LineStringRenderable = function( bucket )
{
	TiledVectorRenderable.prototype.constructor.call(this,bucket);
}

/**************************************************************************************************************/

// Inheritance
Utils.inherits(TiledVectorRenderable,LineStringRenderable);

/**************************************************************************************************************/

/**************************************************************************************************************/

/** 
  Check if a geometry crosses the date line
*/
LineStringRenderable.prototype._fixDateLine = function( tile, coords ) 
{		
	var newCoords = [];
	var lines = [ newCoords ]
	for ( var n = 0; n < coords.length-1; n++) {

		newCoords.push( coords[n] );
		
		var x1 = coords[n][0];
		var y1 = coords[n][1];
		var x2 = coords[n+1][0];
		var y2 = coords[n+1][1];
		
		if ( Math.abs(x2 - x1) > 180 ) 
		{
			if ( x1 < 0 ) {
				x1 += 360;
			}
			if ( x2 < 0 ) {
				x2 += 360;
			}
			
			var t = (180 - x1) / (x2 - x1);
			if ( t > 0 && t < 1) {
				var y = y1 + t * (y2 - y1);
				var x = coords[n][0] > 0 ? 180 : -180;
				newCoords.push( [x,y] );
				newCoords = [ [-x,y] ];
				lines.push( newCoords );
			}
		}
	}
	
	newCoords.push( coords[0] );
	
	return lines;
};

/**
 * Build vertices and indices from the coordinates.
 * Clamp a line string on a tile
 */
LineStringRenderable.prototype.buildVerticesAndIndices = function( tile, coords )
{
	if ( coords.length == 0 )
		return;
		
	// Fix date line for coordinates first
	var coordinates = this._fixDateLine( tile, coords );
	
	for ( var i = 0; i < coordinates.length; i++ ) {
		this._buildVerticesAndIndices( tile, coordinates[i] );
	}
}

/**
 * Build vertices and indices from the coordinates.
 * Clamp a line string on a tile
 */
LineStringRenderable.prototype._buildVerticesAndIndices = function( tile, coords )
{		
	var size = tile.config.tesselation;
	var vs = tile.config.vertexSize;
	
	// Convert lon/lat coordinates to tile coordinates (between [0,size-1] inside the tile)
	var tileCoords = tile.lonlat2tile(coords);

	for ( var i = 0; i < coords.length - 1; i++ )
	{
		var u1 = tileCoords[i][0];
		var v1 = tileCoords[i][1];
		
		var u2 = tileCoords[i+1][0];
		var v2 = tileCoords[i+1][1];
		
		var intersections = [];
	
		// Intersect the segment with the tile grid
		
		// First intersect with columns
		// uStart, uEnd represent a range of the tile columns that the segement can intersect
		var uStart = Math.max( -1, Math.min( u1, u2 ) );
		var uEnd = Math.min( size-1, Math.max( u1, u2 ) );
		for ( var n = Math.floor(uStart)+1; n < Math.floor(uEnd)+1; n++)
		{
			var u = n;
			var res = Numeric.lineIntersection( u1, v1, u2, v2, u, 0.0, u, size-1 );
			if ( res[0] > 0.0 && res[0] < 1.0 && res[1] >= 0.0 && res[1] <= 1.0 )
			{
				var v = res[1] * (size-1);
				var vFloor = Math.floor( v );
				var vFrac = v - vFloor;
				var vertexOffset = vs*( vFloor*size + n );
				var x = (1.0 - vFrac) * tile.vertices[ vertexOffset ] + vFrac * tile.vertices[ vertexOffset + vs*size ];
				var y = (1.0 - vFrac) * tile.vertices[ vertexOffset + 1 ] + vFrac * tile.vertices[ vertexOffset + vs*size + 1 ];
				var z = (1.0 - vFrac) * tile.vertices[ vertexOffset + 2 ] + vFrac * tile.vertices[ vertexOffset + vs*size + 2 ];
				intersections.push( [ res[0], x, y, z ] );
			}
		}
	
		// Then intersect with rows
		// vStart, vEnd represent a range of the tile rows that the segement can intersect
		var vStart = Math.max( -1, Math.min( v1, v2 ) );
		var vEnd = Math.min( size-1, Math.max( v1, v2 ) );
		for ( var n = Math.floor(vStart)+1; n < Math.floor(vEnd)+1; n++)
		{
			var v = n;
			var res = Numeric.lineIntersection( u1, v1, u2, v2, 0.0, v, size-1, v );
			if ( res[0] > 0.0 && res[0] < 1.0 && res[1] >= 0.0 && res[1] <= 1.0 )
			{
				var u = res[1] * (size-1);
				var uFloor = Math.floor( u );
				var uFrac = u - uFloor;
				var vertexOffset = vs*( n*size + uFloor );
				var x = (1.0 - uFrac) * tile.vertices[ vertexOffset ] + uFrac * tile.vertices[ vertexOffset + vs ];
				var y = (1.0 - uFrac) * tile.vertices[ vertexOffset + 1 ] + uFrac * tile.vertices[ vertexOffset + vs+1 ];
				var z = (1.0 - uFrac) * tile.vertices[ vertexOffset + 2 ] + uFrac * tile.vertices[ vertexOffset + vs+2 ];
				intersections.push( [ res[0], x, y, z ] );
			}
		}
/*			for ( var n = 0; n < size; n++)
		{
			var u = n;
			var v = n;
			var res = lineIntersection( u1, v1, u2, v2, u, 0.0, 0.0, v );
			if ( res[0] > 0.0 && res[0] < 1.0 && res[1] > 0.0 && res[1] < 1.0 )
			{
				intersections.push( res[0] );
			}
			if ( n != size-1 )
			{
				var res = lineIntersection( u1, v1, u2, v2, u, size, size, v );
				if ( res[0] > 0.0 && res[0] < 1.0 && res[1] > 0.0 && res[1] < 1.0 )
				{
					intersections.push( res[0] );
				}
			}
		}*/
		
		// Sort intersections found on the segment
		intersections.sort( function(a,b) { return a[0] > b[0]; } );
		
		// Build the vertices from the intersections found
		var startIndex = this.vertices.length / 3;
		
		if ( u1 >= 0.0 && u1 <= size-1 &&  v1 >= 0.0 && v1 <= size-1 )
		{
			var vec = tile.computePosition(u1,v1);
			this.vertices.push( vec[0] );
			this.vertices.push( vec[1] );
			this.vertices.push( vec[2] );
		}
					
		for ( var n = 0; n < intersections.length; n++ )
		{
			this.vertices.push( intersections[n][1] );
			this.vertices.push( intersections[n][2] );
			this.vertices.push( intersections[n][3] );
		}
		
		if ( u2 >= 0.0 && u2 <= size-1 &&  v2 >= 0.0 && v2 <= size-1 )
		{
			var vec = tile.computePosition(u2,v2);
			this.vertices.push( vec[0] );
			this.vertices.push( vec[1] );
			this.vertices.push( vec[2] );
		}
		
		var endIndex = this.vertices.length / 3;
		
		for ( var n = startIndex; n < endIndex - 1; n++ )
		{
			this.lineIndices.push( n );
			this.lineIndices.push( n+1 );
		}
	}
}

/**************************************************************************************************************/

/** @constructor
 *  @extends TiledVectorRenderer
 */
var LineStringRenderer = function( globe )
{
	TiledVectorRenderer.prototype.constructor.call(this,globe);
}

// Inheritance
Utils.inherits(TiledVectorRenderer,LineStringRenderer);

/**************************************************************************************************************/

/**
	Check if renderer is applicable
 */
LineStringRenderer.prototype.canApply = function(type,style)
{
	if ( this.globe.isSky )
		return false;

	return (type == "LineString" || type == "MultiLineString"
							|| (!style.fill && (type == "Polygon" || type == "MultiPolygon")))
						&& !style.gradientLength;
}
/**************************************************************************************************************/

/**
	Bucket constructor for LineStringRenderer
 */
var LineStringBucket = function(layer,style)
{
	this.layer = layer;
	this.style = new FeatureStyle(style);
	this.renderer = null;
}

/**************************************************************************************************************/

/**
	Create a renderable for this bucket
 */
LineStringBucket.prototype.createRenderable = function()
{
	return new LineStringRenderable(this);
}

/**************************************************************************************************************/

/**
	Check if a bucket is compatible
 */
LineStringBucket.prototype.isCompatible = function(style)
{
	return this.style.strokeColor[0] == style.strokeColor[0]
		&& this.style.strokeColor[1] == style.strokeColor[1]
		&& this.style.strokeColor[2] == style.strokeColor[2]
		&& this.style.strokeColor[3] == style.strokeColor[3]
		&& this.style.strokeWidth == style.strokeWidth;
}

/**************************************************************************************************************/

/**
	Get or create a bucket to store a feature with the given style
 */
LineStringRenderer.prototype.createBucket = function( layer, style )
{
	// Create a bucket
	return new LineStringBucket(layer,style);
}

/**************************************************************************************************************/

// Register the renderer
VectorRendererManager.factory.push( function(globe) { return new LineStringRenderer(globe); } );
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
 


// Declare GlobWeb 
var GlobWeb = {};

GlobWeb.Globe = Globe;
GlobWeb.GeoBound = GeoBound;
GlobWeb.WMSLayer = WMSLayer;
GlobWeb.WMTSLayer = WMTSLayer;
GlobWeb.WCSElevationLayer = WCSElevationLayer;
GlobWeb.OSMLayer = OSMLayer;
GlobWeb.BingLayer = BingLayer;
GlobWeb.VectorLayer = VectorLayer;
GlobWeb.GroundOverlayLayer = GroundOverlayLayer;
GlobWeb.FeatureStyle = FeatureStyle;
GlobWeb.Navigation = Navigation;
GlobWeb.Stats = Stats;
GlobWeb.KMLParser = KMLParser;
GlobWeb.Numeric = Numeric;
GlobWeb.PathAnimation = PathAnimation;
GlobWeb.SegmentedAnimation = SegmentedAnimation;
GlobWeb.AttributionHandler = AttributionHandler;

window.GlobWeb = GlobWeb;
return GlobWeb; }());