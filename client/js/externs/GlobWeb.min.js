/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
var GlobWeb = GlobWeb || {};
var glMatrixArrayType = Array, vec3 = {create:function(a) {
  var b = new glMatrixArrayType(3);
  a && (b[0] = a[0], b[1] = a[1], b[2] = a[2]);
  return b
}, set:function(a, b) {
  b[0] = a[0];
  b[1] = a[1];
  b[2] = a[2];
  return b
}, add:function(a, b, c) {
  if(!c || a == c) {
    return a[0] += b[0], a[1] += b[1], a[2] += b[2], a
  }
  c[0] = a[0] + b[0];
  c[1] = a[1] + b[1];
  c[2] = a[2] + b[2];
  return c
}, subtract:function(a, b, c) {
  if(!c || a == c) {
    return a[0] -= b[0], a[1] -= b[1], a[2] -= b[2], a
  }
  c[0] = a[0] - b[0];
  c[1] = a[1] - b[1];
  c[2] = a[2] - b[2];
  return c
}, negate:function(a, b) {
  b || (b = a);
  b[0] = -a[0];
  b[1] = -a[1];
  b[2] = -a[2];
  return b
}, scale:function(a, b, c) {
  if(!c || a == c) {
    return a[0] *= b, a[1] *= b, a[2] *= b, a
  }
  c[0] = a[0] * b;
  c[1] = a[1] * b;
  c[2] = a[2] * b;
  return c
}, normalize:function(a, b) {
  b || (b = a);
  var c = a[0], d = a[1], e = a[2], f = Math.sqrt(c * c + d * d + e * e);
  if(!f) {
    return b[0] = 0, b[1] = 0, b[2] = 0, b
  }
  if(1 == f) {
    return b[0] = c, b[1] = d, b[2] = e, b
  }
  f = 1 / f;
  b[0] = c * f;
  b[1] = d * f;
  b[2] = e * f;
  return b
}, cross:function(a, b, c) {
  c || (c = a);
  var d = a[0], e = a[1], a = a[2], f = b[0], g = b[1], b = b[2];
  c[0] = e * b - a * g;
  c[1] = a * f - d * b;
  c[2] = d * g - e * f;
  return c
}, length:function(a) {
  var b = a[0], c = a[1], a = a[2];
  return Math.sqrt(b * b + c * c + a * a)
}, dot:function(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]
}, direction:function(a, b, c) {
  c || (c = a);
  var d = a[0] - b[0], e = a[1] - b[1], a = a[2] - b[2], b = Math.sqrt(d * d + e * e + a * a);
  if(!b) {
    return c[0] = 0, c[1] = 0, c[2] = 0, c
  }
  b = 1 / b;
  c[0] = d * b;
  c[1] = e * b;
  c[2] = a * b;
  return c
}, lerp:function(a, b, c, d) {
  d || (d = a);
  d[0] = a[0] + c * (b[0] - a[0]);
  d[1] = a[1] + c * (b[1] - a[1]);
  d[2] = a[2] + c * (b[2] - a[2]);
  return d
}, str:function(a) {
  return"[" + a[0] + ", " + a[1] + ", " + a[2] + "]"
}}, mat3 = {create:function(a) {
  var b = new glMatrixArrayType(9);
  a && (b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], b[5] = a[5], b[6] = a[6], b[7] = a[7], b[8] = a[8]);
  return b
}, set:function(a, b) {
  b[0] = a[0];
  b[1] = a[1];
  b[2] = a[2];
  b[3] = a[3];
  b[4] = a[4];
  b[5] = a[5];
  b[6] = a[6];
  b[7] = a[7];
  b[8] = a[8];
  return b
}, identity:function(a) {
  a[0] = 1;
  a[1] = 0;
  a[2] = 0;
  a[3] = 0;
  a[4] = 1;
  a[5] = 0;
  a[6] = 0;
  a[7] = 0;
  a[8] = 1;
  return a
}, transpose:function(a, b) {
  if(!b || a == b) {
    var c = a[1], d = a[2], e = a[5];
    a[1] = a[3];
    a[2] = a[6];
    a[3] = c;
    a[5] = a[7];
    a[6] = d;
    a[7] = e;
    return a
  }
  b[0] = a[0];
  b[1] = a[3];
  b[2] = a[6];
  b[3] = a[1];
  b[4] = a[4];
  b[5] = a[7];
  b[6] = a[2];
  b[7] = a[5];
  b[8] = a[8];
  return b
}, toMat4:function(a, b) {
  b || (b = mat4.create());
  b[0] = a[0];
  b[1] = a[1];
  b[2] = a[2];
  b[3] = 0;
  b[4] = a[3];
  b[5] = a[4];
  b[6] = a[5];
  b[7] = 0;
  b[8] = a[6];
  b[9] = a[7];
  b[10] = a[8];
  b[11] = 0;
  b[12] = 0;
  b[13] = 0;
  b[14] = 0;
  b[15] = 1;
  return b
}, str:function(a) {
  return"[" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + "]"
}}, mat4 = {create:function(a) {
  var b = new glMatrixArrayType(16);
  a && (b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], b[5] = a[5], b[6] = a[6], b[7] = a[7], b[8] = a[8], b[9] = a[9], b[10] = a[10], b[11] = a[11], b[12] = a[12], b[13] = a[13], b[14] = a[14], b[15] = a[15]);
  return b
}, set:function(a, b) {
  b[0] = a[0];
  b[1] = a[1];
  b[2] = a[2];
  b[3] = a[3];
  b[4] = a[4];
  b[5] = a[5];
  b[6] = a[6];
  b[7] = a[7];
  b[8] = a[8];
  b[9] = a[9];
  b[10] = a[10];
  b[11] = a[11];
  b[12] = a[12];
  b[13] = a[13];
  b[14] = a[14];
  b[15] = a[15];
  return b
}, identity:function(a) {
  a[0] = 1;
  a[1] = 0;
  a[2] = 0;
  a[3] = 0;
  a[4] = 0;
  a[5] = 1;
  a[6] = 0;
  a[7] = 0;
  a[8] = 0;
  a[9] = 0;
  a[10] = 1;
  a[11] = 0;
  a[12] = 0;
  a[13] = 0;
  a[14] = 0;
  a[15] = 1;
  return a
}, transpose:function(a, b) {
  if(!b || a == b) {
    var c = a[1], d = a[2], e = a[3], f = a[6], g = a[7], h = a[11];
    a[1] = a[4];
    a[2] = a[8];
    a[3] = a[12];
    a[4] = c;
    a[6] = a[9];
    a[7] = a[13];
    a[8] = d;
    a[9] = f;
    a[11] = a[14];
    a[12] = e;
    a[13] = g;
    a[14] = h;
    return a
  }
  b[0] = a[0];
  b[1] = a[4];
  b[2] = a[8];
  b[3] = a[12];
  b[4] = a[1];
  b[5] = a[5];
  b[6] = a[9];
  b[7] = a[13];
  b[8] = a[2];
  b[9] = a[6];
  b[10] = a[10];
  b[11] = a[14];
  b[12] = a[3];
  b[13] = a[7];
  b[14] = a[11];
  b[15] = a[15];
  return b
}, determinant:function(a) {
  var b = a[0], c = a[1], d = a[2], e = a[3], f = a[4], g = a[5], h = a[6], i = a[7], j = a[8], k = a[9], l = a[10], m = a[11], p = a[12], n = a[13], o = a[14], a = a[15];
  return p * k * h * e - j * n * h * e - p * g * l * e + f * n * l * e + j * g * o * e - f * k * o * e - p * k * d * i + j * n * d * i + p * c * l * i - b * n * l * i - j * c * o * i + b * k * o * i + p * g * d * m - f * n * d * m - p * c * h * m + b * n * h * m + f * c * o * m - b * g * o * m - j * g * d * a + f * k * d * a + j * c * h * a - b * k * h * a - f * c * l * a + b * g * l * a
}, inverse:function(a, b) {
  b || (b = a);
  var c = a[0], d = a[1], e = a[2], f = a[3], g = a[4], h = a[5], i = a[6], j = a[7], k = a[8], l = a[9], m = a[10], p = a[11], n = a[12], o = a[13], q = a[14], s = a[15], r = c * h - d * g, u = c * i - e * g, v = c * j - f * g, w = d * i - e * h, x = d * j - f * h, y = e * j - f * i, z = k * o - l * n, A = k * q - m * n, B = k * s - p * n, C = l * q - m * o, D = l * s - p * o, E = m * s - p * q, t = 1 / (r * E - u * D + v * C + w * B - x * A + y * z);
  b[0] = (h * E - i * D + j * C) * t;
  b[1] = (-d * E + e * D - f * C) * t;
  b[2] = (o * y - q * x + s * w) * t;
  b[3] = (-l * y + m * x - p * w) * t;
  b[4] = (-g * E + i * B - j * A) * t;
  b[5] = (c * E - e * B + f * A) * t;
  b[6] = (-n * y + q * v - s * u) * t;
  b[7] = (k * y - m * v + p * u) * t;
  b[8] = (g * D - h * B + j * z) * t;
  b[9] = (-c * D + d * B - f * z) * t;
  b[10] = (n * x - o * v + s * r) * t;
  b[11] = (-k * x + l * v - p * r) * t;
  b[12] = (-g * C + h * A - i * z) * t;
  b[13] = (c * C - d * A + e * z) * t;
  b[14] = (-n * w + o * u - q * r) * t;
  b[15] = (k * w - l * u + m * r) * t;
  return b
}, toRotationMat:function(a, b) {
  b || (b = mat4.create());
  b[0] = a[0];
  b[1] = a[1];
  b[2] = a[2];
  b[3] = a[3];
  b[4] = a[4];
  b[5] = a[5];
  b[6] = a[6];
  b[7] = a[7];
  b[8] = a[8];
  b[9] = a[9];
  b[10] = a[10];
  b[11] = a[11];
  b[12] = 0;
  b[13] = 0;
  b[14] = 0;
  b[15] = 1;
  return b
}, toMat3:function(a, b) {
  b || (b = mat3.create());
  b[0] = a[0];
  b[1] = a[1];
  b[2] = a[2];
  b[3] = a[4];
  b[4] = a[5];
  b[5] = a[6];
  b[6] = a[8];
  b[7] = a[9];
  b[8] = a[10];
  return b
}, toInverseMat3:function(a, b) {
  var c = a[0], d = a[1], e = a[2], f = a[4], g = a[5], h = a[6], i = a[8], j = a[9], k = a[10], l = k * g - h * j, m = -k * f + h * i, p = j * f - g * i, n = c * l + d * m + e * p;
  if(!n) {
    return null
  }
  n = 1 / n;
  b || (b = mat3.create());
  b[0] = l * n;
  b[1] = (-k * d + e * j) * n;
  b[2] = (h * d - e * g) * n;
  b[3] = m * n;
  b[4] = (k * c - e * i) * n;
  b[5] = (-h * c + e * f) * n;
  b[6] = p * n;
  b[7] = (-j * c + d * i) * n;
  b[8] = (g * c - d * f) * n;
  return b
}, multiply:function(a, b, c) {
  c || (c = a);
  var d = a[0], e = a[1], f = a[2], g = a[3], h = a[4], i = a[5], j = a[6], k = a[7], l = a[8], m = a[9], p = a[10], n = a[11], o = a[12], q = a[13], s = a[14], a = a[15], r = b[0], u = b[1], v = b[2], w = b[3], x = b[4], y = b[5], z = b[6], A = b[7], B = b[8], C = b[9], D = b[10], E = b[11], t = b[12], F = b[13], G = b[14], b = b[15];
  c[0] = r * d + u * h + v * l + w * o;
  c[1] = r * e + u * i + v * m + w * q;
  c[2] = r * f + u * j + v * p + w * s;
  c[3] = r * g + u * k + v * n + w * a;
  c[4] = x * d + y * h + z * l + A * o;
  c[5] = x * e + y * i + z * m + A * q;
  c[6] = x * f + y * j + z * p + A * s;
  c[7] = x * g + y * k + z * n + A * a;
  c[8] = B * d + C * h + D * l + E * o;
  c[9] = B * e + C * i + D * m + E * q;
  c[10] = B * f + C * j + D * p + E * s;
  c[11] = B * g + C * k + D * n + E * a;
  c[12] = t * d + F * h + G * l + b * o;
  c[13] = t * e + F * i + G * m + b * q;
  c[14] = t * f + F * j + G * p + b * s;
  c[15] = t * g + F * k + G * n + b * a;
  return c
}, multiplyVec3:function(a, b, c) {
  c || (c = b);
  var d = b[0], e = b[1], b = b[2];
  c[0] = a[0] * d + a[4] * e + a[8] * b + a[12];
  c[1] = a[1] * d + a[5] * e + a[9] * b + a[13];
  c[2] = a[2] * d + a[6] * e + a[10] * b + a[14];
  return c
}, multiplyVec4:function(a, b, c) {
  c || (c = b);
  var d = b[0], e = b[1], f = b[2], b = b[3];
  c[0] = a[0] * d + a[4] * e + a[8] * f + a[12] * b;
  c[1] = a[1] * d + a[5] * e + a[9] * f + a[13] * b;
  c[2] = a[2] * d + a[6] * e + a[10] * f + a[14] * b;
  c[3] = a[3] * d + a[7] * e + a[11] * f + a[15] * b;
  return c
}, translate:function(a, b, c) {
  var d = b[0], e = b[1], b = b[2];
  if(!c || a == c) {
    return a[12] = a[0] * d + a[4] * e + a[8] * b + a[12], a[13] = a[1] * d + a[5] * e + a[9] * b + a[13], a[14] = a[2] * d + a[6] * e + a[10] * b + a[14], a[15] = a[3] * d + a[7] * e + a[11] * b + a[15], a
  }
  var f = a[0], g = a[1], h = a[2], i = a[3], j = a[4], k = a[5], l = a[6], m = a[7], p = a[8], n = a[9], o = a[10], q = a[11];
  c[0] = f;
  c[1] = g;
  c[2] = h;
  c[3] = i;
  c[4] = j;
  c[5] = k;
  c[6] = l;
  c[7] = m;
  c[8] = p;
  c[9] = n;
  c[10] = o;
  c[11] = q;
  c[12] = f * d + j * e + p * b + a[12];
  c[13] = g * d + k * e + n * b + a[13];
  c[14] = h * d + l * e + o * b + a[14];
  c[15] = i * d + m * e + q * b + a[15];
  return c
}, scale:function(a, b, c) {
  var d = b[0], e = b[1], b = b[2];
  if(!c || a == c) {
    return a[0] *= d, a[1] *= d, a[2] *= d, a[3] *= d, a[4] *= e, a[5] *= e, a[6] *= e, a[7] *= e, a[8] *= b, a[9] *= b, a[10] *= b, a[11] *= b, a
  }
  c[0] = a[0] * d;
  c[1] = a[1] * d;
  c[2] = a[2] * d;
  c[3] = a[3] * d;
  c[4] = a[4] * e;
  c[5] = a[5] * e;
  c[6] = a[6] * e;
  c[7] = a[7] * e;
  c[8] = a[8] * b;
  c[9] = a[9] * b;
  c[10] = a[10] * b;
  c[11] = a[11] * b;
  c[12] = a[12];
  c[13] = a[13];
  c[14] = a[14];
  c[15] = a[15];
  return c
}, rotate:function(a, b, c, d) {
  var e = c[0], f = c[1], c = c[2], g = Math.sqrt(e * e + f * f + c * c);
  if(!g) {
    return null
  }
  1 != g && (g = 1 / g, e *= g, f *= g, c *= g);
  var h = Math.sin(b), i = Math.cos(b), j = 1 - i, b = a[0], g = a[1], k = a[2], l = a[3], m = a[4], p = a[5], n = a[6], o = a[7], q = a[8], s = a[9], r = a[10], u = a[11], v = e * e * j + i, w = f * e * j + c * h, x = c * e * j - f * h, y = e * f * j - c * h, z = f * f * j + i, A = c * f * j + e * h, B = e * c * j + f * h, e = f * c * j - e * h, f = c * c * j + i;
  d ? a != d && (d[12] = a[12], d[13] = a[13], d[14] = a[14], d[15] = a[15]) : d = a;
  d[0] = b * v + m * w + q * x;
  d[1] = g * v + p * w + s * x;
  d[2] = k * v + n * w + r * x;
  d[3] = l * v + o * w + u * x;
  d[4] = b * y + m * z + q * A;
  d[5] = g * y + p * z + s * A;
  d[6] = k * y + n * z + r * A;
  d[7] = l * y + o * z + u * A;
  d[8] = b * B + m * e + q * f;
  d[9] = g * B + p * e + s * f;
  d[10] = k * B + n * e + r * f;
  d[11] = l * B + o * e + u * f;
  return d
}, rotateX:function(a, b, c) {
  var d = Math.sin(b), b = Math.cos(b), e = a[4], f = a[5], g = a[6], h = a[7], i = a[8], j = a[9], k = a[10], l = a[11];
  c ? a != c && (c[0] = a[0], c[1] = a[1], c[2] = a[2], c[3] = a[3], c[12] = a[12], c[13] = a[13], c[14] = a[14], c[15] = a[15]) : c = a;
  c[4] = e * b + i * d;
  c[5] = f * b + j * d;
  c[6] = g * b + k * d;
  c[7] = h * b + l * d;
  c[8] = e * -d + i * b;
  c[9] = f * -d + j * b;
  c[10] = g * -d + k * b;
  c[11] = h * -d + l * b;
  return c
}, rotateY:function(a, b, c) {
  var d = Math.sin(b), b = Math.cos(b), e = a[0], f = a[1], g = a[2], h = a[3], i = a[8], j = a[9], k = a[10], l = a[11];
  c ? a != c && (c[4] = a[4], c[5] = a[5], c[6] = a[6], c[7] = a[7], c[12] = a[12], c[13] = a[13], c[14] = a[14], c[15] = a[15]) : c = a;
  c[0] = e * b + i * -d;
  c[1] = f * b + j * -d;
  c[2] = g * b + k * -d;
  c[3] = h * b + l * -d;
  c[8] = e * d + i * b;
  c[9] = f * d + j * b;
  c[10] = g * d + k * b;
  c[11] = h * d + l * b;
  return c
}, rotateZ:function(a, b, c) {
  var d = Math.sin(b), b = Math.cos(b), e = a[0], f = a[1], g = a[2], h = a[3], i = a[4], j = a[5], k = a[6], l = a[7];
  c ? a != c && (c[8] = a[8], c[9] = a[9], c[10] = a[10], c[11] = a[11], c[12] = a[12], c[13] = a[13], c[14] = a[14], c[15] = a[15]) : c = a;
  c[0] = e * b + i * d;
  c[1] = f * b + j * d;
  c[2] = g * b + k * d;
  c[3] = h * b + l * d;
  c[4] = e * -d + i * b;
  c[5] = f * -d + j * b;
  c[6] = g * -d + k * b;
  c[7] = h * -d + l * b;
  return c
}, frustum:function(a, b, c, d, e, f, g) {
  g || (g = mat4.create());
  var h = b - a, i = d - c, j = f - e;
  g[0] = 2 * e / h;
  g[1] = 0;
  g[2] = 0;
  g[3] = 0;
  g[4] = 0;
  g[5] = 2 * e / i;
  g[6] = 0;
  g[7] = 0;
  g[8] = (b + a) / h;
  g[9] = (d + c) / i;
  g[10] = -(f + e) / j;
  g[11] = -1;
  g[12] = 0;
  g[13] = 0;
  g[14] = -(2 * f * e) / j;
  g[15] = 0;
  return g
}, perspective:function(a, b, c, d, e) {
  a = c * Math.tan(a * Math.PI / 360);
  b *= a;
  return mat4.frustum(-b, b, -a, a, c, d, e)
}, ortho:function(a, b, c, d, e, f, g) {
  g || (g = mat4.create());
  var h = b - a, i = d - c, j = f - e;
  g[0] = 2 / h;
  g[1] = 0;
  g[2] = 0;
  g[3] = 0;
  g[4] = 0;
  g[5] = 2 / i;
  g[6] = 0;
  g[7] = 0;
  g[8] = 0;
  g[9] = 0;
  g[10] = -2 / j;
  g[11] = 0;
  g[12] = -(a + b) / h;
  g[13] = -(d + c) / i;
  g[14] = -(f + e) / j;
  g[15] = 1;
  return g
}, lookAt:function(a, b, c, d) {
  d || (d = mat4.create());
  var e = a[0], f = a[1], a = a[2], g = c[0], h = c[1], i = c[2], c = b[1], j = b[2];
  if(e == b[0] && f == c && a == j) {
    return mat4.identity(d)
  }
  var k, l, m, p, c = e - b[0], j = f - b[1], b = a - b[2];
  p = 1 / Math.sqrt(c * c + j * j + b * b);
  c *= p;
  j *= p;
  b *= p;
  k = h * b - i * j;
  i = i * c - g * b;
  g = g * j - h * c;
  (p = Math.sqrt(k * k + i * i + g * g)) ? (p = 1 / p, k *= p, i *= p, g *= p) : g = i = k = 0;
  h = j * g - b * i;
  l = b * k - c * g;
  m = c * i - j * k;
  (p = Math.sqrt(h * h + l * l + m * m)) ? (p = 1 / p, h *= p, l *= p, m *= p) : m = l = h = 0;
  d[0] = k;
  d[1] = h;
  d[2] = c;
  d[3] = 0;
  d[4] = i;
  d[5] = l;
  d[6] = j;
  d[7] = 0;
  d[8] = g;
  d[9] = m;
  d[10] = b;
  d[11] = 0;
  d[12] = -(k * e + i * f + g * a);
  d[13] = -(h * e + l * f + m * a);
  d[14] = -(c * e + j * f + b * a);
  d[15] = 1;
  return d
}, str:function(a) {
  return"[" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + "]"
}}, quat4 = {create:function(a) {
  var b = new glMatrixArrayType(4);
  a && (b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3]);
  return b
}, set:function(a, b) {
  b[0] = a[0];
  b[1] = a[1];
  b[2] = a[2];
  b[3] = a[3];
  return b
}, calculateW:function(a, b) {
  var c = a[0], d = a[1], e = a[2];
  if(!b || a == b) {
    return a[3] = -Math.sqrt(Math.abs(1 - c * c - d * d - e * e)), a
  }
  b[0] = c;
  b[1] = d;
  b[2] = e;
  b[3] = -Math.sqrt(Math.abs(1 - c * c - d * d - e * e));
  return b
}, inverse:function(a, b) {
  if(!b || a == b) {
    return a[0] *= -1, a[1] *= -1, a[2] *= -1, a
  }
  b[0] = -a[0];
  b[1] = -a[1];
  b[2] = -a[2];
  b[3] = a[3];
  return b
}, length:function(a) {
  var b = a[0], c = a[1], d = a[2], a = a[3];
  return Math.sqrt(b * b + c * c + d * d + a * a)
}, normalize:function(a, b) {
  b || (b = a);
  var c = a[0], d = a[1], e = a[2], f = a[3], g = Math.sqrt(c * c + d * d + e * e + f * f);
  if(0 == g) {
    return b[0] = 0, b[1] = 0, b[2] = 0, b[3] = 0, b
  }
  g = 1 / g;
  b[0] = c * g;
  b[1] = d * g;
  b[2] = e * g;
  b[3] = f * g;
  return b
}, multiply:function(a, b, c) {
  c || (c = a);
  var d = a[0], e = a[1], f = a[2], a = a[3], g = b[0], h = b[1], i = b[2], b = b[3];
  c[0] = d * b + a * g + e * i - f * h;
  c[1] = e * b + a * h + f * g - d * i;
  c[2] = f * b + a * i + d * h - e * g;
  c[3] = a * b - d * g - e * h - f * i;
  return c
}, multiplyVec3:function(a, b, c) {
  c || (c = b);
  var d = b[0], e = b[1], f = b[2], b = a[0], g = a[1], h = a[2], a = a[3], i = a * d + g * f - h * e, j = a * e + h * d - b * f, k = a * f + b * e - g * d, d = -b * d - g * e - h * f;
  c[0] = i * a + d * -b + j * -h - k * -g;
  c[1] = j * a + d * -g + k * -b - i * -h;
  c[2] = k * a + d * -h + i * -g - j * -b;
  return c
}, toMat3:function(a, b) {
  b || (b = mat3.create());
  var c = a[0], d = a[1], e = a[2], f = a[3], g = c + c, h = d + d, i = e + e, j = c * g, k = c * h, c = c * i, l = d * h, d = d * i, e = e * i, g = f * g, h = f * h, f = f * i;
  b[0] = 1 - (l + e);
  b[1] = k - f;
  b[2] = c + h;
  b[3] = k + f;
  b[4] = 1 - (j + e);
  b[5] = d - g;
  b[6] = c - h;
  b[7] = d + g;
  b[8] = 1 - (j + l);
  return b
}, toMat4:function(a, b) {
  b || (b = mat4.create());
  var c = a[0], d = a[1], e = a[2], f = a[3], g = c + c, h = d + d, i = e + e, j = c * g, k = c * h, c = c * i, l = d * h, d = d * i, e = e * i, g = f * g, h = f * h, f = f * i;
  b[0] = 1 - (l + e);
  b[1] = k - f;
  b[2] = c + h;
  b[3] = 0;
  b[4] = k + f;
  b[5] = 1 - (j + e);
  b[6] = d - g;
  b[7] = 0;
  b[8] = c - h;
  b[9] = d + g;
  b[10] = 1 - (j + l);
  b[11] = 0;
  b[12] = 0;
  b[13] = 0;
  b[14] = 0;
  b[15] = 1;
  return b
}, slerp:function(a, b, c, d) {
  d || (d = a);
  var e = a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  if(1 <= Math.abs(e)) {
    return d != a && (d[0] = a[0], d[1] = a[1], d[2] = a[2], d[3] = a[3]), d
  }
  var f = Math.acos(e), g = Math.sqrt(1 - e * e);
  if(0.001 > Math.abs(g)) {
    return d[0] = 0.5 * a[0] + 0.5 * b[0], d[1] = 0.5 * a[1] + 0.5 * b[1], d[2] = 0.5 * a[2] + 0.5 * b[2], d[3] = 0.5 * a[3] + 0.5 * b[3], d
  }
  e = Math.sin((1 - c) * f) / g;
  c = Math.sin(c * f) / g;
  d[0] = a[0] * e + b[0] * c;
  d[1] = a[1] * e + b[1] * c;
  d[2] = a[2] * e + b[2] * c;
  d[3] = a[3] * e + b[3] * c;
  return d
}, str:function(a) {
  return"[" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + "]"
}};
GlobWeb.Stats = function(a, b) {
  a.renderContext.stats = this;
  this.globe = a;
  var c = b ? b.element : void 0;
  c && (this.element = "string" == typeof c ? document.getElementById(c) : c);
  this.showFPS = a.renderContext.continuousRendering;
  this.verbose = b && b.verbose ? b.verbose : !1;
  this.numFrames = 0;
  var d = this;
  window.setInterval(function() {
    d.print()
  }, 1E3)
};
GlobWeb.Stats.prototype.start = function(a) {
  this[a] = Date.now()
};
GlobWeb.Stats.prototype.end = function(a) {
  var b = Date.now() - this[a], c = this["max_" + a] || -1;
  c < b && (c = b);
  var d = this["sum_" + a] || 0;
  this[a] = b;
  this["max_" + a] = c;
  this["sum_" + a] = d + b;
  "globalRenderTime" == a && this.numFrames++
};
GlobWeb.Stats.prototype.print = function() {
  if(0 < this.numFrames) {
    var a = "";
    this.showFPS && (a += "FPS : " + this.numFrames + "<br>");
    a += "Average render time : " + (this.sum_globalRenderTime / this.numFrames).toFixed(2) + " ms";
    a += "<br># rendered tiles : " + this.globe.tileManager.tilesToRender.length;
    this.verbose && (a += "<br>Average traverse tiles time : " + (this.sum_traverseTime / this.numFrames).toFixed(2) + " ms", a += "<br>Average render tiles time : " + (this.sum_renderTime / this.numFrames).toFixed(2) + " ms", a += "<br>Average generate tiles time : " + (this.sum_generateTime / this.numFrames).toFixed(2) + " ms", a += "<br>Average request tiles time : " + (this.sum_requestTime / this.numFrames).toFixed(2) + " ms", a += "<br>Max render time : " + this.max_globalRenderTime + " ms", 
    a += "<br>Max traverse tiles time : " + this.max_traverseTime + " ms", a += "<br>Max render tiles time : " + this.max_renderTime + " ms", a += "<br>Max generate tiles time : " + this.max_generateTime + " ms", a += "<br>Max request tiles time : " + this.max_requestTime + " ms");
    this.element.innerHTML = a;
    this.numFrames = this.max_requestTime = this.max_generateTime = this.max_renderTime = this.max_traverseTime = this.max_globalRenderTime = this.sum_requestTime = this.sum_generateTime = this.sum_renderTime = this.sum_traverseTime = this.sum_globalRenderTime = 0
  }
};
GlobWeb.inherits = function(a, b) {
  function c() {
  }
  c.prototype = a.prototype;
  b.prototype = new c;
  b.prototype.constructor = b
};
GlobWeb.GeoBound = function(a, b, c, d) {
  this.south = b;
  this.west = a;
  this.north = d;
  this.east = c
};
GlobWeb.GeoBound.prototype.getCenter = function() {
  return[0.5 * (this.east + this.west), 0.5 * (this.south + this.north), 0]
};
GlobWeb.GeoBound.prototype.getNorth = function() {
  return this.north
};
GlobWeb.GeoBound.prototype.getSouth = function() {
  return this.south
};
GlobWeb.GeoBound.prototype.getWest = function() {
  return this.west
};
GlobWeb.GeoBound.prototype.getEast = function() {
  return this.east
};
GlobWeb.GeoBound.prototype.computeFromCoordinates = function(a) {
  this.west = a[0][0];
  this.east = a[0][0];
  this.south = a[0][1];
  this.north = a[0][1];
  for(var b = 1;b < a.length;b++) {
    this.west = Math.min(this.west, a[b][0]), this.east = Math.max(this.east, a[b][0]), this.south = Math.min(this.south, a[b][1]), this.north = Math.max(this.north, a[b][1])
  }
};
GlobWeb.GeoBound.prototype.intersects = function(a) {
  return this.west >= a.east || this.east <= a.west || this.south >= a.north || this.north <= a.south ? !1 : !0
};
GlobWeb.BoundingBox = function(a, b) {
  a && (this.min = vec3.create(a));
  b && (this.max = vec3.create(b))
};
GlobWeb.BoundingBox.prototype.extend = function(a, b, c) {
  this.min ? (a < this.min[0] && (this.min[0] = a), b < this.min[1] && (this.min[1] = b), c < this.min[2] && (this.min[2] = c), a > this.max[0] && (this.max[0] = a), b > this.max[1] && (this.max[1] = b), c > this.max[2] && (this.max[2] = c)) : (this.min = vec3.create(), this.max = vec3.create(), this.min[0] = a, this.min[1] = b, this.min[2] = c, this.max[0] = a, this.max[1] = b, this.max[2] = c)
};
GlobWeb.BoundingBox.prototype.compute = function(a, b, c) {
  this.min || (this.min = vec3.create(), this.max = vec3.create());
  this.min[0] = a[0];
  this.min[1] = a[1];
  this.min[2] = a[2];
  this.max[0] = a[0];
  this.max[1] = a[1];
  this.max[2] = a[2];
  for(var d = c || 3, b = b || a.length;c < b;c += d) {
    for(var e = 0;3 > e;e++) {
      a[c + e] < this.min[e] && (this.min[e] = a[c + e]), a[c + e] > this.max[e] && (this.max[e] = a[c + e])
    }
  }
};
GlobWeb.BoundingBox.prototype.getCorner = function(a) {
  return[a & 1 ? this.max[0] : this.min[0], a & 2 ? this.max[1] : this.min[1], a & 4 ? this.max[2] : this.min[2]]
};
GlobWeb.BoundingBox.prototype.getCenter = function() {
  return[0.5 * (this.max[0] + this.min[0]), 0.5 * (this.max[1] + this.min[1]), 0.5 * (this.max[2] + this.min[2])]
};
GlobWeb.BoundingBox.prototype.getRadius = function() {
  var a = vec3.create();
  vec3.subtract(this.max, this.min, a);
  return 0.5 * vec3.length(a)
};
GlobWeb.BaseLayer = function(a) {
  this.globe = null;
  this.name = a && a.hasOwnProperty("name") ? a.name : "";
  this.attribution = a && a.hasOwnProperty("attribution") ? a.attribution : "";
  this.icon = a && a.hasOwnProperty("icon") ? a.icon : "";
  this.description = a && a.hasOwnProperty("description") ? a.description : "";
  this._visible = a && a.hasOwnProperty("visible") ? a.visible : !0;
  this._opacity = a && a.hasOwnProperty("opacity") ? a.opacity : 1
};
GlobWeb.BaseLayer.prototype._attach = function(a) {
  this.globe = a
};
GlobWeb.BaseLayer.prototype._detach = function() {
  this.attribution && this.globe.attributionHandler.removeAttribution(this);
  this.globe = null
};
GlobWeb.BaseLayer.prototype.visible = function(a) {
  "boolean" == typeof a && (this._visible = a, this.globe && this.globe.renderContext.requestFrame());
  return this._visible
};
GlobWeb.BaseLayer.prototype.opacity = function(a) {
  "number" == typeof a && (this._opacity = a, this.globe && this.globe.renderContext.requestFrame());
  return this._opacity
};
GlobWeb.TileWireframeLayer = function(a) {
  GlobWeb.BaseLayer.prototype.constructor.call(this, a);
  this.globe = null
};
GlobWeb.inherits(GlobWeb.BaseLayer, GlobWeb.TileWireframeLayer);
GlobWeb.TileWireframeLayer.prototype._attach = function(a) {
  GlobWeb.BaseLayer.prototype._attach.call(this, a);
  this._visible && this.globe.tileManager.addPostRenderer(this);
  this.program || (this.program = new GlobWeb.Program(this.globe.renderContext), this.program.createFromSource("\t\tattribute vec3 vertex;\n\t\tuniform mat4 modelViewMatrix;\n\t\tuniform mat4 projectionMatrix;\n\t\tvoid main(void) \n\t\t{\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n\t\t}\n\t\t", "\t\tprecision highp float; \n\t\tuniform float alpha; \n\t\tvoid main(void)\n\t\t{\n\t\t\t\tgl_FragColor = vec4(1.0,1.0,1.0,alpha);\n\t\t}\n\t\t"))
};
GlobWeb.TileWireframeLayer.prototype._detach = function() {
  this.globe.tileManager.removePostRenderer(this);
  GlobWeb.BaseLayer.prototype._detach.call(this)
};
GlobWeb.TileWireframeLayer.prototype.render = function(a) {
  var b = this.globe.renderContext, c = b.gl;
  c.enable(c.BLEND);
  this.program.apply();
  c.uniformMatrix4fv(this.program.uniforms.projectionMatrix, !1, b.projectionMatrix);
  for(var d = this.program.attributes.vertex, e = this.globe.tileManager.tileIndexBuffer, f = null, g = 0;g < a.length;g++) {
    var h = a[g], i = h.state == GlobWeb.Tile.State.LOADED, j = -1 == h.parentIndex;
    mat4.multiply(b.viewMatrix, h.matrix, b.modelViewMatrix);
    c.uniformMatrix4fv(this.program.uniforms.modelViewMatrix, !1, b.modelViewMatrix);
    c.uniform1f(this.program.uniforms.alpha, this.opacity());
    c.bindBuffer(c.ARRAY_BUFFER, h.vertexBuffer);
    c.vertexAttribPointer(d, 3, c.FLOAT, !1, 4 * h.config.vertexSize, 0);
    h = i || j ? e.getWireframe() : e.getSubWireframe(h.parentIndex);
    f != h && (c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, h), f = h);
    c.drawElements(c.LINES, f.numIndices, c.UNSIGNED_SHORT, 0)
  }
  c.disable(c.BLEND)
};
GlobWeb.TileWireframeLayer.prototype.visible = function(a) {
  "boolean" == typeof a && this._visible != a && ((this._visible = a) ? this.globe.tileManager.addPostRenderer(this) : this.globe.tileManager.removePostRenderer(this));
  return this._visible
};
GlobWeb.TileWireframeLayer.prototype.opacity = function(a) {
  return GlobWeb.BaseLayer.prototype.opacity.call(this, a)
};
var Numeric = {lerp:function(a, b, c) {
  return b + (c - b) * a
}, cubicInterpolation:function(a, b, c, d, e) {
  var f = a * a, g = f * a, h = 2 * b[0] - 2 * d[0] + c[0] + e[0], i = 2 * b[1] - 2 * d[1] + c[1] + e[1], j = 2 * b[2] - 2 * d[2] + c[2] + e[2], k = -3 * b[0] + 3 * d[0] - 2 * c[0] - e[0], l = -3 * b[1] + 3 * d[1] - 2 * c[1] - e[1], d = -3 * b[2] + 3 * d[2] - 2 * c[2] - e[2], e = vec3.create();
  e[0] = h * g + k * f + c[0] * a + b[0];
  e[1] = i * g + l * f + c[1] * a + b[1];
  e[2] = j * g + d * f + c[2] * a + b[2];
  return e
}, cubicInterpolationDerivative:function(a, b, c, d, e) {
  var f = a * a, g = 6 * b[0] - 6 * d[0] + 3 * c[0] + 3 * e[0], h = 6 * b[1] - 6 * d[1] + 3 * c[1] + 3 * e[1], i = 6 * b[2] - 6 * d[2] + 3 * c[2] + 3 * e[2], j = -6 * b[0] + 6 * d[0] - 4 * c[0] - 2 * e[0], k = -6 * b[1] + 6 * d[1] - 4 * c[1] - 2 * e[1], b = -6 * b[2] + 6 * d[2] - 4 * c[2] - 2 * e[2], d = vec3.create();
  d[0] = g * f + j * a + c[0];
  d[1] = h * f + k * a + c[1];
  d[2] = i * f + b * a + c[2];
  return d
}, map01:function(a, b, c) {
  return b != c ? (a - b) / (c - b) : 0
}, mapLinear:function(a, b, c, d, e) {
  return Numeric.lerp(Numeric.map01(a, b, c), d, e)
}, easeInQuad:function(a) {
  return a * a
}, easeOutQuad:function(a) {
  a -= 1;
  return 1 - a * a
}, easeInOutQuad:function(a) {
  0.5 > a ? (a += a, a = 0.5 * a * a) : (a = a + a - 2, a = 0.5 + 0.5 * (1 - a * a));
  return a
}, easeOutInQuad:function(a) {
  0.5 > a ? (a = a + a - 1, a = 0.5 * (1 - a * a)) : (a = a + a - 1, a = 0.5 + 0.5 * a * a);
  return a
}, toRadian:function(a) {
  return a * Math.PI / 180
}, toDegree:function(a) {
  return 180 * a / Math.PI
}, pointOnRay:function(a, b, c, d) {
  d || (d = vec3.create());
  vec3.scale(b, c, d);
  vec3.add(d, a, d);
  return d
}, lineIntersection:function(a, b, c, d, e, f, g, h) {
  var i = (h - f) * (c - a) - (g - e) * (d - b);
  return 0 == i ? [-1, -1] : [((g - e) * (b - f) - (h - f) * (a - e)) / i, ((c - a) * (b - f) - (d - b) * (a - e)) / i]
}, raySphereIntersection:function(a, b, c, d) {
  a = vec3.subtract(a, c, vec3.create());
  b = 2 * vec3.dot(b, a);
  d = vec3.dot(a, a) - d * d;
  a = b * b - 4 * d;
  if(0 > a) {
    return-1
  }
  a = Math.sqrt(a);
  d = (-b - a) / 2;
  b = (-b + a) / 2;
  d > b && (a = d, d = b, b = a);
  return 0 > b ? -1 : 0 > d ? b : d
}, roundNumber:function(a, b) {
  return Math.round(a * Math.pow(10, b)) / Math.pow(10, b)
}};
mat4.project = function(a, b, c) {
  c || (c = b);
  mat4.multiplyVec4(a, b, c);
  a = 1 / c[3];
  c[0] *= a;
  c[1] *= a;
  c[2] *= a;
  return c
};
mat4.rotateVec3 = function(a, b, c) {
  c || (c = b);
  var d = b[0], e = b[1], b = b[2];
  c[0] = a[0] * d + a[4] * e + a[8] * b;
  c[1] = a[1] * d + a[5] * e + a[9] * b;
  c[2] = a[2] * d + a[6] * e + a[10] * b;
  return c
};
mat4.fromPositionAttitude = function(a, b, c) {
  c || (c = mat4.create());
  quat4.trueToMat4(b, c);
  c[12] = a[0];
  c[13] = a[1];
  c[14] = a[2];
  return c
};
mat3.toQuat4 = function(a, b) {
  b || (b = quat4.create());
  var c = a[0] + a[4] + a[8];
  0 < c ? (c = 2 * Math.sqrt(c + 1), b[3] = 0.25 * c, b[0] = (a[5] - a[7]) / c, b[1] = (a[6] - a[2]) / c, b[2] = (a[1] - a[3]) / c) : a[0] > a[4] && a[0] > a[8] ? (c = 2 * Math.sqrt(1 + a[0] - a[4] - a[8]), b[3] = (a[5] - a[7]) / c, b[0] = 0.25 * c, b[1] = (a[3] + a[1]) / c, b[2] = (a[6] + a[2]) / c) : a[4] > a[8] ? (c = 2 * Math.sqrt(1 + a[4] - a[0] - a[8]), b[3] = (a[6] - a[2]) / c, b[0] = (a[3] + a[1]) / c, b[1] = 0.25 * c, b[2] = (a[7] + a[5]) / c) : (c = 2 * Math.sqrt(1 + a[8] - a[0] - a[4]), 
  b[3] = (a[1] - a[3]) / c, b[0] = (a[6] + a[2]) / c, b[1] = (a[7] + a[5]) / c, b[2] = 0.25 * c);
  return b
};
mat4.toQuat4 = function(a, b) {
  b || (b = quat4.create());
  var c = a[0] + a[5] + a[10];
  0 < c ? (c = 2 * Math.sqrt(c + 1), b[3] = 0.25 * c, b[0] = (a[6] - a[9]) / c, b[1] = (a[8] - a[2]) / c, b[2] = (a[1] - a[4]) / c) : a[0] > a[5] && a[0] > a[10] ? (c = 2 * Math.sqrt(1 + a[0] - a[5] - a[10]), b[3] = (a[6] - a[9]) / c, b[0] = 0.25 * c, b[1] = (a[4] + a[1]) / c, b[2] = (a[8] + a[2]) / c) : a[5] > a[10] ? (c = 2 * Math.sqrt(1 + a[5] - a[0] - a[10]), b[3] = (a[8] - a[2]) / c, b[0] = (a[4] + a[1]) / c, b[1] = 0.25 * c, b[2] = (a[9] + a[6]) / c) : (c = 2 * Math.sqrt(1 + a[10] - a[0] - 
  a[5]), b[3] = (a[1] - a[4]) / c, b[0] = (a[8] + a[2]) / c, b[1] = (a[9] + a[6]) / c, b[2] = 0.25 * c);
  return b
};
quat4.trueToMat4 = function(a, b) {
  b || (b = mat4.create());
  var c = a[0], d = a[1], e = a[2], f = a[3], g = c + c, h = d + d, i = e + e, j = c * g, k = c * h, c = c * i, l = d * h, d = d * i, e = e * i, g = f * g, h = f * h, f = f * i;
  b[0] = 1 - (l + e);
  b[1] = k + f;
  b[2] = c - h;
  b[3] = 0;
  b[4] = k - f;
  b[5] = 1 - (j + e);
  b[6] = d + g;
  b[7] = 0;
  b[8] = c + h;
  b[9] = d - g;
  b[10] = 1 - (j + l);
  b[11] = 0;
  b[12] = 0;
  b[13] = 0;
  b[14] = 0;
  b[15] = 1;
  return b
};
quat4.trueToMat3 = function(a, b) {
  b || (b = mat3.create());
  var c = a[0], d = a[1], e = a[2], f = a[3], g = c + c, h = d + d, i = e + e, j = c * g, k = c * h, c = c * i, l = d * h, d = d * i, e = e * i, g = f * g, h = f * h, f = f * i;
  b[0] = 1 - (l + e);
  b[1] = k + f;
  b[2] = c - h;
  b[3] = k - f;
  b[4] = 1 - (j + e);
  b[5] = d + g;
  b[6] = c + h;
  b[7] = d - g;
  b[8] = 1 - (j + l);
  return b
};
quat4.trueSlerp = function(a, b, c, d) {
  var e = a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  d || (d = quat4.create());
  0 > e ? (e = -e, d[0] = -b[0], d[1] = -b[1], d[2] = -b[2], d[3] = -b[3]) : (d[0] = b[0], d[1] = b[1], d[2] = b[2], d[3] = b[3]);
  if(0.9999 > Math.abs(e)) {
    var b = Math.sqrt(1 - e * e), f = Math.atan2(b, e), e = Math.sin((1 - c) * f) / b, c = Math.sin(c * f) / b;
    d[0] = a[0] * e + c * d[0];
    d[1] = a[1] * e + c * d[1];
    d[2] = a[2] * e + c * d[2];
    d[3] = a[3] * e + c * d[3]
  }else {
    d[0] = Numeric.lerp(c, a[0], b[0]), d[1] = Numeric.lerp(c, a[1], b[1]), d[2] = Numeric.lerp(c, a[2], b[2]), d[3] = Numeric.lerp(c, a[3], b[3]), quat4.normalize(d)
  }
  return d
};
GlobWeb.Animation = function() {
  this.pauseTime = this.startTime = -1;
  this.globe = null
};
GlobWeb.Animation.prototype._unregisterActive = function() {
  var a = this.globe.activeAnimations.indexOf(this);
  this.globe.activeAnimations.splice(a, 1)
};
GlobWeb.Animation.prototype.getStatus = function() {
  return-1 == this.startTime ? "STOPPED" : -1 == this.pauseTime ? "RUNNING" : "PAUSED"
};
GlobWeb.Animation.prototype.start = function() {
  if(this.globe && (-1 == this.startTime || -1 != this.pauseTime)) {
    var a = Date.now();
    -1 == this.startTime ? this.startTime = a : (this.startTime += a - this.pauseTime, this.pauseTime = -1);
    this.globe.activeAnimations.push(this);
    this.globe.renderContext.requestFrame()
  }
};
GlobWeb.Animation.prototype.pause = function() {
  this.globe && (-1 != this.startTime && -1 == this.pauseTime) && (this.pauseTime = Date.now(), this._unregisterActive(this))
};
GlobWeb.Animation.prototype.stop = function() {
  this.pauseTime = this.startTime = -1;
  if(this.onstop) {
    this.onstop()
  }
  this._unregisterActive(this)
};
GlobWeb.InterpolatedAnimation = function(a, b, c, d, e) {
  GlobWeb.Animation.prototype.constructor.call(this);
  this.values = [[0, b], [1, c]];
  this.duration = a;
  this.interpolationFunction = d;
  this.setFunction = e
};
GlobWeb.inherits(GlobWeb.Animation, GlobWeb.InterpolatedAnimation);
GlobWeb.InterpolatedAnimation.prototype.addValue = function(a, b) {
  for(var c = this.values.length, d = 0;d < c && this.values[d][0] < a;) {
    d++
  }
  this.values.splice(d, 0, [a, b])
};
GlobWeb.InterpolatedAnimation.prototype.start = function() {
  GlobWeb.Animation.prototype.start.call(this);
  this.setFunction(this.startValue)
};
GlobWeb.InterpolatedAnimation.prototype.stop = function() {
  GlobWeb.Animation.prototype.stop.call(this);
  this.setFunction(this.endValue)
};
GlobWeb.InterpolatedAnimation.prototype.update = function(a) {
  a = Numeric.map01(a, this.startTime, this.startTime + this.duration);
  if(1 <= a) {
    this.stop()
  }else {
    for(var b = this.values.length, c = 0;c < b && this.values[c][0] < a;) {
      c++
    }
    c = Math.min(c, b - 1);
    b = Math.max(0, c - 1);
    a = Numeric.map01(a, this.values[b][0], this.values[c][0]);
    a = this.interpolationFunction(a, this.values[b][1], this.values[c][1]);
    this.setFunction(a)
  }
};
GlobWeb.SegmentedAnimation = function(a, b) {
  GlobWeb.Animation.prototype.constructor.call(this);
  this.segments = [];
  this.duration = a;
  this.valueSetter = b
};
GlobWeb.inherits(GlobWeb.Animation, GlobWeb.SegmentedAnimation);
GlobWeb.SegmentedAnimation.Segment = function(a, b, c, d, e) {
  this.start = a;
  this.startValue = b;
  this.end = c;
  this.endValue = d;
  this.interpolator = e
};
GlobWeb.SegmentedAnimation.prototype.addSegment = function(a, b, c, d, e) {
  for(var f = this.segments.length, g = 0;g < f && this.segments[g].end <= a;) {
    g++
  }
  this.segments.splice(g, 0, new GlobWeb.SegmentedAnimation.Segment(a, b, c, d, e))
};
GlobWeb.SegmentedAnimation.prototype.start = function() {
  GlobWeb.Animation.prototype.start.call(this);
  this.valueSetter(this.segments[0].startValue)
};
GlobWeb.SegmentedAnimation.prototype.stop = function() {
  GlobWeb.Animation.prototype.stop.call(this);
  this.valueSetter(this.segments[this.segments.length - 1].endValue)
};
GlobWeb.SegmentedAnimation.prototype.update = function(a) {
  a = Numeric.map01(a, this.startTime, this.startTime + this.duration);
  if(1 <= a) {
    this.stop()
  }else {
    for(var b = this.segments.length, c = 0;c < b && this.segments[c].end < a;) {
      c++
    }
    c = Math.min(c, b - 1);
    a = Numeric.map01(a, this.segments[c].start, this.segments[c].end);
    a = this.segments[c].interpolator(a, this.segments[c].startValue, this.segments[c].endValue);
    this.valueSetter(a)
  }
};
GlobWeb.CoordinateSystem = {radius:1, heightScale:1 / 6356752.3142, realEarthRadius:6356752.3142};
GlobWeb.CoordinateSystem.fromGeoTo3D = function(a, b) {
  b || (b = Array(3));
  var c = Numeric.toRadian(a[0]), d = Numeric.toRadian(a[1]), e = Math.cos(d), f = GlobWeb.CoordinateSystem.radius + (2 < a.length ? GlobWeb.CoordinateSystem.heightScale * a[2] : 0);
  b[0] = f * Math.cos(c) * e;
  b[1] = f * Math.sin(c) * e;
  b[2] = f * Math.sin(d);
  return b
};
GlobWeb.CoordinateSystem.from3DToGeo = function(a, b) {
  b || (b = Array(3));
  var c = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]), d = Math.atan2(a[1] / c, a[0] / c), e = Math.asin(a[2] / c);
  b[0] = Numeric.toDegree(d);
  b[1] = Numeric.toDegree(e);
  b[2] = GlobWeb.CoordinateSystem.realEarthRadius * Math.abs(c - GlobWeb.CoordinateSystem.radius);
  return b
};
GlobWeb.CoordinateSystem.from3DToEquatorial = function(a, b) {
  b || (b = Array(3));
  var c = [];
  GlobWeb.CoordinateSystem.from3DToGeo(a, c);
  GlobWeb.CoordinateSystem.fromGeoToEquatorial(c, b);
  return b
};
GlobWeb.CoordinateSystem.fromEquatorialTo3D = function(a, b) {
  b || (b = Array(3));
  var c = [];
  GlobWeb.CoordinateSystem.fromEquatorialToGeo(a, c);
  GlobWeb.CoordinateSystem.fromGeoTo3D(c, b);
  return b
};
GlobWeb.CoordinateSystem.fromEquatorialToGeo = function(a, b) {
  b || (b = []);
  var c = a[0].split(" "), d = parseFloat(c[0]), e = parseFloat(c[1]), c = parseFloat(c[2]);
  b[0] = 15 * (d + e / 60 + c / 3600);
  180 < b[0] && (b[0] -= 360);
  var f = a[1].split(" "), d = parseFloat(f[0]), e = parseFloat(f[1]), c = parseFloat(f[2]);
  b[1] = ("-" == f[0][0] ? -1 : 1) * (Math.abs(d) + e / 60 + c / 3600);
  return b
};
GlobWeb.CoordinateSystem.fromGeoToEquatorial = function(a, b) {
  b || (b = []);
  var c = a[0];
  0 > c && (c += 360);
  b[0] = GlobWeb.CoordinateSystem.fromDegreesToHMS(c);
  b[1] = GlobWeb.CoordinateSystem.fromDegreesToDMS(a[1]);
  return b
};
GlobWeb.CoordinateSystem.fromDegreesToDMS = function(a) {
  var b = Math.abs(a);
  deg = Math.floor(b);
  decimal = 60 * (b - deg);
  min = Math.floor(decimal);
  sec = 60 * (decimal - min);
  return(0 <= a ? "" : "-") + deg + String.fromCharCode(176) + " " + min + "' " + Numeric.roundNumber(sec, 2) + '"'
};
GlobWeb.CoordinateSystem.fromDegreesToHMS = function(a) {
  var b = Math.abs(a / 15), a = Math.floor(b), b = 60 * (b - a), c = Math.floor(b);
  return a + "h " + c + "m " + Numeric.roundNumber(60 * (b - c), 2) + "s"
};
GlobWeb.CoordinateSystem.getLocalTransform = function(a, b) {
  b || (b = mat4.create());
  var c = a[0] * Math.PI / 180, d = a[1] * Math.PI / 180, d = [Math.cos(c) * Math.cos(d), Math.sin(c) * Math.cos(d), Math.sin(d)], c = [-Math.sin(c), Math.cos(c), 0], e = vec3.create();
  vec3.cross(d, c, e);
  b[0] = c[0];
  b[1] = c[1];
  b[2] = c[2];
  b[3] = 0;
  b[4] = e[0];
  b[5] = e[1];
  b[6] = e[2];
  b[7] = 0;
  b[8] = d[0];
  b[9] = d[1];
  b[10] = d[2];
  b[11] = 0;
  b[12] = 0;
  b[13] = 0;
  b[14] = 0;
  b[15] = 1;
  return b
};
GlobWeb.CoordinateSystem.getLHVTransform = function(a, b) {
  b || (b = mat4.create());
  var c = a[0] * Math.PI / 180, d = a[1] * Math.PI / 180, d = [Math.cos(c) * Math.cos(d), Math.sin(c) * Math.cos(d), Math.sin(d)], c = [-Math.sin(c), Math.cos(c), 0], e = vec3.create();
  vec3.cross(d, c, e);
  var f = GlobWeb.CoordinateSystem.fromGeoTo3D(a);
  b[0] = c[0];
  b[1] = c[1];
  b[2] = c[2];
  b[3] = 0;
  b[4] = e[0];
  b[5] = e[1];
  b[6] = e[2];
  b[7] = 0;
  b[8] = d[0];
  b[9] = d[1];
  b[10] = d[2];
  b[11] = 0;
  b[12] = f[0];
  b[13] = f[1];
  b[14] = f[2];
  b[15] = 1;
  return b
};
GlobWeb.CoordinateSystem.getSideVector = function(a, b) {
  b[0] = a[0];
  b[1] = a[1];
  b[2] = a[2];
  return b
};
GlobWeb.CoordinateSystem.getFrontVector = function(a, b) {
  b[0] = a[4];
  b[1] = a[5];
  b[2] = a[6];
  return b
};
GlobWeb.CoordinateSystem.getUpVector = function(a, b) {
  b[0] = a[8];
  b[1] = a[9];
  b[2] = a[10];
  return b
};
GlobWeb.Plane = function() {
  this.normal = vec3.create([0, 0, 0]);
  this.d = 0
};
GlobWeb.Plane.prototype.init = function(a, b, c) {
  var d = [], e = [];
  vec3.subtract(b, a, d);
  vec3.subtract(c, a, e);
  vec3.cross(d, e, this.normal);
  vec3.normalize(this.normal);
  this.d = -vec3.dot(a, this.normal)
};
GlobWeb.Plane.prototype.transform = function(a) {
  var b = [this.normal[0], this.normal[1], this.normal[2], this.d];
  mat4.multiplyVec4(a, b);
  this.normal[0] = b[0];
  this.normal[1] = b[1];
  this.normal[2] = b[2];
  this.d = b[3]
};
GlobWeb.Plane.prototype.intersectSphere = function(a, b) {
  var c = vec3.dot(a, this.normal) + this.d;
  return c > b ? 1 : c < -b ? -1 : 0
};
GlobWeb.Plane.prototype.distance = function(a) {
  return a[0] * this.normal[0] + a[1] * this.normal[1] + a[2] * this.normal[2] + this.d
};
GlobWeb.Plane.prototype.intersectBoundingBox = function(a) {
  var b = (0 <= this.normal[0] ? 1 : 0) | (0 <= this.normal[1] ? 2 : 0) | (0 <= this.normal[2] ? 4 : 0);
  return 0 < this.distance(a.getCorner(~b & 7)) ? 1 : 0 > this.distance(a.getCorner(b)) ? -1 : 0
};
GlobWeb.Frustum = function() {
  this.planes = [new GlobWeb.Plane, new GlobWeb.Plane, new GlobWeb.Plane, new GlobWeb.Plane]
};
GlobWeb.Frustum.prototype.compute = function(a) {
  var b = mat4.create();
  mat4.inverse(a, b);
  var a = mat4.project(b, [-1, -1, -1, 1]), c = mat4.project(b, [-1, 1, -1, 1]), d = mat4.project(b, [1, 1, -1, 1]), b = mat4.project(b, [1, -1, -1, 1]);
  this.planes[0].init([0, 0, 0], a, c);
  this.planes[1].init([0, 0, 0], c, d);
  this.planes[2].init([0, 0, 0], d, b);
  this.planes[3].init([0, 0, 0], b, a)
};
GlobWeb.Frustum.prototype.transform = function(a, b) {
  var c = mat4.create();
  mat4.inverse(b, c);
  this.inverseTransform(a, c)
};
GlobWeb.Frustum.prototype.inverseTransform = function(a, b) {
  for(var c = 0;c < a.planes.length;c++) {
    var d = a.planes[c], e = d.normal[0], f = d.normal[1], g = d.normal[2], h = d.d, d = this.planes[c];
    d.normal[0] = b[0] * e + b[1] * f + b[2] * g + b[3] * h;
    d.normal[1] = b[4] * e + b[5] * f + b[6] * g + b[7] * h;
    d.normal[2] = b[8] * e + b[9] * f + b[10] * g + b[11] * h;
    d.d = b[12] * e + b[13] * f + b[14] * g + b[15] * h
  }
};
GlobWeb.Frustum.prototype.containsSphere = function(a, b) {
  for(var c = 1, d = 0;d < this.planes.length;d++) {
    var e = this.planes[d].normal, e = a[0] * e[0] + a[1] * e[1] + a[2] * e[2] + this.planes[d].d;
    if(e <= b) {
      if(e < -b) {
        return-1
      }
      c = 0
    }
  }
  return c
};
GlobWeb.Frustum.prototype.containsBoundingBox = function(a) {
  for(var b = 0;b < this.planes.length;b++) {
    var c = this.planes[b];
    if(0 > (0 <= c.normal[0] ? a.max[0] : a.min[0]) * c.normal[0] + (0 <= c.normal[1] ? a.max[1] : a.min[1]) * c.normal[1] + (0 <= c.normal[2] ? a.max[2] : a.min[2]) * c.normal[2] + c.d) {
      return!1
    }
  }
  return!0
};
GlobWeb.RenderContext = function(a) {
  this.shadersPath = a.shadersPath || "../shaders/";
  this.tileErrorTreshold = a.tileErrorTreshold || 4;
  this.lighting = a.lighting || !1;
  this.continuousRendering = a.continuousRendering || !1;
  var b = this.stats = null;
  if(!a.canvas) {
    throw"GlobWeb : no canvas in options";
  }
  b = "string" == typeof a.canvas ? document.getElementById(a.canvas) : a.canvas;
  if(!b instanceof HTMLCanvasElement) {
    throw"GlobWeb : invalid canvas";
  }
  for(var c = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"], d = null, e = 0;e < c.length && null == d;++e) {
    try {
      d = b.getContext(c[e], a.contextAttribs)
    }catch(f) {
    }
  }
  if(null == d) {
    throw"GlobWeb : WebGL context cannot be initialized";
  }
  a.backgroundColor ? (a = a.backgroundColor, d.clearColor(a[0], a[1], a[2], a[3])) : d.clearColor(0, 0, 0, 1);
  d.pixelStorei(d.UNPACK_COLORSPACE_CONVERSION_WEBGL, d.NONE);
  d.enable(d.DEPTH_TEST);
  d.enable(d.CULL_FACE);
  this.viewMatrix = mat4.create();
  this.modelViewMatrix = mat4.create();
  this.projectionMatrix = mat4.create();
  this.gl = d;
  this.canvas = b;
  this.frustum = new GlobWeb.Frustum;
  this.worldFrustum = new GlobWeb.Frustum;
  this.localFrustum = new GlobWeb.Frustum;
  this.eyePosition = vec3.create();
  this.eyeDirection = vec3.create();
  this.minNear = 1E-5;
  this.near = GlobWeb.RenderContext.minNear;
  this.far = 6;
  this.numActiveAttribArray = 0;
  this.frameRequested = !1;
  this.fov = 45;
  window.requestAnimationFrame || (window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(a) {
    window.setTimeout(a, 1E3 / 60)
  })
};
GlobWeb.RenderContext.prototype.requestFrame = function() {
  this.frameRequested || (window.requestAnimationFrame(this.frame), this.frameRequested = !0)
};
GlobWeb.RenderContext.prototype.updateViewDependentProperties = function() {
  var a = mat4.create();
  mat4.inverse(this.viewMatrix, a);
  vec3.set([0, 0, 0], this.eyePosition);
  mat4.multiplyVec3(a, this.eyePosition);
  vec3.set([0, 0, -1], this.eyeDirection);
  mat4.rotateVec3(a, this.eyeDirection);
  this.pixelSizeVector = this.computePixelSizeVector();
  mat4.perspective(this.fov, this.canvas.width / this.canvas.height, this.minNear, this.far, this.projectionMatrix);
  this.frustum.compute(this.projectionMatrix);
  this.worldFrustum.inverseTransform(this.frustum, this.viewMatrix)
};
GlobWeb.RenderContext.prototype.getXYRelativeToCanvas = function(a) {
  var b = [];
  a.pageX || a.pageY ? (b[0] = a.pageX, b[1] = a.pageY) : (b[0] = a.clientX + document.body.scrollLeft + document.documentElement.scrollLeft, b[1] = a.clientY + document.body.scrollTop + document.documentElement.scrollTop);
  for(a = this.canvas;a;) {
    b[0] -= a.offsetLeft, b[1] -= a.offsetTop, a = a.offsetParent
  }
  return b
};
GlobWeb.RenderContext.prototype.computePixelSizeVector = function(a) {
  var b = this.canvas.width, c = this.canvas.height, d = this.projectionMatrix, a = a || this.viewMatrix, e = 0.5 * d[0] * b, b = 0.5 * d[8] * b + 0.5 * d[11] * b, b = [a[0] * e + a[2] * b, a[4] * e + a[6] * b, a[8] * e + a[10] * b], e = 0.5 * d[5] * c, c = 0.5 * d[9] * c + 0.5 * d[11] * c, c = [a[1] * e + a[2] * c, a[5] * e + a[6] * c, a[9] * e + a[10] * c], e = d[11], d = [a[2] * e, a[6] * e, a[10] * e, a[14] * e + a[15] * d[15]], a = 0.7071067811 / Math.sqrt(vec3.dot(b, b) + vec3.dot(c, c));
  d[0] *= a;
  d[1] *= a;
  d[2] *= a;
  d[3] *= a;
  return d
};
GlobWeb.RenderContext.prototype.get3DFromPixel = function(a, b) {
  var c = 2 * (a / this.canvas.width) - 1, d = -(2 * (b / this.canvas.height) - 1), e = mat4.create();
  mat4.multiply(this.projectionMatrix, this.viewMatrix, e);
  mat4.inverse(e);
  var f = [];
  mat4.multiplyVec4(e, [c, d, 0, 1], f);
  f[0] /= f[3];
  f[1] /= f[3];
  f[2] /= f[3];
  mat4.inverse(this.viewMatrix, e);
  c = [e[12], e[13], e[14]];
  d = vec3.create();
  vec3.subtract(f, c, d);
  vec3.normalize(d);
  f = Numeric.raySphereIntersection(c, d, [0, 0, 0], GlobWeb.CoordinateSystem.radius);
  return 0 <= f ? Numeric.pointOnRay(c, d, f) : null
};
GlobWeb.RenderContext.prototype.getPixelFrom3D = function(a, b, c) {
  var d = mat4.create();
  mat4.multiply(this.projectionMatrix, this.viewMatrix, d);
  point3D = [];
  mat4.multiply(d, [a, b, c, 0], point3D);
  a = Math.round((1 + point3D[0]) / 2 * this.canvas.width);
  b = Math.round((1 - point3D[1]) / 2 * this.canvas.height);
  return[a, b]
};
GlobWeb.RenderContext.prototype.createNonPowerOfTwoTextureFromImage = function(a) {
  var b = this.gl, c = b.createTexture();
  b.bindTexture(b.TEXTURE_2D, c);
  b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, b.RGBA, b.UNSIGNED_BYTE, a);
  b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.LINEAR);
  b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.LINEAR);
  b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE);
  b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE);
  return c
};
GlobWeb.Program = function(a) {
  this.renderContext = a;
  this.glProgram = null;
  this.attributes = {};
  this.uniforms = {};
  this.numActiveAttribArray = 0
};
GlobWeb.Program.prototype.createShader = function(a, b) {
  var c = this.renderContext.gl, d = c.createShader(a);
  c.shaderSource(d, b);
  c.compileShader(d);
  return!c.getShaderParameter(d, c.COMPILE_STATUS) ? (console.log("Shader compilation error: " + c.getShaderInfoLog(d)), console.log(b), c.deleteShader(d), null) : d
};
GlobWeb.Program.prototype.createFromSource = function(a, b) {
  var c = this.renderContext.gl, d = this.createShader(c.VERTEX_SHADER, a), e = this.createShader(c.FRAGMENT_SHADER, b);
  if(null == d || null == e) {
    return!1
  }
  this.glProgram = c.createProgram();
  c.attachShader(this.glProgram, d);
  c.attachShader(this.glProgram, e);
  c.linkProgram(this.glProgram);
  if(!c.getProgramParameter(this.glProgram, c.LINK_STATUS)) {
    return console.log("Program link error: " + c.getProgramInfoLog(this.glProgram)), c.deleteShader(d), c.deleteShader(e), c.deleteProgram(this.glProgram), this.glProgram = null, !1
  }
  e = c.getProgramParameter(this.glProgram, c.ACTIVE_ATTRIBUTES);
  for(d = this.numActiveAttribArray = 0;d < e;++d) {
    var f = c.getActiveAttrib(this.glProgram, d), g = c.getAttribLocation(this.glProgram, f.name);
    this.attributes[f.name] = g;
    g + 1 > this.numActiveAttribArray && (this.numActiveAttribArray = g + 1)
  }
  e = c.getProgramParameter(this.glProgram, c.ACTIVE_UNIFORMS);
  for(d = 0;d < e;++d) {
    f = c.getActiveUniform(this.glProgram, d), this.uniforms[f.name] = c.getUniformLocation(this.glProgram, f.name)
  }
  return!0
};
GlobWeb.Program.prototype.loadFromFile = function(a, b) {
  var c = new XMLHttpRequest;
  c.open("get", this.renderContext.shadersPath + a, !1);
  c.send(null);
  var d = c.responseText;
  c.open("get", this.renderContext.shadersPath + b, !1);
  c.send(null);
  return this.createFromSource(d, c.responseText)
};
GlobWeb.Program.prototype.apply = function() {
  var a = this.renderContext, b = a.gl;
  b.useProgram(this.glProgram);
  for(var c = a.numActiveAttribArray;c < this.numActiveAttribArray;c++) {
    b.enableVertexAttribArray(c)
  }
  for(c = this.numActiveAttribArray;c < a.numActiveAttribArray;c++) {
    b.disableVertexAttribArray(c)
  }
  a.numActiveAttribArray = this.numActiveAttribArray
};
GlobWeb.TileIndexBuffer = function(a, b) {
  this.renderContext = a;
  this.config = b;
  this.solidIndexBuffer = null;
  this.subSolidIndexBuffer = [null, null, null, null];
  this.wireframeIndexBuffer = null;
  this.subWireframeIndexBuffer = [null, null, null, null];
  this.subIndices = [null, null, null, null]
};
GlobWeb.TileIndexBuffer.prototype.reset = function() {
  for(var a = this.renderContext.gl, b = 0;4 > b;b++) {
    this.subSolidIndexBuffer[b] && (a.deleteBuffer(this.subSolidIndexBuffer[b]), this.subSolidIndexBuffer[b] = null)
  }
  this.solidIndexBuffer && (a.deleteBuffer(this.solidIndexBuffer), this.solidIndexBuffer = null);
  for(b = 0;4 > b;b++) {
    this.subWireframeIndexBuffer[b] && (a.deleteBuffer(this.subWireframeIndexBuffer[b]), this.subWireframeIndexBuffer[b] = null)
  }
  this.wireframeIndexBuffer && (a.deleteBuffer(this.wireframeIndexBuffer), this.wireframeIndexBuffer = null)
};
GlobWeb.TileIndexBuffer.prototype.getSubSolid = function(a) {
  if(null == this.subSolidIndexBuffer[a]) {
    for(var b = a % 2, c = Math.floor(a / 2), d = this.config.tesselation, e = (d - 1) / 2, f = [], g = e * c;g < e * (c + 1);g++) {
      for(var h = e * b;h < e * (b + 1);h++) {
        f.push(g * d + h), f.push((g + 1) * d + h), f.push(g * d + h + 1), f.push(g * d + h + 1), f.push((g + 1) * d + h), f.push((g + 1) * d + h + 1)
      }
    }
    this.subIndices[a] = f;
    if(this.config.skirt) {
      for(var i = 0 == c ? d * d : d * d + 4 * d, j = 0 == c ? 0 : e * d, g = e * b;g < e * (b + 1);g++) {
        f.push(i + g), f.push(j + g), f.push(i + g + 1), f.push(i + g + 1), f.push(j + g), f.push(j + g + 1)
      }
      i = 0 == c ? d * d + 4 * d : d * d + d;
      j = 0 == c ? e * d : (d - 1) * d;
      for(g = e * b;g < e * (b + 1);g++) {
        f.push(j + g), f.push(i + g), f.push(j + g + 1), f.push(j + g + 1), f.push(i + g), f.push(i + g + 1)
      }
      i = 0 == b ? d * d + 2 * d : d * d + 5 * d;
      j = 0 == b ? 0 : e;
      for(h = e * c;h < e * (c + 1);h++) {
        f.push(i + h), f.push(i + h + 1), f.push(j + h * d), f.push(j + h * d), f.push(i + h + 1), f.push(j + (h + 1) * d)
      }
      i = 0 == b ? d * d + 5 * d : d * d + 3 * d;
      j = 0 == b ? e : d - 1;
      for(h = e * c;h < e * (c + 1);h++) {
        f.push(h * d + j), f.push((h + 1) * d + j), f.push(i + h), f.push(i + h), f.push((h + 1) * d + j), f.push(i + h + 1)
      }
    }
    b = this.renderContext.gl;
    c = b.createBuffer();
    b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, c);
    b.bufferData(b.ELEMENT_ARRAY_BUFFER, new Uint16Array(f), b.STATIC_DRAW);
    c.numIndices = f.length;
    this.subSolidIndexBuffer[a] = c
  }
  return this.subSolidIndexBuffer[a]
};
GlobWeb.TileIndexBuffer.prototype.getSubWireframe = function(a) {
  if(null == this.subWireframeIndexBuffer[a]) {
    for(var b = a % 2, c = Math.floor(a / 2), d = this.config.tesselation, e = (d - 1) / 2, f = [], g = e * c;g < e * (c + 1) + 1;g++) {
      for(var h = e * b;h < e * (b + 1);h++) {
        f.push(g * d + h), f.push(g * d + h + 1)
      }
    }
    for(g = e * b;g < e * (b + 1) + 1;g++) {
      for(h = e * c;h < e * (c + 1);h++) {
        f.push(h * d + g), f.push((h + 1) * d + g)
      }
    }
    b = this.renderContext.gl;
    c = b.createBuffer();
    b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, c);
    b.bufferData(b.ELEMENT_ARRAY_BUFFER, new Uint16Array(f), b.STATIC_DRAW);
    c.numIndices = f.length;
    this.subWireframeIndexBuffer[a] = c
  }
  return this.subWireframeIndexBuffer[a]
};
GlobWeb.TileIndexBuffer.prototype.getSolid = function() {
  if(null == this.solidIndexBuffer) {
    for(var a = this.config.tesselation, b = [], c = 0;c < a - 1;c++) {
      for(var d = 0;d < a - 1;d++) {
        b.push(c * a + d), b.push((c + 1) * a + d), b.push(c * a + d + 1), b.push(c * a + d + 1), b.push((c + 1) * a + d), b.push((c + 1) * a + d + 1)
      }
    }
    if(this.config.skirt) {
      for(var e = a * a, d = 0;d < a - 1;d++) {
        b.push(e + d), b.push(d), b.push(e + d + 1), b.push(e + d + 1), b.push(d), b.push(d + 1)
      }
      e += a;
      for(d = 0;d < a - 1;d++) {
        b.push((a - 1) * a + d), b.push(e + d), b.push((a - 1) * a + d + 1), b.push((a - 1) * a + d + 1), b.push(e + d), b.push(e + d + 1)
      }
      e += a;
      for(c = 0;c < a - 1;c++) {
        b.push(e + c), b.push(e + c + 1), b.push(c * a), b.push(c * a), b.push(e + c + 1), b.push((c + 1) * a)
      }
      e += a;
      for(c = 0;c < a - 1;c++) {
        b.push(c * a + a - 1), b.push((c + 1) * a + a - 1), b.push(e + c), b.push(e + c), b.push((c + 1) * a + a - 1), b.push(e + c + 1)
      }
    }
    a = this.renderContext.gl;
    c = a.createBuffer();
    a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, c);
    a.bufferData(a.ELEMENT_ARRAY_BUFFER, new Uint16Array(b), a.STATIC_DRAW);
    this.numIndices = b.length;
    this.solidIndexBuffer = c;
    this.solidIndexBuffer.numIndices = b.length
  }
  return this.solidIndexBuffer
};
GlobWeb.TileIndexBuffer.prototype.getWireframe = function() {
  if(null == this.wireframeIndexBuffer) {
    for(var a = this.config.tesselation, b = [], c = 0;c < a;c++) {
      for(var d = 0;d < a - 1;d++) {
        b.push(c * a + d), b.push(c * a + d + 1)
      }
    }
    for(c = 0;c < a;c++) {
      for(d = 0;d < a - 1;d++) {
        b.push(d * a + c), b.push((d + 1) * a + c)
      }
    }
    a = this.renderContext.gl;
    c = a.createBuffer();
    a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, c);
    a.bufferData(a.ELEMENT_ARRAY_BUFFER, new Uint16Array(b), a.STATIC_DRAW);
    this.numIndices = b.length;
    c.numIndices = b.length;
    this.wireframeIndexBuffer = c
  }
  return this.wireframeIndexBuffer
};
GlobWeb.Tile = function() {
  this.parent = null;
  this.parentIndex = -1;
  this.vertexBuffer = this.texture = this.vertices = this.children = null;
  this.texTransform = [1, 1, 0, 0];
  this.inverseMatrix = this.matrix = null;
  this.bbox = new GlobWeb.BoundingBox;
  this.distance = this.radius = 0;
  this.closestPointToEye = [0, 0, 0];
  this.extension = {};
  this.state = GlobWeb.Tile.State.NONE;
  this.config = null
};
GlobWeb.Tile.State = {ERROR:-10, NONE:0, REQUESTED:1, LOADING:2, LOADED:3};
GlobWeb.Tile.prototype.computePosition = function(a, b) {
  for(var c = Math.floor(b), d = b - c, e = Math.floor(a), f = a - e, g = this.config.tesselation, h = this.config.vertexSize, c = h * (c * g + e), e = [0, 0, 0], i = 0;3 > i;i++) {
    e[i] = (1 - d) * (1 - f) * this.vertices[c + i] + d * (1 - f) * this.vertices[c + h * g + i] + d * f * this.vertices[c + h * g + h + i] + (1 - d) * f * this.vertices[c + h + i]
  }
  return e
};
GlobWeb.Tile.prototype.initFromParent = function(a, b, c) {
  this.parent = a;
  this.parentIndex = 2 * c + b;
  this.matrix = a.matrix;
  this.inverseMatrix = a.inverseMatrix;
  this.texture = a.texture;
  this.config = a.config;
  this.vertexBuffer = a.vertexBuffer;
  for(var d = this.config.tesselation, e = (d - 1) / 2, f = 0;f <= e;f++) {
    for(var g = this.config.vertexSize * ((f + c * e) * d + b * e), h = 0;h <= e;h++) {
      this.bbox.extend(a.vertices[g], a.vertices[g + 1], a.vertices[g + 2]), g += this.config.vertexSize
    }
  }
  this.radius = this.bbox.getRadius()
};
GlobWeb.Tile.prototype.needsToBeRefined = function(a) {
  if(this.distance < this.radius) {
    return!0
  }
  var b = this.matrix, c = this.closestPointToEye, d = a.pixelSizeVector;
  return this.radius / this.config.imageSize / ((b[0] * c[0] + b[4] * c[1] + b[8] * c[2] + b[12]) * d[0] + (b[1] * c[0] + b[5] * c[1] + b[9] * c[2] + b[13]) * d[1] + (b[2] * c[0] + b[6] * c[1] + b[10] * c[2] + b[14]) * d[2] + d[3]) > a.tileErrorTreshold
};
GlobWeb.Tile.prototype.isCulled = function(a) {
  var b = this.inverseMatrix, c = a.eyePosition, d = b[0] * c[0] + b[4] * c[1] + b[8] * c[2] + b[12], e = b[1] * c[0] + b[5] * c[1] + b[9] * c[2] + b[13], c = b[2] * c[0] + b[6] * c[1] + b[10] * c[2] + b[14], f = Math.sqrt(d * d + e * e + c * c);
  if(f < this.radius) {
    return this.distance = 0, a.near = a.minNear, a.far = Math.max(a.far, 2 * this.radius), !1
  }
  var g = this.closestPointToEye;
  g[0] = Math.min(Math.max(d, this.bbox.min[0]), this.bbox.max[0]);
  g[1] = Math.min(Math.max(e, this.bbox.min[1]), this.bbox.max[1]);
  g[2] = Math.min(Math.max(c, this.bbox.min[2]), this.bbox.max[2]);
  var h = a.eyeDirection, i = -(b[0] * h[0] + b[4] * h[1] + b[8] * h[2]), j = -(b[1] * h[0] + b[5] * h[1] + b[9] * h[2]), b = -(b[2] * h[0] + b[6] * h[1] + b[10] * h[2]), h = g[0], k = g[1], l = g[2] + GlobWeb.CoordinateSystem.radius, m = Math.sqrt(h * h + k * k + l * l);
  this.distance = f;
  f = (i * h + j * k + b * l) / m * this.config.cullSign;
  if(-0.05 > f) {
    return!0
  }
  f = a.localFrustum;
  f.inverseTransform(a.worldFrustum, this.matrix);
  return f.containsBoundingBox(this.bbox) ? (d = -(i * g[0] + j * g[1] + b * g[2] - (i * d + j * e + b * c)), a.near = Math.max(a.minNear, Math.min(a.near, d)), a.far = Math.max(a.far, d + 2 * this.radius), !1) : !0
};
GlobWeb.Tile.prototype.dispose = function(a, b) {
  if(this.state == GlobWeb.Tile.State.LOADED) {
    b.disposeGLBuffer(this.vertexBuffer);
    b.disposeGLTexture(this.texture);
    for(var c in this.extension) {
      this.extension[c].dispose && this.extension[c].dispose(a, b)
    }
    this.parent = this.texture = this.vertexBuffer = null;
    this.state = GlobWeb.Tile.State.NONE
  }
};
GlobWeb.Tile.prototype.deleteChildren = function(a, b) {
  if(this.children) {
    for(var c = 0;4 > c;c++) {
      this.children[c].dispose(a, b), this.children[c].deleteChildren(a, b)
    }
    this.children = null
  }
};
GlobWeb.Tile.prototype.buildSkirtVertices = function(a, b, c, d) {
  for(var e = this.vertices, f = 0.05 * this.radius, g = this.config.tesselation, h = 0;h < g;h++) {
    var i = e[b] - a[0], j = e[b + 1] - a[1], k = e[b + 2] - a[2], l = f / Math.sqrt(i * i + j * j + k * k), i = i * l, j = j * l, k = k * l;
    e[d] = e[b] - i;
    e[d + 1] = e[b + 1] - j;
    e[d + 2] = e[b + 2] - k;
    for(i = 3;i < this.config.vertexSize;i++) {
      e[d + i] = e[b + i]
    }
    d += this.config.vertexSize;
    b += c
  }
};
GlobWeb.Tile.prototype.generateNormals = function() {
  for(var a = this.config.tesselation, b = this.config.vertexSize, c = b * a, d = 0, e = 0;e < a;e++) {
    for(var f = e == a - 1 ? 0 : c, g = 0 == e ? 0 : -c, h = 0;h < a;h++) {
      var i = h == a - 1 ? 0 : b, j = 0 == h ? 0 : -b, i = vec3.cross([this.vertices[d + i] - this.vertices[d + j], this.vertices[d + i + 1] - this.vertices[d + j + 1], this.vertices[d + i + 2] - this.vertices[d + j + 2]], [this.vertices[d + f] - this.vertices[d + g], this.vertices[d + f + 1] - this.vertices[d + g + 1], this.vertices[d + f + 2] - this.vertices[d + g + 2]], []);
      vec3.normalize(i);
      this.vertices[d + 3] = i[0];
      this.vertices[d + 4] = i[1];
      this.vertices[d + 5] = i[2];
      d += b
    }
  }
};
GlobWeb.Tile.prototype.generate = function(a, b, c) {
  this.vertices = this.generateVertices(c);
  var c = this.config.tesselation, d = this.config.vertexSize;
  this.bbox.compute(this.vertices, d * c * c, d);
  this.radius = this.bbox.getRadius();
  this.config.normals && this.generateNormals();
  if(this.config.skirt) {
    var e = [0, 0, 0];
    mat4.multiplyVec3(this.inverseMatrix, e);
    var f = d * c * c;
    this.buildSkirtVertices(e, 0, d, f);
    f += d * c;
    this.buildSkirtVertices(e, d * c * (c - 1), d, f);
    f += d * c;
    this.buildSkirtVertices(e, 0, d * c, f);
    f += d * c;
    this.buildSkirtVertices(e, d * (c - 1), d * c, f);
    f += d * c;
    this.buildSkirtVertices(e, d * (c * (c - 1) / 2), d, f);
    this.buildSkirtVertices(e, d * ((c - 1) / 2), d * c, f + d * c)
  }
  null != this.vertexBuffer && null == this.parent && a.disposeGLBuffer(this.vertexBuffer);
  this.vertexBuffer = a.createGLBuffer(this.vertices);
  b && (this.texture = a.createGLTexture(b));
  this.state = GlobWeb.Tile.State.LOADED
};
GlobWeb.TilePool = function(a) {
  var b = a.gl, c = [], d = [], e = this;
  this.numReusedTextures = this.numCreatedTextures = 0;
  this.createGLTexture = function(a) {
    if(0 < c.length) {
      var d = c.pop();
      b.bindTexture(b.TEXTURE_2D, d);
      b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, b.RGBA, b.UNSIGNED_BYTE, a);
      b.generateMipmap(b.TEXTURE_2D);
      e.numReusedTextures++;
      return d
    }
    d = b.createTexture();
    b.bindTexture(b.TEXTURE_2D, d);
    b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, b.RGBA, b.UNSIGNED_BYTE, a);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.LINEAR);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.LINEAR_MIPMAP_LINEAR);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE);
    b.generateMipmap(b.TEXTURE_2D);
    e.numCreatedTextures++;
    return d
  };
  this.createGLBuffer = function(a) {
    var c;
    c = 0 < d.length ? d.pop() : b.createBuffer();
    b.bindBuffer(b.ARRAY_BUFFER, c);
    b.bufferData(b.ARRAY_BUFFER, a, b.STATIC_DRAW);
    return c
  };
  this.disposeGLTexture = function(a) {
    c.push(a)
  };
  this.disposeGLBuffer = function(a) {
    d.push(a)
  };
  this.disposeAll = function() {
    for(var a = 0;a < c.length;a++) {
      b.deleteTexture(c[a])
    }
    for(a = c.length = 0;a < d.length;a++) {
      b.deleteBuffer(d[a])
    }
    d.length = 0
  }
};
GlobWeb.TileManager = function(a) {
  this.globe = a;
  this.renderContext = this.globe.renderContext;
  this.tilePool = new GlobWeb.TilePool(this.renderContext);
  this.elevationProvider = this.imageryProvider = null;
  this.tilesToRender = [];
  this.tilesToRequest = [];
  this.postRenderers = [];
  this.level0Tiles = [];
  this.levelZeroTexture = null;
  var b = this.renderContext, a = function() {
    b.requestFrame()
  };
  this.tileRequests = [];
  for(var c = 0;4 > c;c++) {
    this.tileRequests[c] = new GlobWeb.TileRequest(a)
  }
  this.level0TilesLoaded = !1;
  this.tileConfig = {tesselation:9, skirt:!0, cullSign:1, imageSize:256, vertexSize:this.renderContext.lighting ? 6 : 3, normals:this.renderContext.lighting};
  this.tcoordBuffer = null;
  this.tileIndexBuffer = new GlobWeb.TileIndexBuffer(this.renderContext, this.tileConfig);
  this.identityTextureTransform = [1, 1, 0, 0];
  this.freeze = this.showWireframe = !1;
  this.frameNumber = this.numTilesGenerated = 0;
  a = "\tattribute vec3 vertex;\n\tattribute vec2 tcoord;\n\tuniform mat4 modelViewMatrix;\n\tuniform mat4 projectionMatrix;\n\tuniform vec4 texTransform;\n\tvarying vec2 texCoord;\n";
  this.renderContext.lighting && (a += "attribute vec3 normal;\nvarying vec3 color;\n");
  a += "\tvoid main(void) \n\t{\n\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n";
  this.renderContext.lighting && (a += "vec4 vn = modelViewMatrix * vec4(normal,0);\ncolor = max( vec3(-vn[2],-vn[2],-vn[2]), 0.0 );\n");
  a += "\t\ttexCoord = vec2(tcoord.s * texTransform.x + texTransform.z, tcoord.t * texTransform.y + texTransform.w);\n\t}\n\t";
  c = "\tprecision highp float; \n\tvarying vec2 texCoord;\n";
  this.renderContext.lighting && (c += "varying vec3 color;\n");
  c += "\tuniform sampler2D colorTexture;\n\tvoid main(void)\n\t{\n\t\tgl_FragColor.rgb = texture2D(colorTexture, texCoord).rgb;\n";
  this.renderContext.lighting && (c += "gl_FragColor.rgb *= color;\n");
  c += "\t\tgl_FragColor.a = 1.0;\n\t}\n\t";
  this.program = new GlobWeb.Program(this.renderContext);
  this.program.createFromSource(a, c)
};
GlobWeb.TileManager.prototype.addPostRenderer = function(a) {
  this.postRenderers.push(a)
};
GlobWeb.TileManager.prototype.removePostRenderer = function(a) {
  var b = this.postRenderers.indexOf(a);
  -1 != b && (a.cleanupTile && this.visitTiles(function(b) {
    a.cleanupTile(b)
  }), this.postRenderers.splice(b, 1))
};
GlobWeb.TileManager.prototype.setImageryProvider = function(a) {
  this.reset();
  if(this.imageryProvider = a) {
    this.tileConfig.imageSize = a.tilePixelSize, this.level0Tiles = a.tiling.generateLevelZeroTiles(this.tileConfig, this.tilePool)
  }
};
GlobWeb.TileManager.prototype.setElevationProvider = function(a) {
  this.reset();
  this.elevationProvider = a;
  this.tileConfig.tesselation = a ? a.tilePixelSize : 9
};
GlobWeb.TileManager.prototype.reset = function() {
  for(var a = 0;a < this.level0Tiles.length;a++) {
    this.level0Tiles[a].deleteChildren(this.renderContext, this.tilePool), this.level0Tiles[a].dispose(this.renderContext, this.tilePool)
  }
  a = this.renderContext.gl;
  this.tileIndexBuffer.reset();
  a.deleteBuffer(this.tcoordBuffer);
  this.levelZeroTexture = this.tcoordBuffer = null;
  this.level0TilesLoaded = !1
};
GlobWeb.TileManager.prototype.visitTiles = function(a) {
  for(var b = this.level0Tiles.concat([]);0 < b.length;) {
    var c = b.shift();
    c.state == GlobWeb.Tile.State.LOADED && (a(c), c.children && (b.push(c.children[0]), b.push(c.children[1]), b.push(c.children[2]), b.push(c.children[3])))
  }
};
GlobWeb.TileManager.prototype.launchRequest = function(a) {
  for(var b = null, c = 0;c < this.tileRequests.length;c++) {
    if(!this.tileRequests[c].tile) {
      b = this.tileRequests[c];
      break
    }
  }
  b ? (b.tile = a, c = null, this.elevationProvider && (c = this.elevationProvider.getUrl(a)), b.launch(this.imageryProvider.getUrl(a), c), a.state = GlobWeb.Tile.State.LOADING) : a.state = GlobWeb.Tile.State.NONE
};
GlobWeb.TileManager.prototype.traverseTiles = function() {
  this.tilesToRender.length = 0;
  this.numTraversedTiles = this.tilesToRequest.length = 0;
  this.renderContext.near = 1E10;
  this.renderContext.far = -1;
  if(!this.level0TilesLoaded && !this.levelZeroTexture) {
    this.level0TilesLoaded = !0;
    for(var a = 0;a < this.level0Tiles.length;a++) {
      var b = this.level0Tiles[a], c = b.state == GlobWeb.Tile.State.LOADED;
      b.frameNumber = this.frameNumber;
      this.level0TilesLoaded = this.level0TilesLoaded && c;
      !c && b.state == GlobWeb.Tile.State.NONE && (b.state = GlobWeb.Tile.State.REQUESTED, this.tilesToRequest.push(b))
    }
    this.level0TilesLoaded && this.globe.publish("level0TilesLoaded")
  }
  if(this.level0TilesLoaded || this.levelZeroTexture) {
    for(a = 0;a < this.level0Tiles.length;a++) {
      b = this.level0Tiles[a], b.isCulled(this.renderContext) ? (c = b.state == GlobWeb.Tile.State.LOADED, this.levelZeroTexture && c && (this.tilePool.disposeGLTexture(b.texture), b.texture = null, b.state = GlobWeb.Tile.State.NONE), b.deleteChildren(this.renderContext, this.tilePool)) : this.processTile(b, 0)
    }
  }
};
GlobWeb.TileManager.prototype.processTile = function(a, b) {
  this.numTraversedTiles++;
  a.frameNumber = this.frameNumber;
  a.state == GlobWeb.Tile.State.NONE && (a.state = GlobWeb.Tile.State.REQUESTED, this.tilesToRequest.push(a));
  if(a.state == GlobWeb.Tile.State.LOADED && b + 1 < this.imageryProvider.numberOfLevels && a.needsToBeRefined(this.renderContext)) {
    null == a.children && a.createChildren();
    for(var c = 0;4 > c;c++) {
      a.children[c].isCulled(this.renderContext) ? a.children[c].deleteChildren(this.renderContext, this.tilePool) : this.processTile(a.children[c], b + 1)
    }
  }else {
    this.tilesToRender.push(a)
  }
};
GlobWeb.TileManager.prototype.generateReceivedTiles = function() {
  for(var a = 0;a < this.tileRequests.length;a++) {
    var b = this.tileRequests[a], c = b.tile;
    if(c && b.successfull) {
      if(c.frameNumber == this.frameNumber) {
        this.elevationProvider ? c.generate(this.tilePool, b.image, this.elevationProvider.parseElevations(b.elevations)) : c.generate(this.tilePool, b.image);
        for(a = 0;a < this.postRenderers.length;a++) {
          this.postRenderers[a].generate && this.postRenderers[a].generate(c)
        }
        this.numTilesGenerated++;
        this.renderContext.requestFrame()
      }else {
        c.state = GlobWeb.Tile.State.NONE
      }
      b.tile = null
    }else {
      c && b.failed && (c.state = GlobWeb.Tile.State.ERROR, b.tile = null)
    }
  }
};
GlobWeb.TileManager.prototype.renderTiles = function() {
  var a = this.renderContext, b = a.gl;
  b.enable(b.POLYGON_OFFSET_FILL);
  b.polygonOffset(0, 4);
  b.disable(b.CULL_FACE);
  this.program.apply();
  var c = this.program.attributes;
  mat4.perspective(a.fov, a.canvas.width / a.canvas.height, a.near, a.far, a.projectionMatrix);
  b.activeTexture(b.TEXTURE0);
  b.uniformMatrix4fv(this.program.uniforms.projectionMatrix, !1, a.projectionMatrix);
  b.uniform1i(this.program.uniforms.colorTexture, 0);
  this.tcoordBuffer || this.buildSharedTexCoordBuffer();
  b.bindBuffer(b.ARRAY_BUFFER, this.tcoordBuffer);
  b.vertexAttribPointer(c.tcoord, 2, b.FLOAT, !1, 0, 0);
  for(var d = null, e = null, f = 0;f < this.tilesToRender.length;f++) {
    var g = this.tilesToRender[f], h = g.state == GlobWeb.Tile.State.LOADED, i = -1 == g.parentIndex, j;
    !h && i ? (b.bindTexture(b.TEXTURE_2D, this.levelZeroTexture), j = g.texTransform) : (b.bindTexture(b.TEXTURE_2D, g.texture), j = this.identityTextureTransform);
    e != j && (b.uniform4f(this.program.uniforms.texTransform, j[0], j[1], j[2], j[3]), e = j);
    mat4.multiply(a.viewMatrix, g.matrix, a.modelViewMatrix);
    b.uniformMatrix4fv(this.program.uniforms.modelViewMatrix, !1, a.modelViewMatrix);
    b.bindBuffer(b.ARRAY_BUFFER, g.vertexBuffer);
    b.vertexAttribPointer(c.vertex, 3, b.FLOAT, !1, 4 * this.tileConfig.vertexSize, 0);
    this.tileConfig.normals && b.vertexAttribPointer(c.normal, 3, b.FLOAT, !1, 4 * this.tileConfig.vertexSize, 12);
    g = h || i ? this.tileIndexBuffer.getSolid() : this.tileIndexBuffer.getSubSolid(g.parentIndex);
    d != g && (b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, g), d = g);
    b.drawElements(b.TRIANGLES, d.numIndices, b.UNSIGNED_SHORT, 0)
  }
  for(f = 0;f < this.postRenderers.length;f++) {
    this.postRenderers[f].needsOffset && this.postRenderers[f].render(this.tilesToRender)
  }
  b.disable(b.POLYGON_OFFSET_FILL);
  for(f = 0;f < this.postRenderers.length;f++) {
    this.postRenderers[f].needsOffset || this.postRenderers[f].render(this.tilesToRender)
  }
};
GlobWeb.TileManager.prototype.launchRequests = function() {
  this.tilesToRequest.sort(function(a, b) {
    return a.distance - b.distance
  });
  for(var a = this.tilesToRequest.length, b = 0;b < a;b++) {
    var c = this.tilesToRequest[b];
    c.frameNumber == this.frameNumber ? this.launchRequest(c) : c.state = GlobWeb.Tile.State.NONE
  }
};
GlobWeb.TileManager.prototype.render = function() {
  if(null != this.imageryProvider && this.imageryProvider.ready) {
    null == this.levelZeroTexture && this.imageryProvider.levelZeroImage && (this.levelZeroTexture = this.renderContext.createNonPowerOfTwoTextureFromImage(this.imageryProvider.levelZeroImage), this.globe.publish("levelZeroTextureLoaded"));
    var a = this.renderContext.stats;
    this.freeze || (a && a.start("traverseTime"), this.traverseTiles(), a && a.end("traverseTime"));
    if(this.level0TilesLoaded || this.levelZeroTexture) {
      a && a.start("renderTime"), this.renderTiles(), a && a.end("renderTime")
    }
    a && a.start("generateTime");
    this.generateReceivedTiles();
    a && a.end("generateTime");
    a && a.start("requestTime");
    this.launchRequests();
    a && a.end("requestTime");
    this.frameNumber++
  }
};
GlobWeb.TileManager.prototype.buildSharedTexCoordBuffer = function() {
  var a = this.tileConfig.tesselation, b = this.tileConfig.skirt, c = 2 * a * a;
  b && (c += 12 * a);
  for(var c = new Float32Array(c), d = 1 / (a - 1), e = 0, f = 0, g = 0;g < a;g++) {
    for(var h = 0, i = 0;i < a;i++) {
      c[e] = h, c[e + 1] = f, e += 2, h += d
    }
    f += d
  }
  if(b) {
    for(i = f = h = 0;i < a;i++) {
      c[e] = h, c[e + 1] = f, h += d, e += 2
    }
    h = 0;
    f = 1;
    for(i = 0;i < a;i++) {
      c[e] = h, c[e + 1] = f, h += d, e += 2
    }
    for(i = f = h = 0;i < a;i++) {
      c[e] = h, c[e + 1] = f, f += d, e += 2
    }
    h = 1;
    for(i = f = 0;i < a;i++) {
      c[e] = h, c[e + 1] = f, f += d, e += 2
    }
    h = 0;
    f = 0.5;
    for(i = 0;i < a;i++) {
      c[e] = h, c[e + 1] = f, h += d, e += 2
    }
    h = 0.5;
    for(i = f = 0;i < a;i++) {
      c[e] = h, c[e + 1] = f, f += d, e += 2
    }
  }
  a = this.renderContext.gl;
  b = a.createBuffer();
  a.bindBuffer(a.ARRAY_BUFFER, b);
  a.bufferData(a.ARRAY_BUFFER, c, a.STATIC_DRAW);
  this.tcoordBuffer = b
};
GlobWeb.RasterLayer = function(a) {
  GlobWeb.BaseLayer.prototype.constructor.call(this, a);
  this.tilePixelSize = -1;
  this.tiling = null;
  this.numberOfLevels = -1;
  this.overlay = a && a.hasOwnProperty("overlay") ? a.overlay : !0;
  this.geoBound = a.geoBound || null;
  this.coordinates = a.coordinates || null;
  this.ready = !0
};
GlobWeb.inherits(GlobWeb.BaseLayer, GlobWeb.RasterLayer);
GlobWeb.RasterLayer.prototype._attach = function(a) {
  GlobWeb.BaseLayer.prototype._attach.call(this, a);
  this.attribution && (this.overlay || (this.id = 0), this.globe.attributionHandler.addAttribution(this));
  if(this.overlay) {
    if(!a.rasterOverlayRenderer) {
      var b = new GlobWeb.RasterOverlayRenderer(a.tileManager);
      a.tileManager.addPostRenderer(b);
      a.rasterOverlayRenderer = b
    }
    a.rasterOverlayRenderer.addOverlay(this)
  }
};
GlobWeb.RasterLayer.prototype._detach = function() {
  this.overlay && this.globe.rasterOverlayRenderer && this.globe.rasterOverlayRenderer.removeOverlay(this);
  GlobWeb.BaseLayer.prototype._detach.call(this)
};
GlobWeb.TileRequest = function(a) {
  this.failed = this.successfull = !1;
  this.tile = null;
  this.imageLoaded = !1;
  this.elevationLoaded = !0;
  this.callback = a;
  var b = this;
  this.image = new Image;
  this.image.crossOrigin = "";
  this.image.onload = function() {
    b.handleLoadedImage()
  };
  this.image.onerror = function() {
    b.handleErrorImage()
  };
  this.xhr = new XMLHttpRequest;
  this.xhr.onreadystatechange = function() {
    4 == b.xhr.readyState && 200 == b.xhr.status && b.handleLoadedElevation(b);
    400 <= b.xhr.status && b.handleErrorElevation(b)
  }
};
GlobWeb.TileRequest.prototype.handleLoadedImage = function() {
  this.imageLoaded = !0;
  this.elevationLoaded && (this.successfull = !0, this.callback())
};
GlobWeb.TileRequest.prototype.handleErrorImage = function() {
  console.log("Error while loading " + this.image.src);
  this.failed = !0
};
GlobWeb.TileRequest.prototype.handleLoadedElevation = function() {
  this.elevations = this.xhr.responseText;
  this.elevationLoaded = !0;
  this.imageLoaded && (this.successfull = !0, this.callback())
};
GlobWeb.TileRequest.prototype.handleErrorElevation = function() {
  this.elevations = null;
  this.elevationLoaded = !0;
  this.imageLoaded && (this.successfull = !0, this.callback())
};
GlobWeb.TileRequest.prototype.launch = function(a, b) {
  this.imageLoaded = this.failed = this.successfull = !1;
  this.image.src = a;
  b && (this.elevationLoaded = !1, this.xhr.open("GET", b), this.xhr.send())
};
GlobWeb.Globe = function(a) {
  this.renderContext = new GlobWeb.RenderContext(a);
  this.tileManager = new GlobWeb.TileManager(this);
  this.vectorRendererManager = new GlobWeb.VectorRendererManager(this);
  this.attributionHandler = new GlobWeb.AttributionHandler;
  this.activeAnimations = [];
  this.preRenderers = [];
  this.nbCreatedLayers = 0;
  this.callbacks = {};
  var b = this;
  this.renderContext.frame = function() {
    b.renderContext.frameRequested = !1;
    b.render();
    b.renderContext.continuousRendering ? b.renderContext.requestFrame() : 0 < b.activeAnimations.length && b.renderContext.requestFrame()
  };
  this.renderContext.requestFrame()
};
GlobWeb.Globe.prototype.dispose = function() {
  this.tileManager.tilePool.disposeAll();
  this.tileManager.reset()
};
GlobWeb.Globe.prototype.refresh = function() {
  this.renderContext.requestFrame()
};
GlobWeb.Globe.prototype.setBaseImagery = function(a) {
  this.tileManager.imageryProvider && this.removeLayer(this.tileManager.imageryProvider);
  this.tileManager.setImageryProvider(a);
  a && (a.overlay = !1, this.addLayer(a))
};
GlobWeb.Globe.prototype.setBaseElevation = function(a) {
  this.tileManager.elevationProvider && this.removeLayer(this.tileManager.elevationProvider);
  this.tileManager.setElevationProvider(a);
  a && (a.overlay = !1, this.addLayer(a))
};
GlobWeb.Globe.prototype.addLayer = function(a) {
  a.id = this.nbCreatedLayers;
  a._attach(this);
  this.renderContext.requestFrame();
  this.nbCreatedLayers++
};
GlobWeb.Globe.prototype.removeLayer = function(a) {
  a._detach();
  this.renderContext.requestFrame()
};
GlobWeb.Globe.prototype.addAnimation = function(a) {
  a.globe = this
};
GlobWeb.Globe.prototype.removeAnimation = function(a) {
  a.globe = null
};
GlobWeb.Globe.prototype.getElevation = function(a, b) {
  var c = this.tileManager.level0Tiles[this.tileManager.imageryProvider.tiling.lonlat2LevelZeroIndex(a, b)];
  return c.state == GlobWeb.Tile.State.LOADED ? c.getElevation(a, b) : 0
};
GlobWeb.Globe.prototype.getViewportGeoBound = function() {
  var a = this.renderContext, b = mat4.create();
  mat4.inverse(a.viewMatrix, b);
  var c = [b[12], b[13], b[14]];
  mat4.multiply(a.projectionMatrix, a.viewMatrix, b);
  mat4.inverse(b);
  for(var a = [[-1, -1, 1, 1], [1, -1, 1, 1], [-1, 1, 1, 1], [1, 1, 1, 1]], d = vec3.create(), e = [0, 0, 0], f = 0;4 > f;f++) {
    mat4.multiplyVec4(b, a[f]);
    vec3.scale(a[f], 1 / a[f][3]);
    vec3.subtract(a[f], c, a[f]);
    vec3.normalize(a[f]);
    var g = Numeric.raySphereIntersection(c, a[f], e, GlobWeb.CoordinateSystem.radius);
    if(0 > g) {
      return null
    }
    a[f] = GlobWeb.CoordinateSystem.from3DToGeo(Numeric.pointOnRay(c, a[f], g, d))
  }
  b = new GlobWeb.GeoBound;
  b.computeFromCoordinates(a);
  return b
};
GlobWeb.Globe.prototype.getLonLatFromPixel = function(a, b) {
  var c = this.renderContext.get3DFromPixel(a, b);
  if(null == c) {
    return null
  }
  var d = [];
  GlobWeb.CoordinateSystem.from3DToGeo(c, d);
  return d
};
GlobWeb.Globe.prototype.render = function() {
  var a = this.renderContext, b = a.stats, c = a.gl;
  b && b.start("globalRenderTime");
  if(0 < this.activeAnimations.length) {
    for(var d = Date.now(), e = 0;e < this.activeAnimations.length;e++) {
      this.activeAnimations[e].update(d)
    }
  }
  c.clear(c.COLOR_BUFFER_BIT | c.DEPTH_BUFFER_BIT);
  if(!(0 == a.canvas.width || 0 == a.canvas.height)) {
    c.viewport(0, 0, a.canvas.width, a.canvas.height);
    a.updateViewDependentProperties();
    for(e = 0;e < this.preRenderers.length;e++) {
      this.preRenderers[e].preRender()
    }
    this.tileManager.render();
    0 != this.tileManager.tilesToRender.length && b && b.end("globalRenderTime")
  }
};
GlobWeb.Globe.prototype.subscribe = function(a, b) {
  this.callbacks[a] ? this.callbacks[a].push(b) : this.callbacks[a] = [b]
};
GlobWeb.Globe.prototype.unsubscribe = function(a, b) {
  if(this.callbacks[a]) {
    var c = this.callbacks[a].indexOf(b);
    -1 != c && this.callbacks[a].splice(c, 1)
  }
};
GlobWeb.Globe.prototype.publish = function(a, b) {
  if(this.callbacks[a]) {
    for(var c = this.callbacks[a], d = 0;d < c.length;d++) {
      c[d](b)
    }
  }
};
GlobWeb.AttributionHandler = function(a, b) {
  this.id = "attributions";
  for(var c in a) {
    this[c] = a[c]
  }
  this.attributionDiv = document.createElement("div");
  this.attributionDiv.id = this.id;
  document.getElementsByTagName("body")[0].appendChild(this.attributionDiv);
  var d = document.createElement("style");
  d.innerHTML = "#" + this.id + " {text-align: right; position: absolute; right: 0px; bottom: 2px; }\t\t\t\t#" + this.id + " img {background-color: white; border-radius: 10px;}\t\t\t\t#" + this.id + " div {color: white}";
  document.body.appendChild(d);
  for(c in b) {
    $("#" + this.id).css(c, b[c])
  }
};
GlobWeb.AttributionHandler.prototype.removeAttribution = function(a) {
  a = document.getElementById("attribution_" + a.id);
  this.attributionDiv.removeChild(a)
};
GlobWeb.AttributionHandler.prototype.addAttribution = function(a) {
  var b = document.createElement("div");
  b.innerHTML = a.attribution;
  b.id = "attribution_" + a.id;
  0 == a.id ? this.attributionDiv.insertBefore(b, this.attributionDiv.firstChild) : this.attributionDiv.appendChild(b)
};
GlobWeb.PathAnimation = function(a, b, c) {
  GlobWeb.Animation.prototype.constructor.call(this);
  this.speed = b * GlobWeb.CoordinateSystem.heightScale / 1E3;
  this.nodes = [];
  for(b = 0;b < a.length;b++) {
    var d = {position:GlobWeb.CoordinateSystem.fromGeoTo3D(a[b]), velocity:null, distance:0};
    this.nodes.push(d);
    if(0 < b) {
      var d = this.nodes[b].position[0] - this.nodes[b - 1].position[0], e = this.nodes[b].position[1] - this.nodes[b - 1].position[1], f = this.nodes[b].position[2] - this.nodes[b - 1].position[2];
      this.nodes[b - 1].distance = Math.sqrt(d * d + e * e + f * f)
    }
  }
  for(b = 1;b < a.length - 1;b++) {
    d = vec3.subtract(this.nodes[b + 1].position, this.nodes[b].position, vec3.create()), e = vec3.subtract(this.nodes[b - 1].position, this.nodes[b].position, vec3.create()), vec3.normalize(d), vec3.normalize(e), this.nodes[b].velocity = vec3.subtract(d, e, vec3.create()), vec3.normalize(this.nodes[b].velocity)
  }
  d = vec3.subtract(this.nodes[1].position, this.nodes[0].position, vec3.create());
  vec3.scale(d, 3 / this.nodes[0].distance);
  this.nodes[0].velocity = vec3.subtract(d, this.nodes[1].velocity, vec3.create());
  vec3.scale(this.nodes[0].velocity, 0.5);
  b = a.length - 1;
  d = vec3.subtract(this.nodes[b].position, this.nodes[b - 1].position, vec3.create());
  vec3.scale(d, 3 / this.nodes[b - 1].distance);
  this.nodes[b].velocity = vec3.subtract(d, this.nodes[b - 1].velocity, vec3.create());
  vec3.scale(this.nodes[b].velocity, 0.5);
  this.currentDistance = this.index = 0;
  this.previousTime = -1;
  this.currentDirection = [];
  this.centerOffset = -0.2;
  this.altitudeOffset = 1E3;
  var g = this;
  this.valueSetter = c ? c : function(a, b) {
    var c = vec3.normalize(a, vec3.create()), d = GlobWeb.CoordinateSystem.from3DToGeo(a);
    d[2] = g.globe.getElevation(d[0], d[1]) + g.altitudeOffset;
    var d = GlobWeb.CoordinateSystem.fromGeoTo3D(d), e = vec3.normalize(b, vec3.create()), e = vec3.add(d, e, vec3.create());
    vec3.add(e, vec3.scale(c, g.centerOffset, vec3.create()));
    mat4.lookAt(d, e, c, g.globe.renderContext.viewMatrix)
  }
};
GlobWeb.inherits(GlobWeb.Animation, GlobWeb.PathAnimation);
GlobWeb.PathAnimation.prototype.setSpeed = function(a) {
  this.speed = parseFloat(a) * GlobWeb.CoordinateSystem.heightScale / 1E3
};
GlobWeb.PathAnimation.prototype.setAltitudeOffset = function(a) {
  this.altitudeOffset = parseFloat(a)
};
GlobWeb.PathAnimation.prototype.setDirectionAngle = function(a) {
  this.centerOffset = Math.tan(parseFloat(a) * Math.PI / 180)
};
GlobWeb.PathAnimation.prototype.start = function() {
  var a = -1;
  -1 != this.pauseTime && (a = this.startTime);
  GlobWeb.Animation.prototype.start.call(this);
  this.previousTime = -1 != a ? this.previousTime + (this.startTime - a) : -1
};
GlobWeb.PathAnimation.prototype.update = function(a) {
  -1 == this.previousTime ? this.currentDistance = this.index = 0 : this.currentDistance += (a - this.previousTime) * this.speed;
  for(this.previousTime = a;this.currentDistance >= this.nodes[this.index].distance && this.index < this.nodes.length - 1;) {
    this.currentDistance -= this.nodes[this.index].distance, this.index += 1
  }
  if(this.index < this.nodes.length - 1) {
    var b = this.currentDistance / this.nodes[this.index].distance, c = this.nodes[this.index].position, d = this.nodes[this.index + 1].position, e = vec3.scale(this.nodes[this.index].velocity, this.nodes[this.index].distance, vec3.create()), f = vec3.scale(this.nodes[this.index + 1].velocity, this.nodes[this.index].distance, vec3.create()), a = Numeric.cubicInterpolation(b, c, e, d, f), b = Numeric.cubicInterpolationDerivative(b, c, e, d, f);
    this.valueSetter(a, b)
  }else {
    this.index == this.nodes.length - 1 ? this.valueSetter(this.nodes[this.index].position, this.nodes[this.index].velocity) : this.stop()
  }
};
GlobWeb.MouseNavigationHandler = function(a) {
  this.navigation = null;
  this.lastMouseY = this.lastMouseX = this.pressY = this.pressX = this.pressedButton = -1;
  for(var b in a) {
    this[b] = a[b]
  }
};
GlobWeb.MouseNavigationHandler.prototype.install = function(a) {
  this.navigation = a;
  var a = this.navigation.globe.renderContext.canvas, b = this;
  a.addEventListener("mousedown", function(a) {
    a.preventDefault();
    b.handleMouseDown(a || window.event)
  }, !1);
  document.addEventListener("mouseup", function(a) {
    b.handleMouseUp(a || window.event)
  }, !1);
  a.addEventListener("mousemove", function(a) {
    b.handleMouseMove(a || window.event)
  }, !1);
  this.zoomOnDblClick && a.addEventListener("dblclick", function(a) {
    b.handleMouseDblClick(a || window.event)
  }, !1);
  a.addEventListener("DOMMouseScroll", function(a) {
    a.preventDefault();
    b.handleMouseWheel(a || window.event)
  }, !1);
  a.addEventListener("mousewheel", function(a) {
    a.preventDefault();
    b.handleMouseWheel(a || window.event)
  }, !1)
};
GlobWeb.MouseNavigationHandler.prototype.uninstall = function() {
  var a = this.navigation.globe.renderContext.canvas;
  a.removeEventListener("mousedown", function(a) {
    self.handleMouseDown(a || window.event)
  }, !1);
  document.removeEventListener("mouseup", function(a) {
    self.handleMouseUp(a || window.event)
  }, !1);
  a.removeEventListener("mousemove", function(a) {
    self.handleMouseMove(a || window.event)
  }, !1);
  zoomOnDblClick && a.removeEventListener("dblclick", function(a) {
    self.handleMouseDblClick(a || window.event)
  }, !1);
  a.removeEventListener("DOMMouseScroll", function(a) {
    self.handleMouseWheel(a || window.event)
  }, !1);
  a.removeEventListener("mousewheel", function(a) {
    self.handleMouseWheel(a || window.event)
  }, !1)
};
GlobWeb.MouseNavigationHandler.prototype.handleMouseWheel = function(a) {
  this.navigation.globe.publish("startNavigation");
  void 0 === a.wheelDelta ? this.navigation.zoom(a.detail) : this.navigation.zoom(-a.wheelDelta / 120);
  a.preventDefault && a.preventDefault();
  a.returnValue = !1;
  this.navigation.globe.publish("endNavigation");
  this.navigation.globe.renderContext.requestFrame();
  return!1
};
GlobWeb.MouseNavigationHandler.prototype.handleMouseDown = function(a) {
  this.pressedButton = a.button;
  return 0 == a.button || 1 == a.button ? (this.pressX = a.clientX, this.pressY = a.clientY, this.lastMouseX = a.clientX, this.lastMouseY = a.clientY, this.navigation.globe.publish("startNavigation"), !1) : !0
};
GlobWeb.MouseNavigationHandler.prototype.handleMouseUp = function(a) {
  this.pressedButton = -1;
  return 0 == a.button || 1 == a.button ? (this.navigation.globe.publish("endNavigation"), !1) : !0
};
GlobWeb.MouseNavigationHandler.prototype.handleMouseMove = function(a) {
  if(!(0 > this.pressedButton)) {
    var b = a.clientX - this.lastMouseX, c = a.clientY - this.lastMouseY, d = !1;
    0 == this.pressedButton ? (this.navigation.pan(b, c), this.navigation.globe.renderContext.requestFrame(), d = !0) : 1 == this.pressedButton && (this.navigation.rotate(b, c), this.navigation.globe.renderContext.requestFrame(), d = !0);
    this.lastMouseX = a.clientX;
    this.lastMouseY = a.clientY;
    return d
  }
};
GlobWeb.MouseNavigationHandler.prototype.handleMouseDblClick = function(a) {
  0 == a.button && (a = this.navigation.globe.renderContext.getXYRelativeToCanvas(a), (a = this.navigation.globe.getLonLatFromPixel(a[0], a[1])) && this.navigation.zoomTo(a))
};
GlobWeb.KeyboardNavigationHandler = function(a) {
  this.navigation = null;
  this.panFactor = 10;
  this.zoomFactor = 1;
  this.installOnDocument = !1;
  for(var b in a) {
    this[b] = a[b]
  }
};
GlobWeb.KeyboardNavigationHandler.prototype.install = function(a) {
  this.navigation = a;
  var b = this;
  this.installOnDocument ? document.addEventListener("keydown", function(a) {
    b.handleKeyDown(a || window.event)
  }, !1) : (a = this.navigation.globe.renderContext.canvas, a.addEventListener("keydown", function(a) {
    b.handleKeyDown(a || window.event)
  }, !1), a.tabIndex = "0", a.addEventListener("mousedown", function() {
    this.focus();
    return!1
  }))
};
GlobWeb.KeyboardNavigationHandler.prototype.handleKeyDown = function(a) {
  switch(a.keyCode) {
    case 33:
      this.navigation.zoom(-this.zoomFactor);
      break;
    case 34:
      this.navigation.zoom(this.zoomFactor);
      break;
    case 37:
      this.navigation.pan(this.panFactor, 0);
      break;
    case 38:
      this.navigation.pan(0, this.panFactor);
      break;
    case 39:
      this.navigation.pan(-this.panFactor, 0);
      break;
    case 40:
      this.navigation.pan(0, -this.panFactor)
  }
  this.navigation.globe.renderContext.requestFrame()
};
GlobWeb.BaseNavigation = function(a, b) {
  this.globe = a;
  for(var c in b) {
    this[c] = b[c]
  }
  this.handlers || (this.handlers = [new GlobWeb.MouseNavigationHandler({zoomOnDblClick:!0}), new GlobWeb.KeyboardNavigationHandler]);
  for(c = 0;c < this.handlers.length;c++) {
    this.handlers[c].install(this)
  }
};
GlobWeb.BaseNavigation.prototype.getFov = function() {
  return[this.globe.renderContext.canvas.width / this.globe.renderContext.canvas.height * this.globe.renderContext.fov, this.globe.renderContext.fov]
};
GlobWeb.RasterOverlayRenderer = function(a) {
  this.requestHighestResolutionFirst = !0;
  this.tileManager = a;
  this.program = new GlobWeb.Program(a.renderContext);
  this.program.createFromSource("\tattribute vec3 vertex;\n\tattribute vec2 tcoord;\n\tuniform mat4 modelViewMatrix;\n\tuniform mat4 projectionMatrix;\n\tuniform vec4 textureTransform; \n\t\tvarying vec2 texCoord;\n\t\tvoid main(void) \n\t{\n\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n\t\ttexCoord = tcoord * textureTransform.xy + textureTransform.zw;\n\t}\n\t", "\t#ifdef GL_ES\n\tprecision highp float;\n\t#endif\n\t\n\tvarying vec2 texCoord;\n\tuniform sampler2D overlayTexture;\n\tuniform float opacity; \n\t\n\tvoid main(void)\n\t{\n\t\tgl_FragColor.rgba = texture2D(overlayTexture, texCoord.xy); \n\t\tgl_FragColor.a *= opacity; \n\t}\n\t");
  this.overlays = [];
  this.imageRequests = [];
  this.frameNumber = 0;
  for(var b = this, c = 0;2 > c;c++) {
    var d = new Image;
    d.renderable = null;
    d.frameNumber = -1;
    d.crossOrigin = "";
    d.onload = function() {
      this.renderable.texture = a.tilePool.createGLTexture(this);
      this.renderable.request = null;
      this.renderable.requestFinished = !0;
      this.renderable = null;
      b.tileManager.renderContext.requestFrame()
    };
    d.onerror = function() {
      this.renderable && (this.renderable.request = null, this.renderable.requestFinished = !0, this.renderable = null)
    };
    d.onabort = function() {
      console.log("Raster overlay request abort.");
      this.renderable && (this.renderable = this.renderable.request = null)
    };
    this.imageRequests.push(d)
  }
  this.needsOffset = !0
};
GlobWeb.RasterOverlayRenderable = function(a) {
  this.overlay = a;
  this.request = this.texture = null;
  this.requestFinished = !1
};
GlobWeb.RasterOverlayRenderable.prototype.dispose = function(a, b) {
  this.texture && (b.disposeGLTexture(this.texture), this.texture = null)
};
GlobWeb.RasterOverlayRenderer.TileData = function() {
  this.renderables = []
};
GlobWeb.RasterOverlayRenderer.TileData.prototype.findRenderable = function(a) {
  for(var b = 0;b < this.renderables.length;b++) {
    var c = this.renderables[b];
    if(c.overlay == a) {
      return c
    }
  }
  return null
};
GlobWeb.RasterOverlayRenderer.TileData.prototype.dispose = function(a, b) {
  for(var c = 0;c < this.renderables.length;c++) {
    this.renderables[c].dispose(a, b)
  }
};
GlobWeb.RasterOverlayRenderer.prototype.addOverlay = function(a) {
  this.overlays.push(a);
  for(var b = 0;b < this.tileManager.level0Tiles.length;b++) {
    var c = this.tileManager.level0Tiles[b];
    c.state == GlobWeb.Tile.State.LOADED && this.addOverlayToTile(c, a)
  }
};
GlobWeb.RasterOverlayRenderer.prototype.removeOverlay = function(a) {
  var b = this.overlays.indexOf(a);
  this.overlays.splice(b, 1);
  var c = this.tileManager.renderContext, d = this.tileManager.tilePool;
  this.tileManager.visitTiles(function(b) {
    var f = b.extension.rasterOverlay, g = f ? f.findRenderable(a) : null;
    if(g) {
      var h = f.renderables.indexOf(g);
      f.renderables.splice(h, 1);
      g.dispose(c, d);
      0 == f.renderables.length && delete b.extension.rasterOverlay
    }
  })
};
GlobWeb.RasterOverlayRenderer.prototype.addOverlayToTile = function(a, b) {
  a.extension.rasterOverlay || (a.extension.rasterOverlay = new GlobWeb.RasterOverlayRenderer.TileData);
  a.extension.rasterOverlay.renderables.push(new GlobWeb.RasterOverlayRenderable(b));
  if(a.children) {
    for(var c = 0;4 > c;c++) {
      a.children[c].state == GlobWeb.Tile.State.LOADED && this.overlayIntersects(a.children[c].geoBound, b) && this.addOverlayToTile(a.children[c], b)
    }
  }
};
GlobWeb.RasterOverlayRenderer.prototype.createInterpolatedVertex = function(a, b, c) {
  return[b[0] + a * (c[0] - b[0]), b[1] + a * (c[1] - b[1])]
};
GlobWeb.RasterOverlayRenderer.prototype.clipPolygonToSide = function(a, b, c, d) {
  for(var e = [], f = 0;f < d.length;f++) {
    var g = d[f], h = d[(f + 1) % d.length], i = g[a], j = h[a], k = 0 <= (i - c) * b, l = 0 <= (j - c) * b;
    !k && l ? (i = (c - i) / (j - i), g = this.createInterpolatedVertex(i, g, h), e.push(g), e.push(h)) : k && l ? e.push(h) : k && !l && (i = (c - i) / (j - i), g = this.createInterpolatedVertex(i, g, h), e.push(g))
  }
  return e
};
GlobWeb.RasterOverlayRenderer.prototype.overlayIntersects = function(a, b) {
  if(b.coordinates) {
    var c;
    c = this.clipPolygonToSide(0, 1, a.west, b.coordinates);
    c = this.clipPolygonToSide(0, -1, a.east, c);
    c = this.clipPolygonToSide(1, 1, a.south, c);
    c = this.clipPolygonToSide(1, -1, a.north, c);
    return 0 < c.length
  }
  return b.geoBound ? b.geoBound.intersects(a) : !0
};
GlobWeb.RasterOverlayRenderer.prototype.generate = function(a) {
  if(a.parent) {
    for(var b = a.parent.extension.rasterOverlay, c = b ? b.renderables.length : 0, d = 0;d < c;d++) {
      var e = b.renderables[d].overlay;
      this.overlayIntersects(a.geoBound, e) && this.addOverlayToTile(a, e)
    }
  }else {
    for(d = 0;d < this.overlays.length;d++) {
      e = this.overlays[d], this.overlayIntersects(a.geoBound, e) && this.addOverlayToTile(a, e)
    }
  }
};
GlobWeb.RasterOverlayRenderer.prototype.requestOverlayTextureForTile = function(a, b) {
  if(b.request) {
    b.request.frameNumber = this.frameNumber
  }else {
    for(var c, d = 0;d < this.imageRequests.length;d++) {
      if(!this.imageRequests[d].renderable) {
        c = this.imageRequests[d];
        break
      }
    }
    c && (c.renderable = b, b.request = c, c.frameNumber = this.frameNumber, c.src = b.overlay.getUrl(a))
  }
};
GlobWeb.RasterOverlayRenderer.prototype.render = function(a) {
  if(0 != this.overlays.length) {
    var b = this.tileManager.renderContext, c = b.gl;
    this.program.apply();
    var d = this.program.attributes;
    c.uniformMatrix4fv(this.program.uniforms.projectionMatrix, !1, b.projectionMatrix);
    c.uniform1i(this.program.uniforms.overlayTexture, 0);
    c.enable(c.BLEND);
    c.blendFunc(c.SRC_ALPHA, c.ONE_MINUS_SRC_ALPHA);
    c.depthFunc(c.LEQUAL);
    for(var e = mat4.create(), f = null, g = 0;g < a.length;g++) {
      var h = a[g], i = h.state == GlobWeb.Tile.State.LOADED, j;
      i ? j = h.extension.rasterOverlay : h.parent && (j = h.parent.extension.rasterOverlay);
      if(j) {
        mat4.multiply(b.viewMatrix, h.matrix, e);
        c.uniformMatrix4fv(this.program.uniforms.modelViewMatrix, !1, e);
        c.bindBuffer(c.ARRAY_BUFFER, h.vertexBuffer);
        c.vertexAttribPointer(d.vertex, 3, c.FLOAT, !1, 0, 0);
        var k = i ? this.tileManager.tileIndexBuffer.getSolid() : this.tileManager.tileIndexBuffer.getSubSolid(h.parentIndex);
        f != k && (c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, k), f = k);
        for(k = 0;k < j.renderables.length;k++) {
          var l = j.renderables[k];
          if(l.overlay._visible) {
            var m = 1, p = 0, n = 0, o = i ? h : h.parent;
            if(o) {
              var q = o;
              for(this.requestHighestResolutionFirst && (l.requestFinished || this.requestOverlayTextureForTile(o, l));!l.requestFinished && o;) {
                if(q = o, o = o.parent) {
                  p *= 0.5, n *= 0.5, m *= 0.5, p += q.parentIndex & 1 ? 0.5 : 0, n += q.parentIndex & 2 ? 0.5 : 0, l = o.extension.rasterOverlay.findRenderable(l.overlay)
                }
              }
              this.requestHighestResolutionFirst || q != o && this.requestOverlayTextureForTile(q, l);
              o && l.texture && (c.uniform1f(this.program.uniforms.opacity, l.overlay._opacity), c.uniform4f(this.program.uniforms.textureTransform, m, m, p, n), c.activeTexture(c.TEXTURE0), c.bindTexture(c.TEXTURE_2D, l.texture), c.drawElements(c.TRIANGLES, f.numIndices, c.UNSIGNED_SHORT, 0))
            }
          }
        }
      }
    }
    c.disable(c.BLEND);
    c.depthFunc(c.LESS);
    for(g = 0;g < this.imageRequests.length;g++) {
      a = this.imageRequests[g], a.renderable && a.frameNumber < this.frameNumber && (a.renderable.request = null, a.renderable = null, a.src = "")
    }
    this.frameNumber++
  }
};
GlobWeb.VectorRendererManager = function(a) {
  this.globe = a;
  this.factories = [];
  for(var a = GlobWeb.VectorRendererManager.globalFactories, b = 0;b < a.length;b++) {
    this.factories.push({creator:a[b].creator, canApply:a[b].canApply, instance:null})
  }
};
GlobWeb.VectorRendererManager.globalFactories = [];
GlobWeb.VectorRendererManager.registerRenderer = function(a) {
  GlobWeb.VectorRendererManager.globalFactories.push(a)
};
GlobWeb.VectorRendererManager.prototype.addGeometry = function(a, b, c) {
  for(var d = a.type, e = 0;e < this.factories.length;e++) {
    var f = this.factories[e];
    f.canApply(d, c) && (f.instance || (f.instance = f.creator(this.globe), this.globe.tileManager.addPostRenderer(f.instance)), f.instance.addGeometry(a, b, c))
  }
};
GlobWeb.VectorRendererManager.prototype.removeGeometry = function(a, b) {
  for(var c = 0;c < this.factories.length;c++) {
    var d = this.factories[c];
    d.instance && d.instance.removeGeometry(a, b)
  }
};
GlobWeb.Text = function() {
  var a = null;
  return{generateImageData:function(b, c) {
    a || (a = document.createElement("canvas"), a.width = 512, a.height = 20);
    var d = c;
    d ? d instanceof Array && (d = GlobWeb.FeatureStyle.fromColorToString(c)) : d = "#fff";
    var e = a.getContext("2d");
    e.clearRect(0, 0, a.width, a.height);
    e.fillStyle = d;
    e.font = "18px sans-serif";
    e.textBaseline = "top";
    e.shadowColor = "#000";
    e.shadowOffsetX = 1;
    e.shadowOffsetY = 1;
    e.shadowBlur = 2;
    e.fillText(b, 1, 1);
    d = e.measureText(b);
    return e.getImageData(0, 0, Math.floor(d.width) + 2, a.height)
  }}
}();
GlobWeb.PointRenderer = function(a) {
  this.renderContext = a.renderContext;
  this.tileConfig = a.tileConfig;
  this.buckets = [];
  this.numberOfRenderPoints = 0;
  this.program = new GlobWeb.Program(this.renderContext);
  this.program.createFromSource("\tattribute vec3 vertex; // vertex have z = 0, spans in x,y from -0.5 to 0.5 \n\tuniform mat4 viewProjectionMatrix; \n\tuniform vec3 poiPosition; // world position \n\tuniform vec2 poiScale; // x,y scale \n\tuniform vec2 tst; \n\t\n\tvarying vec2 texCoord; \n\t\n\tvoid main(void)  \n\t{ \n\t\t// Generate texture coordinates, input vertex goes from -0.5 to 0.5 (on x,y) \n\t\ttexCoord = vertex.xy + vec2(0.5) + tst; \n\t\t// Invert y \n\t\ttexCoord.y = 1.0 - texCoord.y; \n\t\t\n\t\t// Compute poi position in clip coordinate \n\t\tgl_Position = viewProjectionMatrix * vec4(poiPosition, 1.0); \n\t\tgl_Position.xy += vertex.xy * gl_Position.w * poiScale; \n\t} \n\t", 
  "\t#ifdef GL_ES \n\tprecision highp float; \n\t#endif \n\t\n\tvarying vec2 texCoord; \n\tuniform sampler2D texture; \n\tuniform float alpha; \n\tuniform vec3 color; \n\t\n\tvoid main(void) \n\t{ \n\t\tvec4 textureColor = texture2D(texture, texCoord); \n\t\tgl_FragColor = vec4(textureColor.rgb * color, textureColor.a * alpha); \n\t\tif (gl_FragColor.a <= 0.0) discard; \n\t} \n\t");
  var a = new Float32Array([-0.5, -0.5, 0, -0.5, 0.5, 0, 0.5, 0.5, 0, 0.5, -0.5, 0]), b = this.renderContext.gl;
  this.vertexBuffer = b.createBuffer();
  b.bindBuffer(b.ARRAY_BUFFER, this.vertexBuffer);
  b.bufferData(b.ARRAY_BUFFER, a, b.STATIC_DRAW)
};
GlobWeb.PointRenderer.prototype._buildTextureFromImage = function(a, b) {
  a.texture = this.renderContext.createNonPowerOfTwoTextureFromImage(b);
  a.textureWidth = b.width;
  a.textureHeight = b.height
};
GlobWeb.PointRenderer.prototype.addGeometry = function(a, b, c) {
  if(c) {
    var b = this.getOrCreateBucket(b, c), d = GlobWeb.CoordinateSystem.fromGeoTo3D(a.coordinates), e = vec3.create();
    vec3.normalize(d, e);
    b.points.push({pos3d:d, vertical:e, geometry:a, color:c.fillColor})
  }
};
GlobWeb.PointRenderer.prototype.removeGeometry = function(a, b) {
  for(var c = 0;c < this.buckets.length;c++) {
    var d = this.buckets[c];
    if(d.layer == b) {
      for(var e = 0;e < d.points.length;e++) {
        if(d.points[e].geometry == a) {
          d.points.splice(e, 1);
          0 == d.points.length && this.buckets.splice(c, 1);
          return
        }
      }
    }
  }
};
GlobWeb.PointRenderer.prototype.getOrCreateBucket = function(a, b) {
  for(var c = 0;c < this.buckets.length;c++) {
    var d = this.buckets[c];
    if(d.layer == a && d.style.isEqualForPoint(b)) {
      return d
    }
  }
  d = {texture:null, points:[], style:b, layer:a};
  if(b.label) {
    c = GlobWeb.Text.generateImageData(b.label, b.textColor), this._buildTextureFromImage(d, c)
  }else {
    if(b.iconUrl) {
      var e = new Image, f = this;
      e.onload = function() {
        f._buildTextureFromImage(d, e);
        f.renderContext.requestFrame()
      };
      e.src = b.iconUrl
    }else {
      b.icon && this._buildTextureFromImage(d, b.icon)
    }
  }
  this.buckets.push(d);
  return d
};
GlobWeb.PointRenderer.prototype.render = function() {
  if(0 != this.buckets.length) {
    this.numberOfRenderPoints = 0;
    var a = this.renderContext, b = this.renderContext.gl;
    b.enable(b.BLEND);
    b.blendEquation(b.FUNC_ADD);
    b.blendFunc(b.SRC_ALPHA, b.ONE_MINUS_SRC_ALPHA);
    this.program.apply();
    mat4.multiply(a.projectionMatrix, a.viewMatrix, a.modelViewMatrix);
    b.uniformMatrix4fv(this.program.uniforms.viewProjectionMatrix, !1, a.modelViewMatrix);
    b.uniform1i(this.program.uniforms.texture, 0);
    mat4.inverse(a.viewMatrix, a.modelViewMatrix);
    var c = [a.modelViewMatrix[8], a.modelViewMatrix[9], a.modelViewMatrix[10]];
    vec3.normalize(c);
    vec3.scale(c, this.tileConfig.cullSign, c);
    var d = a.computePixelSizeVector();
    b.bindBuffer(b.ARRAY_BUFFER, this.vertexBuffer);
    b.vertexAttribPointer(this.program.attributes.vertex, 3, b.FLOAT, !1, 0, 0);
    for(var e = 0;e < this.buckets.length;e++) {
      var f = this.buckets[e];
      if(!(null == f.texture || 0 == f.points.length || !f.layer._visible || 0 >= f.layer._opactiy)) {
        b.activeTexture(b.TEXTURE0);
        b.bindTexture(b.TEXTURE_2D, f.texture);
        var g = [2 * f.textureWidth / a.canvas.width, 2 * f.textureHeight / a.canvas.height];
        b.uniform2fv(this.program.uniforms.poiScale, g);
        b.uniform2fv(this.program.uniforms.tst, [0.5 / f.textureWidth, 0.5 / f.textureHeight]);
        for(var h = 0;h < f.points.length;++h) {
          var i = f.points[h].pos3d, j = f.points[h].vertical, g = f.textureHeight * (d[0] * i[0] + d[1] * i[1] + d[2] * i[2] + d[3]), g = g * this.tileConfig.cullSign;
          !(0.001 * (g / GlobWeb.CoordinateSystem.heightScale) > f.style.pointMaxSize) && (0 < vec3.dot(j, c) && 0 <= a.worldFrustum.containsSphere(i, g)) && (b.uniform3f(this.program.uniforms.poiPosition, j[0] * g + i[0], j[1] * g + i[1], j[2] * g + i[2]), b.uniform1f(this.program.uniforms.alpha, f.layer._opacity), b.uniform3f(this.program.uniforms.color, f.points[h].color[0], f.points[h].color[1], f.points[h].color[2]), b.drawArrays(b.TRIANGLE_FAN, 0, 4), this.numberOfRenderPoints++)
        }
      }
    }
    b.disable(b.BLEND)
  }
};
GlobWeb.VectorRendererManager.registerRenderer({creator:function(a) {
  return new GlobWeb.PointRenderer(a.tileManager)
}, canApply:function(a) {
  return"Point" == a
}});
GlobWeb.FeatureStyle = function(a) {
  this.strokeColor = [1, 0, 0, 1];
  this.fillColor = [1, 0, 0, 1];
  this.fillTextureUrl = null;
  this.strokeWidth = 1;
  this.iconUrl = "hotspot.png";
  this.label = this.icon = null;
  this.textColor = [1, 1, 1, 1];
  this.fill = !1;
  this.pointMaxSize = 40;
  this.opacity = 1;
  this.rendererHint = "Tiled";
  if(a) {
    for(var b in a) {
      this[b] = a[b]
    }
  }
};
GlobWeb.FeatureStyle.fromStringToColor = function() {
  var a = {aliceblue:"f0f8ff", antiquewhite:"faebd7", aqua:"00ffff", aquamarine:"7fffd4", azure:"f0ffff", beige:"f5f5dc", bisque:"ffe4c4", black:"000000", blanchedalmond:"ffebcd", blue:"0000ff", blueviolet:"8a2be2", brown:"a52a2a", burlywood:"deb887", cadetblue:"5f9ea0", chartreuse:"7fff00", chocolate:"d2691e", coral:"ff7f50", cornflowerblue:"6495ed", cornsilk:"fff8dc", crimson:"dc143c", cyan:"00ffff", darkblue:"00008b", darkcyan:"008b8b", darkgoldenrod:"b8860b", darkgray:"a9a9a9", darkgreen:"006400", 
  darkkhaki:"bdb76b", darkmagenta:"8b008b", darkolivegreen:"556b2f", darkorange:"ff8c00", darkorchid:"9932cc", darkred:"8b0000", darksalmon:"e9967a", darkseagreen:"8fbc8f", darkslateblue:"483d8b", darkslategray:"2f4f4f", darkturquoise:"00ced1", darkviolet:"9400d3", deeppink:"ff1493", deepskyblue:"00bfff", dimgray:"696969", dodgerblue:"1e90ff", feldspar:"d19275", firebrick:"b22222", floralwhite:"fffaf0", forestgreen:"228b22", fuchsia:"ff00ff", gainsboro:"dcdcdc", ghostwhite:"f8f8ff", gold:"ffd700", 
  goldenrod:"daa520", gray:"808080", green:"008000", greenyellow:"adff2f", honeydew:"f0fff0", hotpink:"ff69b4", indianred:"cd5c5c", indigo:"4b0082", ivory:"fffff0", khaki:"f0e68c", lavender:"e6e6fa", lavenderblush:"fff0f5", lawngreen:"7cfc00", lemonchiffon:"fffacd", lightblue:"add8e6", lightcoral:"f08080", lightcyan:"e0ffff", lightgoldenrodyellow:"fafad2", lightgrey:"d3d3d3", lightgreen:"90ee90", lightpink:"ffb6c1", lightsalmon:"ffa07a", lightseagreen:"20b2aa", lightskyblue:"87cefa", lightslateblue:"8470ff", 
  lightslategray:"778899", lightsteelblue:"b0c4de", lightyellow:"ffffe0", lime:"00ff00", limegreen:"32cd32", linen:"faf0e6", magenta:"ff00ff", maroon:"800000", mediumaquamarine:"66cdaa", mediumblue:"0000cd", mediumorchid:"ba55d3", mediumpurple:"9370d8", mediumseagreen:"3cb371", mediumslateblue:"7b68ee", mediumspringgreen:"00fa9a", mediumturquoise:"48d1cc", mediumvioletred:"c71585", midnightblue:"191970", mintcream:"f5fffa", mistyrose:"ffe4e1", moccasin:"ffe4b5", navajowhite:"ffdead", navy:"000080", 
  oldlace:"fdf5e6", olive:"808000", olivedrab:"6b8e23", orange:"ffa500", orangered:"ff4500", orchid:"da70d6", palegoldenrod:"eee8aa", palegreen:"98fb98", paleturquoise:"afeeee", palevioletred:"d87093", papayawhip:"ffefd5", peachpuff:"ffdab9", peru:"cd853f", pink:"ffc0cb", plum:"dda0dd", powderblue:"b0e0e6", purple:"800080", red:"ff0000", rosybrown:"bc8f8f", royalblue:"4169e1", saddlebrown:"8b4513", salmon:"fa8072", sandybrown:"f4a460", seagreen:"2e8b57", seashell:"fff5ee", sienna:"a0522d", silver:"c0c0c0", 
  skyblue:"87ceeb", slateblue:"6a5acd", slategray:"708090", snow:"fffafa", springgreen:"00ff7f", steelblue:"4682b4", tan:"d2b48c", teal:"008080", thistle:"d8bfd8", tomato:"ff6347", turquoise:"40e0d0", violet:"ee82ee", violetred:"d02090", wheat:"f5deb3", white:"ffffff", whitesmoke:"f5f5f5", yellow:"ffff00", yellowgreen:"9acd32"}, b = /^(\w{2})(\w{2})(\w{2})$/, c = /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, d = /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3},\s*(\d{1,3}))\)$/;
  return function(e) {
    var f = 0, g = 0, h = 0, i = 255, j, e = e.trim(), e = e.toLowerCase();
    "#" == e.charAt(0) && (e = e.substr(1, 6));
    a.hasOwnProperty(e) && (e = a[e]);
    if(j = b.exec(e)) {
      f = parseInt(j[1], 16), g = parseInt(j[2], 16), h = parseInt(j[3], 16)
    }
    if(j = c.exec(e)) {
      f = parseInt(j[1]), g = parseInt(j[2]), h = parseInt(j[3])
    }
    if(j = d.exec(e)) {
      f = parseInt(j[1]), g = parseInt(j[2]), h = parseInt(j[3]), i = parseInt(j[4])
    }
    return[(0 > f ? 0 : 255 < f ? 255 : f) / 255, (0 > g ? 0 : 255 < g ? 255 : g) / 255, (0 > h ? 0 : 255 < h ? 255 : h) / 255, (0 > i ? 0 : 255 < i ? 255 : i) / 255]
  }
}();
GlobWeb.FeatureStyle.fromColorToString = function(a) {
  var b = parseInt(255 * a[0]).toString(16), c = parseInt(255 * a[1]).toString(16), a = parseInt(255 * a[2]).toString(16);
  return"#" + b + c + a
};
GlobWeb.FeatureStyle.prototype.isEqualForPoly = function(a) {
  return this.fill == a.fill
};
GlobWeb.FeatureStyle.prototype.isEqualForLine = function(a) {
  return this.strokeColor[0] == a.strokeColor[0] && this.strokeColor[1] == a.strokeColor[1] && this.strokeColor[2] == a.strokeColor[2] && this.strokeColor[3] == a.strokeColor[3] && this.strokeWidth == a.strokeWidth
};
GlobWeb.FeatureStyle.prototype.isEqualForPoint = function(a) {
  return this.iconUrl == a.iconUrl && this.icon == a.icon && this.label == a.label
};
GlobWeb.TiledVectorRenderable = function(a, b) {
  this.gl = b;
  this.bucket = a;
  this.indexBuffer = this.vertexBuffer = null;
  this.vertices = [];
  this.indices = [];
  this.geometryInfos = [];
  this.dirtyIB = this.dirtyVB = !0;
  this.childrenIndices = this.childrenIndexBuffers = null;
  this.glMode = -1
};
GlobWeb.TiledVectorRenderable.prototype.buildChildrenIndices = function() {
  this.childrenIndices = [[], [], [], []];
  this.childrenIndexBuffers = [null, null, null, null]
};
GlobWeb.TiledVectorRenderable.prototype.removeGeometry = function(a) {
  for(var b = -1, c = 0;c < this.geometryInfos.length;c++) {
    var d = this.geometryInfos[c];
    if(d.geometry == a) {
      this.vertices.splice(d.startVertices, d.vertexCount);
      this.indices.splice(d.startIndices, d.indexCount);
      a = d.vertexCount / 3;
      for(d = d.startIndices;d < this.indices.length;d++) {
        this.indices[d] -= a
      }
      b = c;
      break
    }
  }
  if(0 <= b) {
    this.dirtyIB = this.dirtyVB = !0;
    for(c = b + 1;c < this.geometryInfos.length;c++) {
      d = this.geometryInfos[c], d.startVertices -= this.geometryInfos[b].vertexCount, d.startIndices -= this.geometryInfos[b].indexCount
    }
    this.geometryInfos.splice(b, 1);
    this.disposeChildrenIndexBuffers();
    this.childrenIndices = null;
    return!0
  }
  return!1
};
GlobWeb.TiledVectorRenderable.prototype._fixDateLine = function(a, b) {
  for(var c = !1, d = b[0][0], e = 1;e < b.length && !c;e++) {
    180 < Math.abs(b[e][0] - d) && (c = !0)
  }
  if(c) {
    c = [];
    if(0 > a.geoBound.west) {
      for(d = 0;d < b.length;d++) {
        c[d] = 0 < b[d][0] ? [b[d][0] - 360, b[d][1]] : [b[d][0], b[d][1]]
      }
    }else {
      for(d = 0;d < b.length;d++) {
        c[d] = 0 > b[d][0] ? [b[d][0] + 360, b[d][1]] : [b[d][0], b[d][1]]
      }
    }
    return c
  }
  return b
};
GlobWeb.TiledVectorRenderable.prototype.addGeometry = function(a, b) {
  var c = {geometry:a, startVertices:this.vertices.length, startIndices:this.indices.length, vertexCount:0, indexCount:0}, d = a.coordinates;
  switch(a.type) {
    case "LineString":
      this.buildVerticesAndIndices(b, d);
      break;
    case "Polygon":
      this.buildVerticesAndIndices(b, d[0]);
      break;
    case "MultiLineString":
      for(var e = 0;e < d.length;e++) {
        this.buildVerticesAndIndices(b, d[e])
      }
      break;
    case "MultiPolygon":
      for(e = 0;e < d.length;e++) {
        this.buildVerticesAndIndices(b, d[e][0])
      }
  }
  c.vertexCount = this.vertices.length - c.startVertices;
  c.indexCount = this.indices.length - c.startIndices;
  return 0 < c.vertexCount ? (this.geometryInfos.push(c), this.dirtyIB = this.dirtyVB = !0, this.disposeChildrenIndexBuffers(), this.childrenIndices = null, !0) : !1
};
GlobWeb.TiledVectorRenderable.prototype.disposeChildrenIndexBuffers = function() {
  var a = this.gl;
  this.childrenIndexBuffers && (this.childrenIndexBuffers[0] && a.deleteBuffer(this.childrenIndexBuffers[0]), this.childrenIndexBuffers[1] && a.deleteBuffer(this.childrenIndexBuffers[1]), this.childrenIndexBuffers[2] && a.deleteBuffer(this.childrenIndexBuffers[2]), this.childrenIndexBuffers[3] && a.deleteBuffer(this.childrenIndexBuffers[3]));
  this.childrenIndexBuffers = null
};
GlobWeb.TiledVectorRenderable.prototype.dispose = function() {
  var a = this.gl;
  this.indexBuffer && a.deleteBuffer(this.indexBuffer);
  this.vertexBuffer && a.deleteBuffer(this.vertexBuffer);
  this.disposeChildrenIndexBuffers();
  this.vertexBuffer = this.indexBuffer = null
};
GlobWeb.TiledVectorRenderable.prototype.renderChild = function(a, b) {
  null == this.childrenIndices && this.buildChildrenIndices();
  var c = this.childrenIndices[b];
  if(0 != c.length) {
    var d = this.gl;
    null == this.vertexBuffer && (this.vertexBuffer = d.createBuffer());
    d.bindBuffer(d.ARRAY_BUFFER, this.vertexBuffer);
    this.dirtyVB && (d.bufferData(d.ARRAY_BUFFER, new Float32Array(this.vertices), d.STATIC_DRAW), this.dirtyVB = !1);
    d.vertexAttribPointer(a.vertex, 3, d.FLOAT, !1, 0, 0);
    var e = this.childrenIndexBuffers[b];
    e ? d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, e) : (d = this.gl, e = d.createBuffer(), d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, e), d.bufferData(d.ELEMENT_ARRAY_BUFFER, new Uint16Array(c), d.STATIC_DRAW), this.childrenIndexBuffers[b] = e);
    d.drawElements(this.glMode, c.length, d.UNSIGNED_SHORT, 0)
  }
};
GlobWeb.TiledVectorRenderable.prototype.render = function(a) {
  var b = this.gl;
  null == this.vertexBuffer && (this.vertexBuffer = b.createBuffer());
  b.bindBuffer(b.ARRAY_BUFFER, this.vertexBuffer);
  this.dirtyVB && (b.bufferData(b.ARRAY_BUFFER, new Float32Array(this.vertices), b.STATIC_DRAW), this.dirtyVB = !1);
  b.vertexAttribPointer(a.vertex, 3, b.FLOAT, !1, 0, 0);
  null == this.indexBuffer && (this.indexBuffer = b.createBuffer());
  b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
  this.dirtyIB && (b.bufferData(b.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.indices), b.STATIC_DRAW), this.dirtyIB = !1);
  b.drawElements(this.glMode, this.indices.length, b.UNSIGNED_SHORT, 0)
};
GlobWeb.LineStringRenderable = function(a, b) {
  GlobWeb.TiledVectorRenderable.prototype.constructor.call(this, a, b);
  this.glMode = b.LINES
};
GlobWeb.inherits(GlobWeb.TiledVectorRenderable, GlobWeb.LineStringRenderable);
GlobWeb.LineStringRenderable.prototype.buildChildrenIndices = function() {
  this.childrenIndices = [[], [], [], []];
  this.childrenIndexBuffers = [null, null, null, null];
  for(var a = 0;a < this.indices.length / 2;a++) {
    var b = 3 * this.indices[2 * a], c = 3 * this.indices[2 * a + 1], d = this.vertices[b], e = this.vertices[c], f = 0;
    if(0 < d || 0 == d && 0 < e) {
      f = 1
    }
    b = this.vertices[b + 1];
    c = this.vertices[c + 1];
    d = 1;
    if(0 < b || 0 == b && 0 < c) {
      d = 0
    }
    this.childrenIndices[2 * d + f].push(this.indices[2 * a]);
    this.childrenIndices[2 * d + f].push(this.indices[2 * a + 1])
  }
};
GlobWeb.LineStringRenderable.prototype.buildVerticesAndIndices = function(a, b) {
  for(var c = this._fixDateLine(a, b), d = a.config.tesselation, e = a.config.vertexSize, f = a.lonlat2tile(b), g = 0;g < c.length - 1;g++) {
    for(var h = f[g][0], i = f[g][1], j = f[g + 1][0], k = f[g + 1][1], l = [], m = Math.max(-1, Math.min(h, j)), p = Math.min(d - 1, Math.max(h, j)), m = Math.floor(m) + 1;m < Math.floor(p) + 1;m++) {
      var n = m, o = Numeric.lineIntersection(h, i, j, k, n, 0, n, d - 1);
      if(0 < o[0] && 1 > o[0] && 0 < o[1] && 1 > o[1]) {
        var n = o[1] * (d - 1), q = Math.floor(n), s = n - q, r = e * (q * d + m), n = (1 - s) * a.vertices[r] + s * a.vertices[r + e * d], q = (1 - s) * a.vertices[r + 1] + s * a.vertices[r + e * d + 1], r = (1 - s) * a.vertices[r + 2] + s * a.vertices[r + e * d + 2];
        l.push([o[0], n, q, r])
      }
    }
    m = Math.max(-1, Math.min(i, k));
    p = Math.min(d - 1, Math.max(i, k));
    for(m = Math.floor(m) + 1;m < Math.floor(p) + 1;m++) {
      n = m, o = Numeric.lineIntersection(h, i, j, k, 0, n, d - 1, n), 0 < o[0] && (1 > o[0] && 0 < o[1] && 1 > o[1]) && (n = o[1] * (d - 1), q = Math.floor(n), s = n - q, r = e * (m * d + q), n = (1 - s) * a.vertices[r] + s * a.vertices[r + e], q = (1 - s) * a.vertices[r + 1] + s * a.vertices[r + e + 1], r = (1 - s) * a.vertices[r + 2] + s * a.vertices[r + e + 2], l.push([o[0], n, q, r]))
    }
    l.sort(function(a, b) {
      return a[0] > b[0]
    });
    o = this.vertices.length / 3;
    0 < h && (h < d - 1 && 0 < i && i < d - 1) && (h = a.computePosition(h, i), this.vertices.push(h[0]), this.vertices.push(h[1]), this.vertices.push(h[2]));
    for(m = 0;m < l.length;m++) {
      this.vertices.push(l[m][1]), this.vertices.push(l[m][2]), this.vertices.push(l[m][3])
    }
    0 < j && (j < d - 1 && 0 < k && k < d - 1) && (h = a.computePosition(j, k), this.vertices.push(h[0]), this.vertices.push(h[1]), this.vertices.push(h[2]));
    j = this.vertices.length / 3;
    for(m = o;m < j - 1;m++) {
      this.indices.push(m), this.indices.push(m + 1)
    }
  }
};
GlobWeb.VectorRendererManager.registerRenderer({creator:function(a) {
  a = new GlobWeb.TiledVectorRenderer(a.tileManager);
  a.id = "lineString";
  a.styleEquals = function(a, c) {
    return a.isEqualForLine(c)
  };
  a.renderableConstuctor = GlobWeb.LineStringRenderable;
  return a
}, canApply:function(a, b) {
  return"Tiled" == b.rendererHint && ("LineString" == a || "MultiLineString" == a || !b.fill && ("Polygon" == a || "MultiPolygon" == a))
}});
GlobWeb.TiledVectorRenderer = function(a) {
  this.tileManager = a;
  this.buckets = [{style:new GlobWeb.FeatureStyle, geometries:[]}];
  this.program = new GlobWeb.Program(this.tileManager.renderContext);
  this.program.createFromSource("\tattribute vec3 vertex; \n\tuniform float zOffset; \n\tuniform mat4 modelViewMatrix;\n\tuniform mat4 projectionMatrix;\n\t\n\tvoid main(void)  \n\t{ \n\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(vertex.x, vertex.y, vertex.z + zOffset, 1.0); \n\t} \n\t", "\t#ifdef GL_ES \n\tprecision highp float; \n\t#endif \n\tuniform vec4 color; \n\t\n\tvoid main(void) \n\t{ \n\t\tgl_FragColor = color; \n\t} \n\t");
  this.renderableConstuctor = this.styleEquals = null;
  this.id = "empty"
};
GlobWeb.TiledVectorRenderer.prototype.getOrCreateBucket = function(a, b) {
  for(var c = 0;c < this.buckets.length;c++) {
    if(this.buckets[c].layer == a && this.styleEquals(b, this.buckets[c].style)) {
      return this.buckets[c]
    }
  }
  c = {layer:a, style:b, geometries:[]};
  this.buckets.push(c);
  return c
};
GlobWeb.TiledVectorRenderer.prototype.findRenderable = function(a, b) {
  if(b.extension[this.id]) {
    for(var c = b.extension[this.id].renderables, d = 0;d < c.length;d++) {
      if(c[d].bucket == a) {
        return c[d]
      }
    }
  }
  return null
};
GlobWeb.TiledVectorRenderer.prototype.removeGeometryFromTile = function(a, b, c) {
  var d = this.findRenderable(a, c);
  if(d && d.removeGeometry(b) && c.children) {
    for(d = 0;4 > d;d++) {
      c.children[d].state == GlobWeb.Tile.State.LOADED && this.removeGeometryFromTile(a, b, c.children[d])
    }
  }
};
GlobWeb.TiledVectorRenderer.prototype.removeGeometry = function(a, b) {
  for(var c = null, d = 0;d < this.buckets.length && !c;d++) {
    var e = this.buckets[d];
    if(e.layer == b) {
      var f = e.geometries.indexOf(a);
      -1 != f && (e = this.buckets[d], e.geometries.splice(f, 1), c = e)
    }
  }
  if(c) {
    for(d = 0;d < this.tileManager.level0Tiles.length;d++) {
      this.removeGeometryFromTile(c, a, this.tileManager.level0Tiles[d])
    }
  }
};
GlobWeb.TiledVectorRenderer.prototype.cleanupTile = function(a) {
  a.extension[this.id] && (a.extension[this.id].dispose(), delete a.extension[this.id])
};
GlobWeb.TiledVectorRenderer.prototype.addGeometry = function(a, b, c) {
  b = this.getOrCreateBucket(b, c);
  b.geometries.push(a);
  for(c = 0;c < this.tileManager.level0Tiles.length;c++) {
    var d = this.tileManager.level0Tiles[c];
    d.state == GlobWeb.Tile.State.LOADED && this.addGeometryToTile(b, a, d)
  }
};
GlobWeb.TiledVectorRenderer.prototype.addGeometryToTile = function(a, b, c) {
  var d = !1, e = this.findRenderable(a, c);
  e || (e = new this.renderableConstuctor(a, this.tileManager.renderContext.gl), d = !0);
  if(e.addGeometry(b, c) && c.children) {
    for(var f = 0;4 > f;f++) {
      c.children[f].state == GlobWeb.Tile.State.LOADED && this.addGeometryToTile(a, b, c.children[f])
    }
  }
  d && this.addRenderableToTile(c, e)
};
GlobWeb.TiledVectorRenderer.TileData = function() {
  this.renderables = []
};
GlobWeb.TiledVectorRenderer.TileData.prototype.dispose = function() {
  for(var a = 0;a < this.renderables.length;a++) {
    this.renderables[a].dispose()
  }
  this.renderables.length = 0
};
GlobWeb.TiledVectorRenderer.prototype.addRenderableToTile = function(a, b) {
  0 < b.vertices.length && (a.extension[this.id] || (a.extension[this.id] = new GlobWeb.TiledVectorRenderer.TileData), a.extension[this.id].renderables.push(b))
};
GlobWeb.TiledVectorRenderer.prototype.generate = function(a) {
  if(a.parent) {
    for(var b = a.parent.extension[this.id], c = b ? b.renderables.length : 0, d = 0;d < c;d++) {
      for(var e = b.renderables[d], f = new this.renderableConstuctor(e.bucket, this.tileManager.renderContext.gl), g = e.geometryInfos, e = 0;e < g.length;e++) {
        f.addGeometry(g[e].geometry, a)
      }
      this.addRenderableToTile(a, f)
    }
  }else {
    for(d = 0;d < this.buckets.length;d++) {
      b = this.buckets[d];
      f = new this.renderableConstuctor(b, this.tileManager.renderContext.gl);
      for(e = 0;e < b.geometries.length;e++) {
        f.addGeometry(b.geometries[e], a)
      }
      this.addRenderableToTile(a, f)
    }
  }
};
GlobWeb.TiledVectorRenderer.prototype.render = function(a) {
  var b = this.tileManager.renderContext, c = b.gl, d = mat4.create();
  this.program.apply();
  c.depthFunc(c.LEQUAL);
  c.uniformMatrix4fv(this.program.uniforms.projectionMatrix, !1, b.projectionMatrix);
  for(var e = null, f = 0;f < a.length;++f) {
    var g = a[f];
    if(g.extension[this.id]) {
      mat4.multiply(b.viewMatrix, g.matrix, d);
      c.uniformMatrix4fv(this.program.uniforms.modelViewMatrix, !1, d);
      c.uniform1f(this.program.uniforms.zOffset, 7E-4 * g.radius);
      for(var h = g.extension[this.id].renderables, i = 0;i < h.length;i++) {
        var j = h[i];
        j.bucket.layer._visible && (j.bucket.style != e && (e = j.bucket.style, c.lineWidth(e.strokeWidth), c.uniform4f(this.program.uniforms.color, e.strokeColor[0], e.strokeColor[1], e.strokeColor[2], e.strokeColor[3] * j.bucket.layer._opacity)), h[i].render(this.program.attributes))
      }
    }else {
      if(g.state != GlobWeb.Tile.State.LOADED && g.parent.extension[this.id]) {
        mat4.multiply(b.viewMatrix, g.parent.matrix, d);
        c.uniformMatrix4fv(this.program.uniforms.modelViewMatrix, !1, d);
        c.uniform1f(this.program.uniforms.zOffset, 7E-4 * g.parent.radius);
        h = g.parent.extension[this.id].renderables;
        for(i = 0;i < h.length;i++) {
          j = h[i], j.bucket.layer._visible && (j.bucket.style != e && (e = j.bucket.style, c.lineWidth(e.strokeWidth), c.uniform4f(this.program.uniforms.color, e.strokeColor[0], e.strokeColor[1], e.strokeColor[2], e.strokeColor[3] * j.bucket.layer._opacity)), h[i].renderChild(this.program.attributes, g.parentIndex))
        }
      }
    }
  }
  c.depthFunc(c.LESS)
};
GlobWeb.VectorLayer = function(a) {
  GlobWeb.BaseLayer.prototype.constructor.call(this, a);
  this.style = a && a.style ? a.style : new GlobWeb.FeatureStyle;
  this.features = [];
  this.type = "Vector"
};
GlobWeb.inherits(GlobWeb.BaseLayer, GlobWeb.VectorLayer);
GlobWeb.VectorLayer.prototype._attach = function(a) {
  GlobWeb.BaseLayer.prototype._attach.call(this, a);
  this.attribution && this.globe.attributionHandler.addAttribution(this);
  for(a = 0;a < this.features.length;a++) {
    this._addFeatureToRenderers(this.features[a])
  }
};
GlobWeb.VectorLayer.prototype._detach = function() {
  for(var a = 0;a < this.features.length;a++) {
    this._removeFeatureFromRenderers(this.features[a])
  }
  GlobWeb.BaseLayer.prototype._detach.call(this)
};
GlobWeb.VectorLayer.prototype.addFeatureCollection = function(a) {
  if(a = a.features) {
    for(var b = 0;b < a.length;b++) {
      this.addFeature(a[b])
    }
  }
};
GlobWeb.VectorLayer.prototype.removeFeatureCollection = function(a) {
  if(a = a.features) {
    for(var b = 0;b < a.length;b++) {
      this.removeFeature(a[b])
    }
  }
};
GlobWeb.VectorLayer.prototype._addFeatureToRenderers = function(a) {
  var b = a.geometry, c = this.style;
  if((a = a.properties) && a.style) {
    c = a.style, c.rendererHint = this.style.rendererHint
  }
  if("GeometryCollection" == b.type) {
    b = b.geometries;
    for(a = 0;a < b.length;a++) {
      this.globe.vectorRendererManager.addGeometry(b[a], this, c)
    }
  }else {
    this.globe.vectorRendererManager.addGeometry(b, this, c)
  }
};
GlobWeb.VectorLayer.prototype._removeFeatureFromRenderers = function(a) {
  a = a.geometry;
  if("GeometryCollection" == a.type) {
    for(var a = a.geometries, b = 0;b < a.length;b++) {
      this.globe.vectorRendererManager.removeGeometry(a[b], this)
    }
  }else {
    this.globe.vectorRendererManager.removeGeometry(a, this)
  }
};
GlobWeb.VectorLayer.prototype.addFeature = function(a) {
  var b = a.geometry;
  b && b.type && (this.features.push(a), this.globe && (this._addFeatureToRenderers(a), this._visible && this.globe.renderContext.requestFrame()))
};
GlobWeb.VectorLayer.prototype.removeFeature = function(a) {
  var b = this.features.indexOf(a);
  this.features.splice(b, 1);
  this.globe && (this._removeFeatureFromRenderers(a), this._visible && this.globe.renderContext.requestFrame())
};
GlobWeb.VectorLayer.prototype.removeAllFeatures = function() {
  if(this.globe) {
    for(var a = 0;a < this.features.length;a++) {
      this._removeFeatureFromRenderers(feature)
    }
  }
  this.features.length = 0;
  this.globe && this._visible && this.globe.renderContext.requestFrame()
};
GlobWeb.VectorLayer.prototype.modifyFeatureStyle = function(a, b) {
  this._removeFeatureFromRenderers(a);
  a.properties.style = b;
  this._addFeatureToRenderers(a)
};
GlobWeb.VectorLayer.prototype.modifyStyle = function(a) {
  for(var b = 0;b < this.features.length;b++) {
    this._removeFeatureFromRenderers(this.features[b])
  }
  this.style = a;
  for(b = 0;b < this.features.length;b++) {
    this._addFeatureToRenderers(this.features[b])
  }
};
GlobWeb.KMLParser = function() {
  var a = {type:"FeatureCollection", features:[]}, b = {}, c = function(a) {
    for(var b = [], a = a.trim().split(/[\s,]+/), c = 0;c < a.length;c += 3) {
      b.push([parseFloat(a[c]), parseFloat(a[c + 1])])
    }
    return b
  }, d = function(a) {
    switch(a.nodeName) {
      case "MultiGeometry":
        for(var b = [], a = a.childNodes, e = 0;e < a.length;e++) {
          var f = d(a[e]);
          f && b.push(f)
        }
        return{type:"GeometryCollection", geometries:b};
      case "LineString":
        b = a.getElementsByTagName("coordinates");
        if(1 == b.length) {
          return{type:"LineString", coordinates:c(b[0].textContent)}
        }
        break;
      case "Polygon":
        b = a.firstElementChild.getElementsByTagName("coordinates");
        if(1 == b.length) {
          return{type:"Polygon", coordinates:[c(b[0].textContent)]}
        }
        break;
      case "Point":
        if(b = a.getElementsByTagName("coordinates"), 1 == b.length) {
          return b = b[0].textContent.split(","), {type:"Point", coordinates:[b[0], b[1]]}
        }
    }
    return null
  }, e = function(a) {
    var c = "#" + a.getAttribute("id"), d = new GlobWeb.FeatureStyle;
    b[c] = d;
    for(a = a.firstElementChild;a;) {
      switch(a.nodeName) {
        case "LineStyle":
          for(var c = d, e = a.firstElementChild;e;) {
            switch(e.nodeName) {
              case "color":
                c.strokeColor = GlobWeb.FeatureStyle.fromStringToColor(e.childNodes[0].nodeValue);
                break;
              case "width":
                c.strokeWidth = parseFloat(e.childNodes[0].nodeValue)
            }
            e = e.nextElementSibling
          }
          break;
        case "IconStyle":
          c = d;
          for(e = a.firstElementChild;e;) {
            switch(e.nodeName) {
              case "Icon":
                c.iconUrl = e.firstElementChild ? e.firstElementChild.childNodes[0].nodeValue : null
            }
            e = e.nextElementSibling
          }
          break;
        case "LabelStyle":
          c = d;
          for(e = a.firstElementChild;e;) {
            switch(e.nodeName) {
              case "color":
                var f = GlobWeb.FeatureStyle.fromStringToColor(e.textContent.trim());
                0 == f[3] && (c.label = null, c.textColor = f)
            }
            e = e.nextElementSibling
          }
      }
      a = a.nextElementSibling
    }
    return d
  }, f = function(c) {
    switch(c.nodeName) {
      case "Placemark":
        for(var h = {type:"Feature", properties:{}, geometry:null}, i = !1, c = c.firstElementChild;c;) {
          switch(c.nodeName) {
            case "name":
              h.properties.name = c.childNodes[0].nodeValue;
              break;
            case "styleUrl":
              var j = c.childNodes[0].nodeValue;
              b.hasOwnProperty(j) && (h.properties.style = b[j], i = !0);
              break;
            case "Style":
              if(j = e(c, h.properties.name)) {
                h.properties.style = j
              }
              break;
            default:
              null == h.geometry && (h.geometry = d(c))
          }
          c = c.nextElementSibling
        }
        if(h.geometry) {
          if((j = h.properties.style) && 0 < j.textColor[3] && "Point" == h.geometry.type) {
            i && (j = h.properties.style = new GlobWeb.FeatureStyle(j)), j.label = h.properties.name
          }
          a.features.push(h)
        }
        break;
      case "Document":
      ;
      case "Folder":
        a: {
          for(h = c.firstElementChild;h;) {
            switch(h.nodeName) {
              case "visibility":
                if(0 == parseInt(h.textContent)) {
                  break a
                }
                break;
              case "Style":
                e(h);
                break;
              default:
                f(h)
            }
            h = h.nextElementSibling
          }
        }
    }
  };
  return{parse:function(b) {
    for(b = b.documentElement.firstElementChild;b;) {
      f(b), b = b.nextElementSibling
    }
    return a
  }}
}();
GlobWeb.Navigation = function(a, b) {
  this.minDistance = 1;
  this.maxDistance = 3 * GlobWeb.CoordinateSystem.realEarthRadius;
  GlobWeb.BaseNavigation.prototype.constructor.call(this, a, b);
  this.geoCenter = [0, 0, 0];
  this.heading = 0;
  this.tilt = 90;
  this.distance = 3 * GlobWeb.CoordinateSystem.radius;
  this.minDistance *= GlobWeb.CoordinateSystem.heightScale;
  this.maxDistance *= GlobWeb.CoordinateSystem.heightScale;
  this.inverseViewMatrix = mat4.create();
  this.computeViewMatrix()
};
GlobWeb.inherits(GlobWeb.BaseNavigation, GlobWeb.Navigation);
GlobWeb.Navigation.prototype.zoomTo = function(a, b, c, d) {
  var e = this, f = b || this.distance / (4 * GlobWeb.CoordinateSystem.heightScale), b = d || 90, d = [this.geoCenter[0], this.geoCenter[1], this.distance, this.tilt], f = [a[0], a[1], f * GlobWeb.CoordinateSystem.heightScale, b], c = new GlobWeb.SegmentedAnimation(c || 5E3, function(a) {
    e.geoCenter[0] = a[0];
    e.geoCenter[1] = a[1];
    e.distance = a[2];
    e.tilt = a[3];
    e.computeViewMatrix()
  }), g = GlobWeb.CoordinateSystem.fromGeoTo3D(this.geoCenter), a = GlobWeb.CoordinateSystem.fromGeoTo3D(a), a = vec3.subtract(g, a), a = vec3.length(a), g = this.globe.renderContext.canvas, g = Math.min(Numeric.toRadian(45), Numeric.toRadian(45 * g.width / g.height)), a = 1.1 * (a / 2 / Math.tan(g / 2));
  a > this.distance ? (b = [0.5 * d[0] + 0.5 * f[0], 0.5 * d[1] + 0.5 * f[1], a, b], c.addSegment(0, d, 0.5, b, function(a, b, c) {
    var d = Numeric.easeInQuad(a), e = Numeric.easeOutQuad(a);
    return[Numeric.lerp(d, b[0], c[0]), Numeric.lerp(d, b[1], c[1]), Numeric.lerp(e, b[2], c[2]), Numeric.lerp(a, b[3], c[3])]
  }), c.addSegment(0.5, b, 1, f, function(a, b, c) {
    var d = Numeric.easeOutQuad(a), e = Numeric.easeInQuad(a);
    return[Numeric.lerp(d, b[0], c[0]), Numeric.lerp(d, b[1], c[1]), Numeric.lerp(e, b[2], c[2]), Numeric.lerp(a, b[3], c[3])]
  })) : c.addSegment(0, d, 1, f, function(a, b, c) {
    var d = Numeric.easeOutQuad(a), e = Numeric.easeInQuad(a);
    return[Numeric.lerp(d, b[0], c[0]), Numeric.lerp(d, b[1], c[1]), Numeric.lerp(e, b[2], c[2]), Numeric.lerp(a, b[3], c[3])]
  });
  c.onstop = function() {
    e.globe.publish("endNavigation")
  };
  this.globe.addAnimation(c);
  c.start();
  this.globe.publish("startNavigation")
};
GlobWeb.Navigation.prototype.applyLocalRotation = function(a) {
  mat4.rotate(a, this.heading * Math.PI / 180, [0, 0, 1]);
  mat4.rotate(a, (90 - this.tilt) * Math.PI / 180, [1, 0, 0])
};
GlobWeb.Navigation.prototype.computeViewMatrix = function() {
  this.computeInverseViewMatrix();
  mat4.inverse(this.inverseViewMatrix, this.globe.renderContext.viewMatrix)
};
GlobWeb.Navigation.prototype.computeInverseViewMatrix = function() {
  GlobWeb.CoordinateSystem.getLHVTransform(this.geoCenter, this.inverseViewMatrix);
  this.applyLocalRotation(this.inverseViewMatrix);
  mat4.translate(this.inverseViewMatrix, [0, 0, this.distance])
};
GlobWeb.Navigation.prototype.zoom = function(a) {
  this.globe.publish("startNavigation");
  var b = this.distance;
  this.distance *= 1 + 0.1 * a;
  this.distance > this.maxDistance && (this.distance = this.maxDistance);
  this.distance < this.minDistance && (this.distance = this.minDistance);
  this.computeViewMatrix();
  this.hasCollision() && (this.distance = b, this.computeViewMatrix());
  this.globe.publish("endNavigation")
};
GlobWeb.Navigation.prototype.hasCollision = function() {
  var a = [this.inverseViewMatrix[12], this.inverseViewMatrix[13], this.inverseViewMatrix[14]], b = vec3.create();
  GlobWeb.CoordinateSystem.from3DToGeo(a, b);
  a = this.globe.getElevation(b[0], b[1]);
  return b[2] < a + 50
};
GlobWeb.Navigation.prototype.pan = function(a, b) {
  var c = vec3.create();
  vec3.set(this.geoCenter, c);
  var d = mat4.create();
  GlobWeb.CoordinateSystem.getLocalTransform(this.geoCenter, d);
  var e = vec3.create(), f = vec3.create([0, 1, 0]);
  GlobWeb.CoordinateSystem.getUpVector(d, e);
  mat4.multiplyVec3(d, f, f);
  this.applyLocalRotation(d);
  var g = vec3.create(), h = vec3.create();
  GlobWeb.CoordinateSystem.getSideVector(d, g);
  GlobWeb.CoordinateSystem.getFrontVector(d, h);
  vec3.cross(e, g, h);
  vec3.cross(h, e, g);
  vec3.normalize(g, g);
  vec3.normalize(h, h);
  a /= this.globe.renderContext.canvas.width;
  b /= this.globe.renderContext.canvas.height;
  e = vec3.create();
  GlobWeb.CoordinateSystem.fromGeoTo3D(this.geoCenter, e);
  vec3.scale(g, a * this.distance, g);
  vec3.scale(h, b * this.distance, h);
  vec3.subtract(e, g, e);
  vec3.add(e, h, e);
  vec3.normalize(e);
  vec3.scale(e, GlobWeb.CoordinateSystem.radius);
  GlobWeb.CoordinateSystem.from3DToGeo(e, this.geoCenter);
  g = vec3.create([0, 1, 0]);
  GlobWeb.CoordinateSystem.getLocalTransform(this.geoCenter, d);
  mat4.multiplyVec3(d, g, g);
  0 > vec3.dot(f, g) && (this.heading = (this.heading + 180) % 360);
  this.computeViewMatrix();
  this.hasCollision() && (this.geoCenter = c, this.computeViewMatrix())
};
GlobWeb.Navigation.prototype.rotate = function(a, b) {
  var c = this.heading, d = this.tilt;
  this.heading += 0.1 * a;
  this.tilt += 0.1 * b;
  this.computeViewMatrix();
  this.hasCollision() && (this.heading = c, this.tilt = d, this.computeViewMatrix())
};
GlobWeb.AtmosphereLayer = function(a) {
  GlobWeb.BaseLayer.prototype.constructor.call(this, a);
  this.name || (this.name = "Atmosphere");
  this.kr = a && a.kr || 0.0025;
  this.km = a && a.km || 0.0015;
  this.sunBrightness = a && a.sunBrightness || 15;
  this.exposure = a && a.exposure || 2;
  this.wavelength = a && a.wavelength || [0.65, 0.57, 0.475];
  this._innerRadius = GlobWeb.CoordinateSystem.radius;
  this._outerRadius = 1.025 * this._innerRadius;
  this._originalProgram = this._groundProgram = this._skyProgram = null;
  this._isValid = !1
};
GlobWeb.inherits(GlobWeb.BaseLayer, GlobWeb.AtmosphereLayer);
GlobWeb.AtmosphereLayer.prototype._attach = function(a) {
  this.globe = a;
  var b = a.renderContext;
  this._skyFromSpaceProgram = new GlobWeb.Program(b);
  this._skyFromSpaceProgram.loadFromFile("SkyFromSpaceVert.glsl", "SkyFrag.glsl");
  this._skyFromAtmosphereProgram = new GlobWeb.Program(b);
  this._skyFromAtmosphereProgram.loadFromFile("SkyFromAtmosphereVert.glsl", "SkyFrag.glsl");
  this._groundFromSpaceProgram = new GlobWeb.Program(b);
  this._groundFromSpaceProgram.loadFromFile("GroundFromSpaceVert.glsl", "GroundFrag.glsl");
  this._groundFromAtmosphereProgram = new GlobWeb.Program(b);
  this._groundFromAtmosphereProgram.loadFromFile("GroundFromAtmosphereVert.glsl", "GroundFrag.glsl");
  if(this._isValid = null != this._skyFromSpaceProgram.glProgram && null != this._skyFromAtmosphereProgram.glProgram && null != this._groundFromSpaceProgram.glProgram && null != this._groundFromAtmosphereProgram.glProgram) {
    this._skyFromSpaceProgram.apply();
    this._initUniforms(this._skyFromSpaceProgram.uniforms);
    this._skyFromAtmosphereProgram.apply();
    this._initUniforms(this._skyFromAtmosphereProgram.uniforms);
    this._groundFromSpaceProgram.apply();
    this._initUniforms(this._groundFromSpaceProgram.uniforms);
    this._groundFromAtmosphereProgram.apply();
    this._initUniforms(this._groundFromAtmosphereProgram.uniforms);
    for(var c = [], d = [], e = -72;72 >= e;e++) {
      for(var f = e * 0.5 * Math.PI / 72, g = -144;144 >= g;g++) {
        var h = g * Math.PI / 144, i = this._outerRadius * Math.cos(h) * Math.cos(f), h = this._outerRadius * Math.sin(h) * Math.cos(f), j = this._outerRadius * Math.sin(f);
        c.push(i);
        c.push(h);
        c.push(j)
      }
    }
    for(e = 0;144 > e;e++) {
      for(g = 0;288 > g;g++) {
        d.push(289 * e + g), d.push(289 * (e + 1) + g + 1), d.push(289 * e + g + 1), d.push(289 * (e + 1) + g + 1), d.push(289 * e + g), d.push(289 * (e + 1) + g)
      }
    }
    b = b.gl;
    this._vertexBuffer = b.createBuffer();
    b.bindBuffer(b.ARRAY_BUFFER, this._vertexBuffer);
    b.bufferData(b.ARRAY_BUFFER, new Float32Array(c), b.STATIC_DRAW);
    this._indexBuffer = b.createBuffer();
    b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    b.bufferData(b.ELEMENT_ARRAY_BUFFER, new Uint16Array(d), b.STATIC_DRAW);
    this._numIndices = d.length;
    this._originalProgram = a.tileManager.program;
    a.preRenderers.push(this);
    a.tileManager.addPostRenderer(this)
  }
};
GlobWeb.AtmosphereLayer.prototype._initUniforms = function(a) {
  var b = this.globe.renderContext.gl, c = [1, 1, 1];
  vec3.normalize(c);
  b.uniform1f(a.fKrESun, this.kr * this.sunBrightness);
  b.uniform1f(a.fKmESun, this.kr * this.sunBrightness);
  b.uniform1f(a.fKr4PI, 4 * this.kr * Math.PI);
  b.uniform1f(a.fKm4PI, 4 * this.km * Math.PI);
  b.uniform1f(a.fExposure, this.exposure);
  var d = [Math.pow(this.wavelength[0], 4), Math.pow(this.wavelength[1], 4), Math.pow(this.wavelength[2], 4)];
  b.uniform3f(a.v3InvWavelength, 1 / d[0], 1 / d[1], 1 / d[2]);
  b.uniform3f(a.v3LightPos, c[0], c[1], c[2]);
  b.uniform1f(a.fInnerRadius, this._innerRadius);
  b.uniform1f(a.fInnerRadius2, this._innerRadius * this._innerRadius);
  b.uniform1f(a.fOuterRadius, this._outerRadius);
  b.uniform1f(a.fOuterRadius2, this._outerRadius * this._outerRadius);
  b.uniform1f(a.fScale, 1 / (this._outerRadius - this._innerRadius));
  b.uniform1f(a.fScaleDepth, 0.25);
  b.uniform1f(a.fScaleOverScaleDepth, 1 / (this._outerRadius - this._innerRadius) / 0.25);
  b.uniform1f(a.g, -0.95);
  b.uniform1f(a.g2, 0.9025)
};
GlobWeb.AtmosphereLayer.prototype.preRender = function() {
  if(this._isValid) {
    var a = this.globe.tileManager;
    if(this._visible) {
      var b = this.globe.renderContext, c = b.gl, d = b.viewMatrix, e = d[12], f = d[13], g = d[14], d = [-(d[0] * e + d[1] * f + d[2] * g), -(d[4] * e + d[5] * f + d[6] * g), -(d[8] * e + d[9] * f + d[10] * g)], h = vec3.length(d);
      this._skyProgram = h < this._outerRadius ? this._skyFromAtmosphereProgram : this._skyFromSpaceProgram;
      this._groundProgram = h < this._outerRadius ? this._groundFromAtmosphereProgram : this._groundFromSpaceProgram;
      this._skyProgram.apply();
      c.uniform3f(this._skyProgram.uniforms.v3CameraPos, d[0], d[1], d[2]);
      c.uniform1f(this._skyProgram.uniforms.fCameraHeight2, h * h);
      c.uniform1f(this._skyProgram.uniforms.fCameraHeight, h);
      this._groundProgram.apply();
      e = [0, 0, 0];
      mat4.multiplyVec3(b.viewMatrix, e);
      c.uniform3f(this._groundProgram.uniforms.earthCenter, e[0], e[1], e[2]);
      var i = [1, 1, 1];
      vec3.normalize(i);
      var e = i[0], f = i[1], g = i[2], j = b.viewMatrix;
      i[0] = j[0] * e + j[4] * f + j[8] * g;
      i[1] = j[1] * e + j[5] * f + j[9] * g;
      i[2] = j[2] * e + j[6] * f + j[10] * g;
      c.uniform3f(this._groundProgram.uniforms.lightDir, i[0], i[1], i[2]);
      c.uniform3f(this._groundProgram.uniforms.v3CameraPos, d[0], d[1], d[2]);
      c.uniform1f(this._groundProgram.uniforms.fCameraHeight2, h * h);
      c.uniform1f(this._groundProgram.uniforms.fCameraHeight, h);
      a.program = this._groundProgram;
      b.far = 3
    }else {
      a.program = this._originalProgram
    }
  }
};
GlobWeb.AtmosphereLayer.prototype.render = function() {
  if(this._isValid && this._visible) {
    var a = this.globe.renderContext, b = a.gl;
    b.enable(b.CULL_FACE);
    this._skyProgram.apply();
    b.uniformMatrix4fv(this._skyProgram.uniforms.projectionMatrix, !1, a.projectionMatrix);
    b.uniformMatrix4fv(this._skyProgram.uniforms.viewMatrix, !1, a.viewMatrix);
    b.bindBuffer(b.ARRAY_BUFFER, this._vertexBuffer);
    b.vertexAttribPointer(this._skyProgram.attributes.vertex, 3, b.FLOAT, !1, 0, 0);
    b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    b.drawElements(b.TRIANGLES, this._numIndices, b.UNSIGNED_SHORT, 0);
    b.disable(b.CULL_FACE)
  }
};
GlobWeb.GeoTiling = function(a, b) {
  this.level0NumTilesX = a;
  this.level0NumTilesY = b
};
GlobWeb.GeoTiling.prototype.generateLevelZeroTiles = function(a) {
  a.skirt = 1;
  a.cullSign = 1;
  for(var b = [], c = 180 / this.level0NumTilesY, d = 360 / this.level0NumTilesX, e = 0;e < this.level0NumTilesY;e++) {
    for(var f = 0;f < this.level0NumTilesX;f++) {
      var g = new GlobWeb.GeoBound(-180 + f * d, 90 - (e + 1) * c, -180 + (f + 1) * d, 90 - e * c), g = new GlobWeb.GeoTile(g, 0, f, e);
      g.config = a;
      b.push(g)
    }
  }
  return b
};
GlobWeb.GeoTiling.prototype.lonlat2LevelZeroIndex = function(a, b) {
  return Math.floor((90 - b) * this.level0NumTilesY / 180) * this.level0NumTilesX + Math.floor((a + 180) * this.level0NumTilesX / 360)
};
GlobWeb.GeoTile = function(a, b, c, d) {
  GlobWeb.Tile.prototype.constructor.call(this);
  this.geoBound = a;
  this.level = b;
  this.x = c;
  this.y = d
};
GlobWeb.GeoTile.prototype = new GlobWeb.Tile;
GlobWeb.GeoTile.prototype.getElevation = function(a, b) {
  var c = (a - this.geoBound.west) / (this.geoBound.east - this.geoBound.west), d = (b - this.geoBound.north) / (this.geoBound.south - this.geoBound.north), e = 2 * (1 <= d ? 1 : Math.floor(2 * d)) + Math.floor(2 * c);
  if(this.children && this.children[e].state == GlobWeb.Tile.State.LOADED) {
    return this.children[e].getElevation(a, b)
  }
  e = this.config.tesselation;
  c = this.config.vertexSize * (Math.floor(d * e) * e + Math.floor(c * e));
  c = [this.vertices[c], this.vertices[c + 1], this.vertices[c + 2]];
  mat4.multiplyVec3(this.matrix, c);
  return GlobWeb.CoordinateSystem.from3DToGeo(c)[2]
};
GlobWeb.GeoTile.prototype.createChildren = function() {
  var a = 0.5 * (this.geoBound.east + this.geoBound.west), b = 0.5 * (this.geoBound.north + this.geoBound.south), c = this.level + 1, d = new GlobWeb.GeoTile(new GlobWeb.GeoBound(this.geoBound.west, b, a, this.geoBound.north), c, 2 * this.x, 2 * this.y), e = new GlobWeb.GeoTile(new GlobWeb.GeoBound(a, b, this.geoBound.east, this.geoBound.north), c, 2 * this.x + 1, 2 * this.y), f = new GlobWeb.GeoTile(new GlobWeb.GeoBound(this.geoBound.west, this.geoBound.south, a, b), c, 2 * this.x, 2 * this.y + 
  1), a = new GlobWeb.GeoTile(new GlobWeb.GeoBound(a, this.geoBound.south, this.geoBound.east, b), c, 2 * this.x + 1, 2 * this.y + 1);
  d.initFromParent(this, 0, 0);
  e.initFromParent(this, 1, 0);
  f.initFromParent(this, 0, 1);
  a.initFromParent(this, 1, 1);
  this.children = [d, e, f, a]
};
GlobWeb.GeoTile.prototype.lonlat2tile = function(a) {
  for(var b = this.geoBound.east - this.geoBound.west, c = this.geoBound.south - this.geoBound.north, d = this.config.tesselation - 1, e = [], f = 0;f < a.length;f++) {
    e.push([d * (a[f][0] - this.geoBound.west) / b, d * (a[f][1] - this.geoBound.north) / c])
  }
  return e
};
GlobWeb.GeoTile.prototype.generateVertices = function(a) {
  this.matrix = GlobWeb.CoordinateSystem.getLHVTransform(this.geoBound.getCenter());
  var b = mat4.create();
  mat4.inverse(this.matrix, b);
  this.inverseMatrix = b;
  for(var c = this.config.vertexSize, d = this.config.tesselation, e = new Float32Array(c * d * (d + 6)), f = (this.geoBound.east - this.geoBound.west) / (d - 1), g = (this.geoBound.south - this.geoBound.north) / (d - 1), h = GlobWeb.CoordinateSystem.radius, i = GlobWeb.CoordinateSystem.heightScale, j = 0, k = this.geoBound.north * Math.PI / 180, g = g * Math.PI / 180, f = f * Math.PI / 180, l = 0;l < d;l++) {
    for(var m = Math.cos(k), p = Math.sin(k), n = this.geoBound.west * Math.PI / 180, o = 0;o < d;o++) {
      var q = a ? i * a[j] : 0, s = (h + q) * Math.cos(n) * m, r = (h + q) * Math.sin(n) * m, q = (h + q) * p, u = j * c;
      e[u] = b[0] * s + b[4] * r + b[8] * q + b[12];
      e[u + 1] = b[1] * s + b[5] * r + b[9] * q + b[13];
      e[u + 2] = b[2] * s + b[6] * r + b[10] * q + b[14];
      j++;
      n += f
    }
    k += g
  }
  return e
};
GlobWeb.MercatorTiling = function(a) {
  this.startLevel = a
};
GlobWeb.MercatorTiling.prototype.generateLevelZeroTiles = function(a) {
  a.skirt = !0;
  a.cullSign = 1;
  for(var b = [], c = Math.pow(2, this.startLevel), d = Math.pow(2, this.startLevel), e = 0;e < d;e++) {
    for(var f = 0;f < c;f++) {
      var g = new GlobWeb.MercatorTile(this.startLevel, f, e);
      g.config = a;
      b.push(g)
    }
  }
  return b
};
GlobWeb.MercatorTiling.prototype.lonlat2LevelZeroIndex = function() {
  return 0
};
GlobWeb.MercatorTiling.tile2long = function(a, b) {
  return 360 * (a / Math.pow(2, b)) - 180
};
GlobWeb.MercatorTiling.tile2lat = function(a, b) {
  var c = Math.PI - 2 * Math.PI * a / Math.pow(2, b);
  return 180 / Math.PI * Math.atan(0.5 * (Math.exp(c) - Math.exp(-c)))
};
GlobWeb.MercatorTile = function(a, b, c) {
  GlobWeb.Tile.prototype.constructor.call(this);
  this.level = a;
  this.x = b;
  this.y = c;
  this.geoBound = new GlobWeb.GeoBound(GlobWeb.MercatorTiling.tile2long(b, a), GlobWeb.MercatorTiling.tile2lat(c + 1, a), GlobWeb.MercatorTiling.tile2long(b + 1, a), GlobWeb.MercatorTiling.tile2lat(c, a))
};
GlobWeb.MercatorTile.prototype = new GlobWeb.Tile;
GlobWeb.MercatorTile.prototype.getElevation = function() {
  return 0
};
GlobWeb.MercatorTile.prototype.createChildren = function() {
  var a = new GlobWeb.MercatorTile(this.level + 1, 2 * this.x, 2 * this.y), b = new GlobWeb.MercatorTile(this.level + 1, 2 * this.x + 1, 2 * this.y), c = new GlobWeb.MercatorTile(this.level + 1, 2 * this.x, 2 * this.y + 1), d = new GlobWeb.MercatorTile(this.level + 1, 2 * this.x + 1, 2 * this.y + 1);
  a.initFromParent(this, 0, 0);
  b.initFromParent(this, 1, 0);
  c.initFromParent(this, 0, 1);
  d.initFromParent(this, 1, 1);
  this.children = [a, b, c, d]
};
GlobWeb.MercatorTile.prototype.lonlat2tile = function(a) {
  for(var b = Math.pow(2, this.level), c = this.config.tesselation - 1, d = [], e = 0;e < a.length;e++) {
    var f = (a[e][0] + 180) / 360, g = Math.sin(a[e][1] * Math.PI / 180), g = 0.5 - Math.log((1 + g) / (1 - g)) / (4 * Math.PI);
    d.push([c * (f * b - this.x), c * (g * b - this.y)])
  }
  return d
};
GlobWeb.MercatorTile.prototype.generateVertices = function(a) {
  this.matrix = GlobWeb.CoordinateSystem.getLHVTransform(this.geoBound.getCenter());
  var b = mat4.create();
  mat4.inverse(this.matrix, b);
  this.inverseMatrix = b;
  for(var c = this.config.tesselation, d = new Float32Array(3 * c * (c + 6)), e = 1 / (c - 1), f = GlobWeb.CoordinateSystem.radius, g = GlobWeb.CoordinateSystem.heightScale, h = 0, i = Math.pow(2, this.level), j = this.y, k = 0;k < c;k++) {
    for(var l = Math.PI * (1 - 2 * j / i), m = Math.atan(0.5 * (Math.exp(l) - Math.exp(-l))), l = Math.cos(m), m = Math.sin(m), p = this.x, n = 0;n < c;n++) {
      var o = Math.PI * (2 * p / i - 1), q = a ? g * a[h] : 0, s = (f + q) * Math.cos(o) * l, o = (f + q) * Math.sin(o) * l, q = (f + q) * m, r = 3 * h;
      d[r] = b[0] * s + b[4] * o + b[8] * q + b[12];
      d[r + 1] = b[1] * s + b[5] * o + b[9] * q + b[13];
      d[r + 2] = b[2] * s + b[6] * o + b[10] * q + b[14];
      h++;
      p += e
    }
    j += e
  }
  return d
};
GlobWeb.WMSLayer = function(a) {
  GlobWeb.RasterLayer.prototype.constructor.call(this, a);
  this.baseUrl = a.baseUrl;
  this.tilePixelSize = a.tilePixelSize || 256;
  this.tiling = new GlobWeb.GeoTiling(4, 2);
  this.numberOfLevels = a.numberOfLevels || 21;
  this.type = "ImageryRaster";
  var b = this.baseUrl, b = -1 == b.indexOf("?", 0) ? b + "?service=wms" : b + "&service=wms", b = b + "&version=" + (a.hasOwnProperty("version") ? a.version : "1.1.1"), b = b + "&request=GetMap&srs=" + (a.hasOwnProperty("srs") ? a.srs : "EPSG:4326"), b = b + ("&layers=" + a.layers);
  a.hasOwnProperty("styles") && (b += "&styles=" + a.styles);
  b = b + "&format=" + (a.hasOwnProperty("format") ? a.format : "image/jpeg");
  a.hasOwnProperty("transparent") && (b += "&transparent=" + a.transparent);
  b = b + "&width=" + this.tilePixelSize;
  b = b + "&height=" + this.tilePixelSize;
  a.hasOwnProperty("time") && (b += "&time=" + a.time);
  this.getMapBaseUrl = b
};
GlobWeb.inherits(GlobWeb.RasterLayer, GlobWeb.WMSLayer);
GlobWeb.WMSLayer.prototype.getUrl = function(a) {
  var a = a.geoBound, b = this.getMapBaseUrl, b = b + "&bbox=" + a.west, b = b + "," + a.south, b = b + "," + a.east;
  return b = b + "," + a.north
};
GlobWeb.WMTSLayer = function(a) {
  GlobWeb.RasterLayer.prototype.constructor.call(this, a);
  this.baseUrl = a.baseUrl;
  this.tilePixelSize = a.tilePixelSize || 256;
  this.tiling = new GlobWeb.GeoTiling(4, 2);
  this.numberOfLevels = a.numberOfLevels || 21;
  this.type = "ImageryRaster";
  this.startLevel = a.startLevel || 1;
  var b = this.baseUrl, b = -1 == b.indexOf("?", 0) ? b + "?service=wmts" : b + "&service=wmts", b = b + "&version=" + (a.hasOwnProperty("version") ? a.version : "1.0.0"), b = b + "&request=GetTile" + ("&layer=" + a.layer), b = b + ("&tilematrixset=" + a.matrixSet);
  a.hasOwnProperty("style") && (b += "&style=" + a.style);
  this.getTileBaseUrl = b = b + "&format=" + (a.hasOwnProperty("format") ? a.format : "image/png")
};
GlobWeb.inherits(GlobWeb.RasterLayer, GlobWeb.WMTSLayer);
GlobWeb.WMTSLayer.prototype.getUrl = function(a) {
  var b = this.getTileBaseUrl, b = b + "&tilematrix=" + (a.level + this.startLevel), b = b + ("&tilecol=" + a.x);
  return b += "&tilerow=" + a.y
};
GlobWeb.WCSElevationLayer = function(a) {
  GlobWeb.RasterLayer.prototype.constructor.call(this, a);
  this.baseUrl = a.baseUrl;
  this.tilePixelSize = a.tilePixelSize || 33;
  this.tiling = new GlobWeb.GeoTiling(4, 2);
  this.numberOfLevels = a.numberOfLevels || 21;
  this.type = "ImageryRaster";
  this.version = a.version || "2.0.0";
  this.format = a.format || "image/x-aaigrid";
  var b = this.baseUrl, b = -1 == b.indexOf("?", 0) ? b + "?service=wcs" : b + "&service=wcs", b = b + ("&version=" + this.version), b = b + "&request=GetCoverage";
  switch(this.version.substring(0, 3)) {
    case "2.0":
      this.crs = a.outputCRS || a.crs || "http://www.opengis.net/def/crs/EPSG/0/4326";
      b += "&outputCRS=" + this.crs;
      b += "&size=x(" + this.tilePixelSize + ")";
      b += "&size=y(" + this.tilePixelSize + ")";
      b += "&coverageid=" + a.coverage;
      break;
    case "1.0":
      b += "&width=" + this.tilePixelSize, b += "&height=" + this.tilePixelSize, b += "&crs=" + (a.crs || "EPSG:4326"), b += "&coverage=" + a.coverage
  }
  this.getCoverageBaseUrl = b += "&format=" + this.format
};
GlobWeb.inherits(GlobWeb.RasterLayer, GlobWeb.WCSElevationLayer);
GlobWeb.WCSElevationLayer.prototype.parseElevations = function(a) {
  if(null == a) {
    return this._returnZeroElevations()
  }
  switch(this.format) {
    case "image/x-aaigrid":
      return this._parseAAIGrid(a);
    default:
      return console.log("Format '" + this.format + "' could not be parsed."), this._returnZeroElevations()
  }
};
GlobWeb.WCSElevationLayer.prototype._returnZeroElevations = function() {
  for(var a = [], b = 0;b < this.tilePixelSize * this.tilePixelSize;++b) {
    a.push(0)
  }
  return a
};
GlobWeb.WCSElevationLayer.prototype._parseAAIGrid = function(a) {
  for(var b = [], a = a.trim().split("\n"), c = 0, d = 0;d < a.length;++d) {
    if(" " === a[d].substring(0, 1)) {
      c = d;
      break
    }
  }
  for(d = c;d < a.length;d++) {
    for(var c = a[d].trim().split(/\s+/), e = 0;e < c.length;e++) {
      b.push(parseInt(c[e]))
    }
  }
  return b
};
GlobWeb.WCSElevationLayer.prototype.getUrl = function(a) {
  var a = a.geoBound, b = this.getCoverageBaseUrl;
  "2.0" === this.version.substring(0, 3) ? (b += "&subset=x," + this.crs + "(" + a.west + "," + a.east + ")", b += "&subset=y," + this.crs + "(" + a.south + "," + a.north + ")") : "1.0" === this.version.substring(0, 3) && (b = b + "&bbox=" + a.west, b = b + "," + a.south, b = b + "," + a.east, b = b + "," + a.north);
  return b
};
GlobWeb.BingTileSystem = function() {
  return{tileXYToQuadKey:function(a, b, c) {
    for(var d = "";0 < c;c--) {
      var e = "0", f = 1 << c - 1;
      0 != (a & f) && e++;
      0 != (b & f) && (e++, e++);
      d += e
    }
    return d
  }, latLongToPixelXY:function(a, b, c) {
    a = Math.min(Math.max(a, -85.05112878), 85.05112878);
    b = Math.min(Math.max(b, -180), 180);
    b = (b + 180) / 360;
    a = Math.sin(a * Math.PI / 180);
    a = 0.5 - Math.log((1 + a) / (1 - a)) / (4 * Math.PI);
    c = 256 << c;
    b = Math.min(Math.max(b * c + 0.5, 0), c - 1);
    c = Math.min(Math.max(a * c + 0.5, 0), c - 1);
    return[Math.floor(b), Math.floor(c)]
  }}
}();
GlobWeb.BingLayer = function(a) {
  GlobWeb.RasterLayer.prototype.constructor.call(this, a);
  this.tilePixelSize = 256;
  this.tiling = new GlobWeb.MercatorTiling(a.baseLevel || 2);
  this.numberOfLevels = 18;
  this.type = "ImageryRaster";
  this.ready = !1;
  this.baseUrl = "";
  this.baseUrlSubDomains = [];
  var b = this;
  window._bingTileProviderCallback = function(c) {
    b.baseUrl = c.resourceSets[0].resources[0].imageUrl;
    b.baseUrlSubDomains = c.resourceSets[0].resources[0].imageUrlSubdomains;
    b.ready = !0;
    if(a.onready && a.onready instanceof Function) {
      a.onready(b)
    }
    b.globe && b.globe.renderContext.requestFrame()
  };
  var c = document.createElement("script");
  c.type = "text/javascript";
  c.src = "http://dev.virtualearth.net/REST/V1/Imagery/Metadata/" + a.imageSet + "?jsonp=_bingTileProviderCallback&key=" + a.key;
  c.id = "_bingTileProviderCallback";
  document.getElementsByTagName("head")[0].appendChild(c)
};
GlobWeb.inherits(GlobWeb.RasterLayer, GlobWeb.BingLayer);
GlobWeb.BingLayer.prototype.getUrl = function(a) {
  return this.baseUrl.replace("{quadkey}", GlobWeb.BingTileSystem.tileXYToQuadKey(a.x, a.y, a.level)).replace("{subdomain}", this.baseUrlSubDomains[Math.floor(Math.random() * this.baseUrlSubDomains.length)])
};
GlobWeb.OSMLayer = function(a) {
  GlobWeb.RasterLayer.prototype.constructor.call(this, a);
  this.tilePixelSize = a.tilePixelSize || 256;
  this.tiling = new GlobWeb.MercatorTiling(a.baseLevel || 2);
  this.numberOfLevels = a.numberOfLevels || 21;
  this.type = "ImageryRaster";
  this.baseUrl = a.baseUrl
};
GlobWeb.inherits(GlobWeb.RasterLayer, GlobWeb.OSMLayer);
GlobWeb.OSMLayer.prototype.getUrl = function(a) {
  return this.baseUrl + "/" + a.level + "/" + a.x + "/" + a.y + ".png"
};

